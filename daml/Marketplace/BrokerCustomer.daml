module Marketplace.BrokerCustomer where

import Marketplace.Notification
import Marketplace.Token
import Marketplace.Trading
import Marketplace.Utils

import DA.Finance.Asset


template BrokerCustomerInvitation
  with
    operator : Party
    broker : Party
    brokerCustomer : Party
  where
    signatory broker, operator
    observer brokerCustomer

    choice BrokerCustomerInvitation_Accept : ContractId BrokerCustomer
      controller brokerCustomer
      do
        create DismissibleNotification with
          sender = brokerCustomer, senderRole = Some InvestorRole
          receiver = broker, text = "Broker customer invitation accepted."
        create BrokerCustomer with ..
    choice BrokerCustomerInvitation_Reject : ()
      controller brokerCustomer
      do
        create DismissibleNotification with
          sender = brokerCustomer, senderRole = Some InvestorRole
          receiver = broker, text = "Broker customer invitation rejected."
        return ()


template BrokerCustomer
  with
    operator : Party
    broker : Party
    brokerCustomer : Party
  where
    signatory broker, brokerCustomer, operator

    key (broker, operator, brokerCustomer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice BrokerCustomer_RequestBid : ContractId BrokerOrderRequest
      with
        depositCid : ContractId AssetDeposit
        pair : IdPair
        price : Decimal
      controller brokerCustomer
      do
        deposit <- fetch depositCid
        assertMsg ("deposit is not allocated to broker " <> show broker)
          $ deposit.account.id.label == getAccountLabel brokerCustomer broker
        assertMsg ("deposit should be for " <> pair._2.label <> " but it is for " <> deposit.asset.id.label)
          $ pair._2 == deposit.asset.id
        (_, quoteToken) <- fetchByKey @Token pair._2
        assertMsg ("price should be rounded to at most " <> show quoteToken.quantityPrecision <> " decimal places")
          $ roundBankers quoteToken.quantityPrecision price == price
        (_, baseToken) <- fetchByKey @Token pair._1
        let qty = roundBankers baseToken.quantityPrecision $ deposit.asset.quantity / price
        create BrokerOrderRequest with isBid = True, ..

    nonconsuming choice BrokerCustomer_RequestOffer : ContractId BrokerOrderRequest
      with
        depositCid : ContractId AssetDeposit
        pair : IdPair
        price : Decimal
      controller brokerCustomer
      do
        deposit <- fetch depositCid
        assertMsg ("deposit is not allocated to broker " <> show broker)
          $ deposit.account.id.label == getAccountLabel brokerCustomer broker
        assertMsg ("deposit should be for " <> pair._1.label <> " but it is for " <> deposit.asset.id.label)
          $ pair._1 == deposit.asset.id
        (_, quoteToken) <- fetchByKey @Token pair._2
        assertMsg ("price should be rounded to at most " <> show quoteToken.quantityPrecision <> " decimal places")
          $ roundBankers quoteToken.quantityPrecision price == price
        (_, baseToken) <- fetchByKey @Token pair._1
        let qty = roundBankers baseToken.quantityPrecision deposit.asset.quantity
        create BrokerOrderRequest with isBid = False, ..
