module Marketplace.Trading where

import Marketplace.BinaryOption
import Marketplace.Custodian
import Marketplace.Token
import Marketplace.Transfer
import Marketplace.Utils

import DA.Next.Set (Set)
import DA.Next.Set qualified as Set

import DA.Finance.Asset
import DA.Finance.Types

import DA.Math

template Settlement
  with
    exchange : Party
    receiverAccount : Account
    depositCid : ContractId AssetDeposit
    signatures : Set Party
  where
    signatory exchange :: Set.toList signatures
    choice Settlement_Sign : ContractId Settlement
      with
        party : Party
      controller party
      do
        create this with signatures = Set.insert party signatures
    controller exchange can
      Settlement_Settle : ContractId AssetDeposit
        do
          exercise depositCid AssetDeposit_Transfer with ..

template SettlementAgreement
  with
    operator : Party
    exchange : Party
    exchParticipant : Party
  where
    signatory exchange, exchParticipant
    key (exchange, exchParticipant) : (Party, Party)
    maintainer key._1

    controller exchange can
      nonconsuming SettlementAgreement_SignSettlement : ContractId Settlement
        with
          settlementCid : ContractId Settlement
        do
          exercise settlementCid Settlement_Sign with party = exchParticipant

template OrderRequest
  with
    order : Order
  where
    signatory order.exchange, order.exchParticipant
    ensure order.qty > 0.0

    controller order.exchange can
      OrderRequest_Ack : ContractId Order
        with
          orderId : Int
        do create order with orderId = orderId

      OrderRequest_Reject : ContractId AssetDeposit
        do
          exercise order.depositCid AssetDeposit_Unlock

    controller order.exchParticipant can
      OrderRequest_Cancel : ContractId AssetDeposit
        do
          exercise order.depositCid AssetDeposit_Unlock


template OrderCancelRequest
  with
    order : Order
  where
    signatory order.exchange, order.exchParticipant

    key (order.exchange, order.orderId) : (Party, Int)
    maintainer key._1

    controller order.exchange can
      OrderCancel_Ack : ContractId AssetDeposit
        do exerciseByKey @Order (order.exchange, order.orderId) Order_Cancel

      OrderCancel_Reject : ()
        do return ()


template Order
  with
    exchange : Party
    exchParticipant : Party
    pair : IdPair
    isBid : Bool
    price : Decimal
    qty : Decimal
    depositCid : ContractId AssetDeposit
    account : Account
    status : Text
    orderId : Int
    createdAt : Time
  where
    let tokenObservers = if isBid
                         then pair._2.signatories
                         else pair._1.signatories
    signatory exchange, exchParticipant
    observer tokenObservers
    ensure qty > 0.0

    key (exchange, orderId) : (Party, Int)
    maintainer key._1

    controller exchange can
      Order_FillBinaryOption : (ContractId TradeSide, Optional (ContractId Order))
        with
          fillQty : Decimal
          fillPrice : Decimal
          counterParty : Party
          counterOrderId : Int
          timeMatched : Text
        do
          assertMsg "Fill quantity must be greater than 0" $ fillQty > 0.0
          assertMsg "Fill quantity must be less than or equal to order quantity" $ fillQty <= qty
          assertMsg "Fill price is outside of the order's price bounds"
                 $ if isBid then fillPrice <= price
                            else fillPrice >= price
          let senderAccountId = Id
                with signatories = account.id.signatories,
                      label = getAccountLabel exchParticipant exchange, version = 0
          let receiverAccountId = Id
                with signatories = account.id.signatories,
                      label = getAccountLabel counterParty exchange, version = 0
              isBinaryOption = True
          (_, binOption) <- fetchByKey @BinaryOption pair._1
          (_, quoteToken) <- fetchByKey @Token pair._2
          if fillQty < qty then do
            let depositFillQty = roundBankers quoteToken.quantityPrecision $
                                    if isBid then fillQty * fillPrice
                                    else fillQty * (binOption.maxPrice - fillPrice)
            [filledDepositCid, restDepositCid] <- exercise depositCid AssetDeposit_Split with quantities = [depositFillQty]
            remainingCid <- create this
              with qty = qty - fillQty, status = "PartiallyFilled", depositCid = restDepositCid
            tradeCid <- create TradeSide with
                isBuy = isBid, optDepositCid = Some filledDepositCid
                qty = fillQty, price = fillPrice, ..

            return $ (tradeCid, Some remainingCid)
          else do
            tradeCid <- create TradeSide with isBuy = isBid, optDepositCid = Some depositCid, price = fillPrice, ..
            return $ (tradeCid, None)

      Order_Fill : (ContractId TradeSide, Optional (ContractId Order))
        with
          fillQty : Decimal
          fillPrice : Decimal
          counterParty : Party
          counterOrderId : Int
          timeMatched : Text
        do
          assertMsg "Fill quantity must be greater than 0" $ fillQty > 0.0
          assertMsg "Fill quantity must be less than or equal to order quantity"
            $ fillQty <= qty
          assertMsg "Fill price is outside of the order's price bounds"
                 $ if isBid then fillPrice <= price
                            else fillPrice >= price

          let receiverAccountId = Id
                with signatories = account.id.signatories,
                      label = getAccountLabel counterParty exchange, version = 0
              isBinaryOption = False
          let senderAccountId = Id
                with signatories = account.id.signatories,
                      label = getAccountLabel exchParticipant exchange, version = 0
          (_, baseToken) <- fetchByKey @Token pair._1
          (_, quoteToken) <- fetchByKey @Token pair._2
          if fillQty < qty then do
            deposit <- fetch depositCid
            let minFillQty = 10.0 ** (- intToDecimal if isBid then quoteToken.quantityPrecision
                                                              else baseToken.quantityPrecision)
            let depositFillQty = min (if isBid
                                      then roundBankers quoteToken.quantityPrecision $ fillQty * fillPrice
                                      else fillQty)
                                     (deposit.asset.quantity - minFillQty)
            if (depositFillQty > 0.0 && depositFillQty < deposit.asset.quantity)
            then do
              [filledDepositCid, restDepositCid] <- exercise depositCid AssetDeposit_Split with quantities = [depositFillQty]

              remainingCid <- create this
                with qty = qty - fillQty, status = "PartiallyFilled"
                     depositCid = restDepositCid

              tradeCid <- create TradeSide with
                  isBuy = isBid, optDepositCid = Some filledDepositCid
                  qty = fillQty, price = fillPrice, ..

              return $ (tradeCid, Some remainingCid)
            else do
              -- the fillQty is not enough to warrant a deposit transfer
              remainingCid <- create this with qty = qty - fillQty, status = "PartiallyFilled"
              tradeCid <- create TradeSide with
                  isBuy = isBid, optDepositCid = None
                  qty = fillQty, price = fillPrice, ..

              return $ (tradeCid, Some remainingCid)
          else do
            tradeCid <- create TradeSide with
                isBuy = isBid, optDepositCid = Some depositCid
                price = fillPrice, ..

            return $ (tradeCid, None)

      Order_Cancel : ContractId AssetDeposit
        do
          exercise depositCid AssetDeposit_Unlock

    controller exchParticipant can
      nonconsuming Order_RequestCancel : ContractId OrderCancelRequest
        do createOrLookup OrderCancelRequest with order = this


assetSplit : Asset -> [Decimal] -> [Asset]
assetSplit asset quantities = map (\q -> asset with quantity = q) quantitiesAll
  where
    quantitySum = foldl (+) 0.0 quantities
    quantitiesAll = if quantitySum == asset.quantity
                    then quantities
                    else quantities ++ [asset.quantity - quantitySum]


template BrokerOrderRequest
  with
    operator : Party
    brokerCustomer : Party
    broker : Party
    depositCid : ContractId AssetDeposit
    pair : IdPair
    isBid : Bool
    price : Decimal
    qty : Decimal
  where
    signatory broker, brokerCustomer, operator

    controller broker can
      BrokerOrderRequest_Accept : (ContractId BrokerOrder, ContractId DepositTransferRequest)
        with
          brokerOrderId : Int
        do
          deposit <- fetch depositCid
          assertMsg "Deposit account does not belong to brokerCustomer" $ deposit.account.owner == brokerCustomer
          brokerOrderCid <- create BrokerOrder with ..
          let receiverAccountId = Id with signatories = deposit.account.id.signatories, label = getAccountLabel broker broker, version = 0
          let custodian = getCustodian deposit.account.id operator
          -- depositTransferReqCid <- exerciseByKey @CustodianRelationship (custodian, operator, brokerCustomer) CustodianRelationship_RequestTransfer with
                -- request =
          depositTransferReqCid <- create DepositTransferRequest with sender = brokerCustomer, senderAccountId = deposit.account.id, ..
          return (brokerOrderCid, depositTransferReqCid)


template BrokerOrder
  with
    operator : Party
    brokerCustomer : Party
    broker : Party
    pair : IdPair
    isBid : Bool
    price : Decimal
    qty : Decimal
    brokerOrderId : Int
  where
    signatory broker, brokerCustomer, operator

    key (broker, brokerOrderId) : (Party, Int)
    maintainer key._1

    controller broker can
      BrokerOrder_Fill : ContractId DepositTransferRequest
        with
          depositCid : ContractId AssetDeposit
        do
          deposit <- fetch depositCid
          assertMsg ("the owner of the deposit is not broker: " <> show broker)
            $ deposit.account.owner == broker
          (_, baseToken) <- fetchByKey @Token pair._1
          (_, quoteToken) <- fetchByKey @Token pair._2
          let depositToken = if isBid then baseToken else quoteToken
          assertMsg ("deposit should be for " <> depositToken.id.label
            <> " but it is for " <> deposit.asset.id.label)
            $ deposit.asset.id == depositToken.id
          let depositQty = if isBid then deposit.asset.quantity
                           else roundBankers baseToken.quantityPrecision $ deposit.asset.quantity / price
          assertMsg ("the deposit quantity of " <> show depositQty
            <> " does not match the requested of " <> show qty) $ depositQty == qty
          let senderAccountId = deposit.account.id
              receiverAccountId = Id with signatories = deposit.account.id.signatories, label = getAccountLabel brokerCustomer broker, version = 0
          create BrokerTrade with isBuy = isBid, ..
          create DepositTransferRequest with sender = broker, ..

template ClearedOrderRequest
  with
    order : ClearedOrder
  where
    signatory order.ccp, order.exchParticipant
    ensure order.qty > 0.0

    controller order.exchange can
      ClearedOrderRequest_Ack : ContractId ClearedOrder
        with
          orderId : Int
        do create order with orderId = orderId

      ClearedOrderRequest_Reject : ()
        do return ()
    controller order.exchParticipant can
      ClearedOrderRequest_Cancel : ()
        do return ()

-- TODO: Allow for cancelling pending orders
template ClearedOrder
  with
    ccp : Party
    exchange : Party
    exchParticipant : Party
    pair : IdPair
    isBid : Bool
    price : Decimal
    qty : Decimal
    status : Text
    orderId : Int
    createdAt : Time
  where
    signatory exchange, exchParticipant
    ensure qty > 0.0

    key (exchange, orderId) : (Party, Int)
    maintainer key._1

    controller exchange can
      ClearedOrder_Fill : Optional (ContractId ClearedOrder)
        with
          fillQty : Decimal
          fillPrice : Decimal
        do
          assertMsg "Fill quantity must be greater than 0" $ fillQty > 0.0
          assertMsg "Fill quantity must be less than or equal to order quantity" $ fillQty <= qty
          assertMsg "Fill price is outside of the order's price bounds"
                 $ if isBid then fillPrice <= price
                            else fillPrice >= price

          if qty == fillQty
            then do return None
            else do
              partialOrder <- create this with
                qty = qty - fillQty, status = "PartiallyFilled"

              return $ Some partialOrder

      ClearedOrder_Cancel : ()
        do return ()

    controller exchParticipant can
      nonconsuming ClearedOrder_RequestCancel : ContractId ClearedOrderCancelRequest
        do createOrLookup ClearedOrderCancelRequest with order = this

template ClearedOrderCancelRequest
  with
    order : ClearedOrder
  where
    signatory order.exchange, order.exchParticipant

    key (order.exchange, order.orderId) : (Party, Int)
    maintainer key._1

    controller order.exchange can
      ClearedOrderCancel_Ack : ()
        do
          exerciseByKey @ClearedOrder (order.exchange, order.orderId) ClearedOrder_Cancel
          return ()

      ClearedOrderCancel_Reject : ()
        do return ()

-- TODO: Replace DerivativeTrade with ClearedTrade
template ClearedTrade
  with
    ccp : Party
    exchange : Party
    instrument : Id  -- id of order
    pair : IdPair
    executedQuantity : Decimal
    executedPrice : Decimal
    buyer : Party
    buyerOrderId : Int
    seller : Party
    sellerOrderId : Int
    eventId : Int
    timeMatched : Text
    matchId : Int
    trackingNumber : Int
  where
    signatory exchange
    observer ccp
    controller ccp can
      ClearedTrade_Novate : (ContractId ClearedTradeSide, ContractId ClearedTradeSide)
        with
          buyerAccountId : Id
          sellerAccountId : Id
        do
          timeNovated <- getTime
          buyCid <- create ClearedTradeSide with
            participant = buyer
            orderId = buyerOrderId
            accountId = buyerAccountId
            isBuy = True
            qty = executedQuantity
            price = executedPrice
            counterOrderId = sellerOrderId
            ..
          sellCid <- create ClearedTradeSide with
            participant = seller
            orderId = sellerOrderId
            accountId = sellerAccountId
            isBuy = False
            qty = executedQuantity
            price = executedPrice
            counterOrderId = buyerOrderId
            ..
          return (buyCid, sellCid)


template ClearedTradeSide
  with
    ccp : Party
    exchange : Party
    participant : Party
    instrument : Id
    pair : IdPair
    isBuy : Bool
    qty : Decimal
    price : Decimal
    timeMatched : Text -- previously eventTimestamp
    timeNovated : Time -- previously timestamp
    orderId : Int
    counterOrderId : Int
    accountId : Id  -- the investor account at the ccp
    eventId : Int
    matchId : Int
  where
    signatory ccp, exchange
    observer exchange, participant

template DerivativeTrade
  with
    ccp : Party
    exchange : Party
    eventId : Int
    eventTimestamp : Text
    instrument : Id  -- id of Derivative
    trackingNumber : Int
    buyer : Party
    buyerOrderId : Int
    seller : Party
    sellerOrderId : Int
    matchId : Int
    executedQuantity : Decimal
    executedPrice : Decimal
  where
    signatory exchange
    observer ccp
    controller ccp can
      DerivativeTrade_Novate : (ContractId DerivativeTradeSide, ContractId DerivativeTradeSide)
        with
          buyerAccountId : Id
          sellerAccountId : Id
        do
          timestamp <- getTime
          buyCid <- create DerivativeTradeSide with
            participant = buyer
            orderId = buyerOrderId
            accountId = buyerAccountId
            isBuy = True
            ..
          sellCid <- create DerivativeTradeSide with
            participant = seller
            orderId = sellerOrderId
            accountId = sellerAccountId
            isBuy = False
            ..
          return (buyCid, sellCid)


template DerivativeTradeSide
  with
    participant : Party
    ccp : Party
    exchange : Party
    isBuy : Bool
    eventId : Int
    eventTimestamp : Text
    instrument : Id
    orderId : Int
    matchId : Int
    executedQuantity : Decimal
    executedPrice : Decimal
    accountId : Id  -- the investor account at the ccp
    timestamp : Time
  where
    signatory ccp, exchange
    observer exchange, participant


template TradeSide
  with
    exchParticipant : Party
    exchange : Party
    pair : IdPair
    price : Decimal
    qty : Decimal
    isBuy : Bool
    orderId : Int
    counterOrderId : Int
    timeMatched : Text
    optDepositCid : Optional (ContractId AssetDeposit)
    receiverAccountId : Id
    senderAccountId : Id
    isBinaryOption : Bool
  where
    signatory exchange, exchParticipant

    let getAccount : Id -> Account
        getAccount accountId = account
          where
            (party, partyProvider) = getAccountOwnerProvider accountId.label
            account = Account with id = accountId, provider = partyProvider, owner = party

    controller exchange can
      TradeSide_Settle : (ContractId SettledTradeSide, [ContractId AssetDeposit])
        do
          assertMsg "Binary option settlement must be done with the SettleBinaryOption choice." $ not isBinaryOption
          depositCids <- case optDepositCid of
            Some depositCid -> do
              deposit <- fetch depositCid
              (sendDepositCid, restDepositCids) <-
                if isBuy && (deposit.asset.quantity > qty * price)
                then do
                  -- let [sendAsset, restAsset] = assetSplit asset [qty * price]
                  [sendDepositCid, restDepositCid] <- exercise depositCid AssetDeposit_Split with quantities = [qty * price]

                  restDepositCid' <- exercise restDepositCid AssetDeposit_Unlock

                  return (sendDepositCid, [restDepositCid'])
                else return (depositCid, [])

              let receiverAccount = getAccount receiverAccountId

              settlementCid <- create Settlement with depositCid = sendDepositCid, signatures = mempty, ..
              settlementCid <- exerciseByKey @SettlementAgreement (exchange, exchParticipant) SettlementAgreement_SignSettlement with ..
              settlementCid <- exerciseByKey @SettlementAgreement (exchange, receiverAccount.owner) SettlementAgreement_SignSettlement with ..
              transferredDepositCid <- exercise settlementCid Settlement_Settle

              return $ transferredDepositCid :: restDepositCids
            None -> return []
          settledTradeCid <- create SettledTradeSide with ..
          return (settledTradeCid, depositCids)

      TradeSide_SettleBinaryOption : (ContractId SettledTradeSide, Optional (ContractId AssetDeposit))
        with
          settledBinOptionCid : ContractId SettledBinaryOption
        do
          assertMsg "Only binary option trades can be settled with this choice." isBinaryOption
          settledBinOption <- fetch settledBinOptionCid
          let needsTransfer = settledBinOption.outcome /= isBuy
          optDepositCid <- case (optDepositCid, needsTransfer) of
            (Some depositCid, True) -> do
              let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
                  receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
              transferredDepositCid <- exercise depositCid AssetDeposit_Transfer with ..
              return $ Some transferredDepositCid
            _ -> return None
          settledTradeCid <- create SettledTradeSide with ..
          return (settledTradeCid, optDepositCid)


template SettledTradeSide
  with
    exchParticipant : Party
    exchange : Party
    pair : IdPair
    price : Decimal
    qty : Decimal
    isBuy : Bool
    orderId : Int
    counterOrderId : Int
    timeMatched : Text
  where
    signatory exchange, exchParticipant


template BrokerTrade
  with
    brokerCustomer : Party
    broker : Party
    pair : IdPair
    price : Decimal
    qty : Decimal
    isBuy : Bool
    brokerOrderId : Int
  where
    signatory broker, brokerCustomer
