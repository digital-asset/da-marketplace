-- TODO DRY: refactor opportunity: embed Order/Trading in these files.
-- Use proper namespace
module Marketplace.Trading where

import DA.Assert ((===))
import DA.Finance.Asset (AssetDeposit, AssetDeposit_Split(..))
import DA.Finance.Asset.Settlement (AssetSettlementRule, AssetSettlement_Transfer(..))
import DA.Finance.Trade.SettlementInstruction (SettlementInstruction(..), SettlementInstruction_Process(..), SettlementDetails(..))
import DA.Finance.Trade.Dvp (Dvp(..), SettlementStatus(..))
import DA.Finance.Types (Id(..), Asset(..), Account, MasterAgreement(..))
import DA.Finance.Utils (assertOnOrAfterDateMsg, zipChecked, fetchAndArchive)
import DA.List (head, last)
import DA.Next.Set (Set, empty, insert, fromList)
import DA.Optional (whenSome)
import Marketplace.Listing (Listing)

data Side
    = Buy
    | Sell
  deriving (Eq, Show)

data OrderType
    = Market
    | Limit with
        price : Decimal
  deriving (Eq, Show)

data TimeInForce
    = GTC
      -- ^ Good Till Cancelled (Rests on book until cancellation)
    | GTD with
        expiryDate : Int
      -- ^ Good Till Date (At expiryDate, order will be automatically cancelled).
      -- UTC date and time in seconds
    | GAA
      -- ^ Good At Auction (Expires after auction if not filled)
    | IOC
      -- ^ Immediate Or Cancel (Allows for partial fills)
    | FOK
      -- ^ Fill Or Kill (All or nothing)
  deriving (Eq, Show)

data OrderDetails = OrderDetails with
    id : Id
    symbol : Text
    asset : Asset
    side : Side
    orderType : OrderType
    timeInForce : TimeInForce
  deriving (Eq, Show)

data Status
    = New
    | PendingExecution
    | PartiallyExecuted
    | FullyExecuted
    | Rejected with
        errorCode : Int
        errorMessage : Text
    | PendingCancellation
    | CancellationRejected with
        errorCode : Int
        errorMessage : Text
    | Cancelled
  deriving (Eq, Show)

data ExecutionFill = ExecutionFill with
    matchId : Text
    makerOrderId : Text
    takerOrderId : Text
    executedQuantity : Decimal
    executedPrice : Decimal
    executedTimestamp : Text -- Should this be an Int so we can order if necessary?
  deriving (Eq, Show)

template Order
  with
    operator : Party
    provider : Party
    customer : Party
    status : Status
    orderDetails : OrderDetails
    providerOrderId : Optional Text
    executionFills : [ExecutionFill]
    remainingQuantity : Decimal
    depositCid : ContractId AssetDeposit
  where
    signatory operator, provider, customer

    key (provider, orderDetails.id.label) : (Party, Text)
    maintainer key._1

    controller operator, provider can
      InstructTrade : ContractId TradeInstruction
        with
          tradeInstructionCid : ContractId TradeInstruction
        do
          exercise tradeInstructionCid Sign with ctrl = customer

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    controller customer can
      nonconsuming RequestCreateOrder : (ContractId Order, ContractId CreateOrderRequest, ContractId AssetDeposit)
        with
          orderDetails : OrderDetails
          depositCid : ContractId AssetDeposit
        do
          -- TODO: Check that price and quantity conform to the precision requirements of the Listing
          -- TODO: Check order valid for exberry with the market/limit and timeInForce combos (also, if GTD if expiry date is less than one year)
          let
            status = New
            providerOrderId = None
            executionFills = []
            remainingQuantity = orderDetails.asset.quantity

          depositCid <- exerciseByKey @AssetSettlementRule tradingAccount.id AssetSettlement_Transfer with receiverAccountId = allocationAccount.id; ..
          createOrderRequestCid <- create CreateOrderRequest with ..
          orderCid <- create Order with ..

          return (orderCid, createOrderRequestCid, depositCid)

      nonconsuming RequestCancelOrder : (ContractId Order, ContractId CancelOrderRequest)
        with
          orderCid : ContractId Order
        do
          order@Order{..} <- fetch orderCid
          archive orderCid

          orderCid <- create order with status = PendingCancellation
          cancelOrderRequestCid <- create CancelOrderRequest with ..

          return (orderCid, cancelOrderRequestCid)

    controller provider can
      nonconsuming AcknowledgeOrderRequest : ContractId Order
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          providerOrderId : Text
        do
          CreateOrderRequest{..} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          (orderCid, order) <- fetchByKey (provider, orderDetails.id.label)

          case order.status of
            New -> do
              archive orderCid
              create order with status = PendingExecution; providerOrderId = Some providerOrderId
            _ -> return orderCid

      nonconsuming RejectOrder : (ContractId Order, ContractId AssetDeposit)
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          CreateOrderRequest{..} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          (orderCid, order) <- fetchByKey (provider, orderDetails.id.label)
          archive orderCid

          orderCid <- create order with status = Rejected with ..
          depositCid <- exerciseByKey @AssetSettlementRule allocationAccount.id AssetSettlement_Transfer with receiverAccountId = tradingAccount.id, ..

          return (orderCid, depositCid)

      nonconsuming CancelOrder : (ContractId Order, ContractId AssetDeposit)
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
        do
          CancelOrderRequest{..} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          (orderCid, order@Order{..}) <- fetchByKey (provider, orderDetails.id.label)
          archive orderCid

          orderCid <- create order with status = Cancelled
          depositCid <- exerciseByKey @AssetSettlementRule allocationAccount.id AssetSettlement_Transfer with receiverAccountId = tradingAccount.id; ..

          return (orderCid, depositCid)

      nonconsuming RejectCancellation : (ContractId Order)
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          CancelOrderRequest{..} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          (orderCid, order) <- fetchByKey (provider, orderDetails.id.label)
          archive orderCid

          create order with status = CancellationRejected with ..

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        with
          tradingAccount : Account
          allocationAccount : Account
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the provider and provider is nominee on allocationAccount
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    customer : Party
    provider : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory operator, customer

    controller provider can
      Approve : ContractId Service
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the provider and provider is nominee on allocationAccount
          create Service with ..

      Reject : ()
        do
          return ()

template CreateOrderRequest
  with
    provider : Party
    customer : Party
    operator : Party
    orderDetails : OrderDetails
    depositCid : ContractId AssetDeposit
  where
    signatory provider, customer

    key (provider, orderDetails.id.label) : (Party, Text)
    maintainer key._1

    let serviceKey = (operator, provider, customer)

    controller provider can
      nonconsuming AcknowledgeRequest : ContractId Order
        with
          providerOrderId : Text
        do
          exerciseByKey @Service serviceKey AcknowledgeOrderRequest with createOrderRequestCid = self, ..

      nonconsuming RejectRequest : (ContractId Order, ContractId AssetDeposit)
        with
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service serviceKey RejectOrder with createOrderRequestCid = self, ..

template CancelOrderRequest
  with
    provider : Party
    customer : Party
    operator : Party
    orderDetails : OrderDetails
  where
    signatory provider, customer

    key (provider, orderDetails.id.label) : (Party, Text)
    maintainer key._1

    let serviceKey = (operator, provider, customer)

    controller provider can
      nonconsuming AcknowledgeCancel : (ContractId Order, ContractId AssetDeposit)
        do
          exerciseByKey @Service serviceKey CancelOrder with cancelOrderRequestCid = self

      nonconsuming FailureCancel : ContractId Order
        with
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service serviceKey RejectCancellation with cancelOrderRequestCid = self, ..

template TradeInstruction
  with
    operator : Party
    provider : Party
    buyer : Party
    seller : Party
    signed : Set Party
  where
    signatory signed

    key (provider, buyer, seller) : (Party, Party, Party)
    maintainer key._1

    choice Sign : ContractId TradeInstruction
      with
        ctrl : Party
      controller ctrl
      do
        assert (ctrl == buyer || ctrl == seller)
        create this with signed = insert ctrl signed

    controller provider can
      Process : ContractId Trade
        with
          fill : ExecutionFill
          buy : Order
          sell : Order
        do
          -- TODO: Check that price matches limit order price, quantity is less than order qty
          [buyTradingService, sellTradingService] <- forA [buy, sell] \order -> snd <$> fetchByKey @Service (operator, provider, order.customer)
          paymentCurrencyId <- (.quotedAssetId) . snd <$> fetchByKey @Listing (operator, provider, buy.orderDetails.symbol)

          let
            filledQuantity = fill.executedQuantity
            filledPrice = fill.executedPrice
            matchId = fill.matchId
            delivery = buy.orderDetails.asset with quantity = filledQuantity
            payment = Asset with id = paymentCurrencyId, quantity = filledPrice * filledQuantity
            tradeId = Id with signatories = fromList [ provider, buy.customer, sell.customer ]; label = matchId; version = 0
            masterAgreement = MasterAgreement with party1 = buy.customer, party2 = sell.customer; id = tradeId
            status = SettlementStatus_Instructed
            settlementDate = None
            deliveries = [ delivery ]
            payments = [ payment ]
            observers = empty
            deliveryAsset = buy.orderDetails.asset with quantity = filledQuantity
            paymentAsset = payment

          [buyDepositCid, sellDepositCid] <- forA [buy, sell] (\order -> do
            let
              isPartialFill = filledQuantity < buy.remainingQuantity
              status = if isPartialFill then PartiallyExecuted else FullyExecuted
              executionFills = fill :: order.executionFills
              remainingQuantity = order.remainingQuantity - filledQuantity
              quantities = [case order.orderDetails.side of
                    Buy  -> filledQuantity * filledPrice
                    Sell -> filledQuantity]

            create order with status, executionFills, remainingQuantity
            if isPartialFill then
              head <$> exercise order.depositCid AssetDeposit_Split with ..
            else
              pure order.depositCid
            )

          let
            deliverySteps = [ SettlementDetails with senderAccount = sellTradingService.allocationAccount; receiverAccount = buyTradingService.tradingAccount; depositCid = Some sellDepositCid ]
            paymentSteps = [ SettlementDetails with senderAccount = buyTradingService.allocationAccount; receiverAccount = sellTradingService.tradingAccount; depositCid = Some buyDepositCid ]

          dvpCid <- create Dvp with ..
          deliveryInstructionCid <- create SettlementInstruction with steps = deliverySteps; asset = deliveryAsset; ..
          paymentInstructionCid <- create SettlementInstruction with steps = paymentSteps; asset = paymentAsset; ..
          create Trade with deliveryInstructionCids = [deliveryInstructionCid]; paymentInstructionCids = [paymentInstructionCid]; ..

template Trade
  with
    operator : Party
    provider : Party
    buyer : Party
    seller : Party
    dvpCid : ContractId Dvp
    deliveryInstructionCids : [ContractId SettlementInstruction]
    paymentInstructionCids : [ContractId SettlementInstruction]
  where
    signatory operator, provider, buyer, seller

    controller operator, provider can
      Settle : (ContractId Dvp, [[ContractId AssetDeposit]], [[ContractId AssetDeposit]])
        do
          dvp <- fetchAndArchive dvpCid
          dvp.status === SettlementStatus_Instructed
          whenSome dvp.settlementDate (assertOnOrAfterDateMsg "expects settlementDate <= now")

          let seller = if dvp.buyer == dvp.masterAgreement.party1 then dvp.masterAgreement.party2 else dvp.masterAgreement.party1

          let work sender receiver (asset, instructionCid) = do
                instruction <- fetch instructionCid
                instruction.masterAgreement === dvp.masterAgreement
                instruction.tradeId === dvp.tradeId
                instruction.asset === asset
                (head instruction.steps).senderAccount.owner === sender
                (last instruction.steps).receiverAccount.owner === receiver
                exercise instructionCid SettlementInstruction_Process

          dvpNewCid <- create dvp with status = SettlementStatus_Settled
          paymentDepositCids <- mapA (work dvp.buyer seller) $ zipChecked dvp.payments paymentInstructionCids
          deliveryDepositCids <- mapA (work seller dvp.buyer) $ zipChecked dvp.deliveries deliveryInstructionCids
          pure (dvpNewCid, paymentDepositCids, deliveryDepositCids)


-- TODO: Revisit/reimplement


-- template TradeSide
--   with
--     exchParticipant : Party
--     provider : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--     optAsset : Optional Asset
--     receiverAccountId : Id
--     isBinaryOption : Bool
--   where
--     signatory provider, exchParticipant

    -- controller provider can
    --   TradeSide_Settle : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     do
    --       assert $ not isBinaryOption
    --       optDepositTxReqCid <- case optAsset of
    --         Some asset -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = provider
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         None -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optDepositTxReqCid)

    --   TradeSide_SettleBinaryOption : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     with
    --       settledBinOptionCid : ContractId SettledBinaryOption
    --     do
    --       assert isBinaryOption
    --       settledBinOption <- fetch settledBinOptionCid
    --       let needsTransfer = settledBinOption.outcome /= isBuy
    --       optCreditRequestCid <- case (optAsset, needsTransfer) of
    --         (Some asset, True) -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = provider
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         _ -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optCreditRequestCid)


-- template SettledTradeSide
--   with
--     exchParticipant : Party
--     provider : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--   where
--     signatory provider, exchParticipant


-- template BrokerTrade
--   with
--     brokerCustomer : Party
--     broker : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     brokerOrderId : Int
--   where
--     signatory broker, brokerCustomer
