daml 1.2
module Marketplace.Trading where

import Marketplace.Token
import Marketplace.Utils

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types

import DA.Math


type TokenPair = (Id, Id)


template OrderRequest
  with
    order : Order
  where
    signatory order.operator, order.exchange, order.exchParticipant
    ensure order.qty > 0.0

    controller order.exchange can
      OrderRequestAck : ContractId Order
        with
          orderId : Int
        do create order with orderId = orderId

      OrderRequestReject : ()
        do return ()


template OrderCancelRequest
  with
    order : Order
  where
    signatory order.operator, order.exchange, order.exchParticipant

    key (order.exchange, order.orderId) : (Party, Int)
    maintainer key._1

    controller order.exchange can
      OrderCancelAck : ()
        do exerciseByKey @Order (order.exchange, order.orderId) OrderCancel

      OrderCancelReject : ()
        do return ()


template Order
  with
    operator : Party
    exchange : Party
    exchParticipant : Party
    pair : TokenPair
    isBid : Bool
    price : Decimal
    qty : Decimal
    depositCid : ContractId AssetDeposit
    status : Text
    orderId : Int
  where
    signatory operator, exchange, exchParticipant
    ensure qty > 0.0

    key (exchange, orderId) : (Party, Int)
    maintainer key._1

    controller exchange can
      OrderFill : Optional (ContractId Order)
        with
          fillQty : Decimal
          fillPrice : Decimal
          counterParty : Party
        do
          assert $ fillQty > 0.0
          assert $ fillQty <= qty
          assert $ if isBid then fillPrice <= price
                            else fillPrice >= price
          deposit <- fetch depositCid
          let receiverAccountId = getAccountId counterParty exchange [deposit.account.provider]
          (senderRuleCid, _) <- fetchByKey @AssetSettlementRule deposit.account.id
          (_, baseToken) <- fetchByKey @Token pair._1
          (_, quoteToken) <- fetchByKey @Token pair._2
          if fillQty < qty then do
            let minFillQty = 10.0 ** (- intToDecimal if isBid then quoteToken.quantityPrecision else baseToken.quantityPrecision)
            let depositFillQty = min (if isBid
                                      then roundBankers quoteToken.quantityPrecision $ fillQty * fillPrice
                                      else fillQty)
                                     (deposit.asset.quantity - minFillQty)
            if (depositFillQty > 0.0 && depositFillQty < deposit.asset.quantity)
            then do
              [filledCid, restCid] <- exercise depositCid AssetDeposit_Split with quantities = [depositFillQty]
              exercise senderRuleCid AssetSettlement_Transfer with depositCid = filledCid, ..
              remainingCid <- create this with depositCid = restCid, qty = qty - fillQty, status = "PartiallyFilled"
              return $ Some remainingCid
            else do
              -- the fillQty is not enough to warrant a deposit transfer
              remainingCid <- create this with qty = qty - fillQty, status = "PartiallyFilled"
              return $ Some remainingCid
          else do
            exercise senderRuleCid AssetSettlement_Transfer with ..
            return None

      OrderCancel : ()
        do return ()

    controller exchParticipant can
      nonconsuming OrderRequestCancel : ContractId OrderCancelRequest
        do create OrderCancelRequest with order = this
