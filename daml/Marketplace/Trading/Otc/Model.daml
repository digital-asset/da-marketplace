module Marketplace.Trading.Otc.Model where

import DA.Finance.Types (Asset, Account)
import DA.Optional (fromSomeNote)
import DA.Action (when)
import DA.Set (empty)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Issuance.Instrument.Model(Bond(..))
import Marketplace.Settlement.Hierarchical.Util (createInstructions, getAccount, Status(..), SettlementMode(..))
import Marketplace.Settlement.Htlc.Util (createInstructionsHtlc, HtlcState(..))
import Marketplace.Settlement.Htlc.Dvp qualified as Htlc
import Marketplace.Settlement.Hierarchical.Dvp qualified as Hierarchical
import Marketplace.Trading.Model (Side(..))
import SwiftMessage.Util
import SwiftMessage.Message(SwiftOutboundMessage(..), SwiftMessageType(..), SwiftMessage(..))
import SwiftMessage.Model.MT548

template Order
  with
    operator : Party
    provider : Party
    customer : Party
    counterparty : Party
    deliveryRegistrar : Party
    paymentRegistrar : Party
    id : Text
    delivery : Asset
    payment : Asset
    side : Side
    settlementMode : SettlementMode
    hashlockOpt : Optional Text
  where
    signatory operator, provider, customer
    observer counterparty

    choice Accept : ContractId Match
      controller counterparty
      do
        create Match with order = this; status = Match_Created

    choice Reject : ()
      controller counterparty
      do
        pure ()

    choice Cancel : ()
      controller customer
      do
        pure ()

-- helper data record for Instruct choices in Match
data SettlementResult = SettlementResult with
  settlementId : Text

  deliverer : Party
  payer : Party
  delivererSecAccount : Account
  delivererCashAccount : Account
  payerSecAccount : Account
  payerCashAccount : Account

createSettlementId : Order -> Text 
createSettlementId order = 
  order.id <> "-" <> partyToText order.customer <> "-" <> partyToText order.counterparty

data MatchStatus = Match_Created | Match_Instructed deriving (Eq, Show)

template Match
  with
    order : Order
    status : MatchStatus
  where
    signatory signatory order, order.counterparty

    let
      createSettlementResult : Order -> Update SettlementResult
      createSettlementResult Order{..} = do
        let
          settlementId = createSettlementId order
          payer = if side == Buy then customer else counterparty
          deliverer = if side == Buy then counterparty else customer
        (_, payerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, payer)
        (_, delivererSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, deliverer)
        let
          payerSecAccount = getAccount False payerSettlementInfo payer
          payerCashAccount = getAccount True payerSettlementInfo payer
          delivererSecAccount = getAccount False delivererSettlementInfo deliverer
          delivererCashAccount = getAccount True delivererSettlementInfo deliverer
        pure $ SettlementResult with ..
      
      createSettlementAdvice : Order -> SettlementResult -> Date -> Update SettlementAdvice
      createSettlementAdvice Order{..} SettlementResult{..} dateOfSettlement = do
        (_, bond) <- fetchByKey @Bond (delivery.id.signatories, delivery.id.label)
        let 
          instrumentId = bond.isin <> "-" <> delivery.id.label
          settledAmount = payment.quantity
          settledQty = delivery.quantity
          buyer = payer
          buyerSafekeepingAcc = payerSecAccount
          receivingAgent = payerSecAccount.provider
          seller = deliverer
          sellerSafekeepingAcc = delivererSecAccount
          deliveringAgent = delivererSecAccount.provider
          dateOfTrade = dateOfSettlement
        pure $ SettlementAdvice with ..

      sendSwiftMessage : Text -> SettlementAdvice -> SettlementMode -> Party -> Update ()
      sendSwiftMessage settlementId settlementAdvice@SettlementAdvice{..} settlementMode operator = do
        let
          paymentMode = if settlementMode == Fop then FREE else APMT
          mt548_buy = createMT548Details settlementAdvice RECE paymentMode  
          mt548_sell = createMT548Details settlementAdvice DELI paymentMode
        create SwiftOutboundMessage with referenceId = settlementId; provider = operator; consumer = operator; status = Finalized; observers = empty; swiftMessage = MT548 (mt548_buy); swiftMessageType = MT548_buy_t
        create SwiftOutboundMessage with referenceId = settlementId; provider = operator; consumer = operator; status = Finalized; observers = empty; swiftMessage = MT548 (mt548_sell); swiftMessageType = MT548_sell_t
        pure ()

    choice Instruct : (ContractId Match, ContractId Hierarchical.Dvp)
      with dateOfSettlement : Date
      controller order.operator
      do
        settlementResult@SettlementResult {..} <- createSettlementResult order
        let Order{..} = order
        deliverySis <- createInstructions False operator operator deliveryRegistrar delivererSecAccount payerSecAccount settlementId 0 delivery
        instructionIds <-
            if settlementMode == Dvp
            then do
              paymentSis <- createInstructions True operator operator paymentRegistrar payerCashAccount delivererCashAccount settlementId (length deliverySis) payment
              map (.instructionId) <$> mapA fetch (deliverySis <> paymentSis)
            else do
              map (.instructionId) <$> mapA fetch deliverySis

        settlementAdvice <- createSettlementAdvice order settlementResult dateOfSettlement
        sendSwiftMessage settlementId settlementAdvice settlementMode operator
        matchCid <- create this with status = Match_Instructed 
        dvpCid <- create Hierarchical.Dvp with operator; agent = operator; deliverer; payer; settlementId; instructionIds; delivery; payment; status = Instructed; settlementMode
        pure (matchCid, dvpCid)
      
    choice InstructHtlc : (ContractId Match, ContractId Htlc.Dvp)
      with 
        expiry : Time
        dateOfSettlement : Date
      controller order.operator
      do 
        settlementResult@SettlementResult {..} <- createSettlementResult order
        let Order{..} = order
            hashlock = fromSomeNote "No hashlock specified for HTLC" hashlockOpt
        deliverySis <- createInstructionsHtlc False operator deliveryRegistrar deliverer delivererSecAccount payer payerSecAccount settlementId 0 delivery hashlock expiry
        instructionIds <- map (.instructionId) <$> mapA fetch deliverySis
        settlementAdvice <- createSettlementAdvice order settlementResult dateOfSettlement
        sendSwiftMessage settlementId settlementAdvice settlementMode operator
        matchCid <- create this with status = Match_Instructed
        dvpCid <- create Htlc.Dvp with delivererAgent = deliverer; payerAgent = payer; status = Locked; ..
        pure (matchCid, dvpCid)

    choice ProposeCancel: ContractId MatchCancelProposal
      with ctrl : Party
      controller ctrl
      do 
        assertMsg "only buyer and seller can cancel match" (ctrl `elem` [order.customer, order.counterparty])
        create MatchCancelProposal with cancelProposer = ctrl; match = this

template MatchCancelProposal 
  with
    match : Match
    cancelProposer : Party
  where 
    signatory match.order.operator, match.order.provider, cancelProposer
    observer cancelCounterParty
    ensure cancelProposer `elem` [cancelProposer, cancelCounterParty]

    let
      findCounterParty: Order -> Party 
      findCounterParty Order{..} = if cancelProposer == counterparty then customer else counterparty
      cancelCounterParty = findCounterParty match.order

    choice AcceptCancellation : ContractId MatchCancel
      controller cancelCounterParty
      do 
        create MatchCancel with ..
    
    choice RejectCancellation : ContractId Match
      controller cancelCounterParty
      do 
        create match


template MatchCancel 
  with
    match : Match
  where 
    signatory signatory match

    let 
      cancelDvp : (Party, Text) -> Update (Either (ContractId Hierarchical.Dvp) (ContractId Htlc.Dvp))
      cancelDvp dvpKey = do
        if match.order.settlementMode == Htlc then
          Right <$> exerciseByKey @Htlc.Dvp dvpKey Htlc.CancelDvp
        else 
          Left <$> exerciseByKey @Hierarchical.Dvp dvpKey Hierarchical.CancelDvp

      sendCancelSwiftMessage : (ContractId SwiftOutboundMessage, SwiftOutboundMessage) -> Update ()
      sendCancelSwiftMessage (cid, swiftOutboundMsg@SwiftOutboundMessage{swiftMessage = MT548 details}) = do
          archive cid
          create swiftOutboundMsg with swiftMessage = (MT548 (details with status = CAND))
          pure ()
      sendCancelSwiftMessage other =
        pure ()

    choice CancelMatch : ()
      controller match.order.operator 
      do 
        -- archive or update status of dvp
        let
          order = match.order 
          settlementId = createSettlementId order
        when (match.status == Match_Instructed) do cancelDvp (order.operator, settlementId); pure ()        
        -- fetch and send cancelled MT548
        mt548_buy <- fetchByKey @SwiftOutboundMessage (order.operator, settlementId, MT548_buy_t)
        mt548_sell <- fetchByKey @SwiftOutboundMessage (order.operator, settlementId, MT548_sell_t)
        sendCancelSwiftMessage mt548_buy
        sendCancelSwiftMessage mt548_sell
  