module Marketplace.Trading.Otc.Model where

import DA.Finance.Types (Asset, Account)
import DA.Optional (fromSomeNote)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Settlement.Hierarchical.Util (createInstructions, getAccount, Status(..), SettlementMode(..))
import Marketplace.Settlement.Htlc.Util (createInstructionsHtlc, HtlcState(..))
import Marketplace.Settlement.Htlc.Dvp qualified as Htlc
import Marketplace.Settlement.Hierarchical.Dvp qualified as Hierarchical
import Marketplace.Trading.Model (Side(..))

template Order
  with
    operator : Party
    provider : Party
    customer : Party
    counterparty : Party
    deliveryRegistrar : Party
    paymentRegistrar : Party
    id : Text
    delivery : Asset
    payment : Asset
    side : Side
    settlementMode : SettlementMode
    hashlockOpt : Optional Text
  where
    signatory operator, provider, customer
    observer counterparty

    choice Accept : ContractId Match
      controller counterparty
      do
        create Match with order = this

    choice Reject : ()
      controller counterparty
      do
        pure ()

    choice Cancel : ()
      controller customer
      do
        pure ()

-- helper data record for Instruct choices in Match
data SettlementResult = SettlementResult with
  settlementId : Text

  deliverer : Party
  payer : Party
  delivererSecAccount : Account
  delivererCashAccount : Account
  payerSecAccount : Account
  payerCashAccount : Account

template Match
  with
    order : Order
  where
    signatory signatory order, order.counterparty

    let
      createSettlementResult : Order -> Update SettlementResult
      createSettlementResult Order{..} = do
        let
          settlementId = id <> "-" <> partyToText customer <> "-" <> partyToText counterparty
          payer = if side == Buy then customer else counterparty
          deliverer = if side == Buy then counterparty else customer
        (_, payerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, payer)
        (_, delivererSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, deliverer)
        let
          payerSecAccount = getAccount False payerSettlementInfo payer
          payerCashAccount = getAccount True payerSettlementInfo payer
          delivererSecAccount = getAccount False delivererSettlementInfo deliverer
          delivererCashAccount = getAccount True delivererSettlementInfo deliverer
        pure $ SettlementResult with ..

    nonconsuming choice Instruct : ContractId Hierarchical.Dvp
      controller order.operator
      do
        SettlementResult {..} <- createSettlementResult order
        let Order{..} = order
        deliverySis <- createInstructions False operator operator deliveryRegistrar delivererSecAccount payerSecAccount settlementId 0 delivery
        instructionIds <-
            if settlementMode == Dvp
            then do
              paymentSis <- createInstructions True operator operator paymentRegistrar payerCashAccount delivererCashAccount settlementId (length deliverySis) payment
              map (.instructionId) <$> mapA fetch (deliverySis <> paymentSis)
            else do
              map (.instructionId) <$> mapA fetch deliverySis
        create Hierarchical.Dvp with operator; agent = operator; deliverer; payer; settlementId; instructionIds; delivery; payment; status = Instructed; settlementMode
      
    nonconsuming choice InstructHtlc : ContractId Htlc.Dvp
      with 
        expiry : Time
      controller order.operator
      do 
        SettlementResult {..} <- createSettlementResult order
        let Order{..} = order
            hashlock = fromSomeNote "No hashlock specified for HTLC" hashlockOpt
        deliverySis <- createInstructionsHtlc False operator deliveryRegistrar deliverer delivererSecAccount payer payerSecAccount settlementId 0 delivery hashlock expiry
        instructionIds <- map (.instructionId) <$> mapA fetch deliverySis
        create Htlc.Dvp with delivererAgent = deliverer; payerAgent = payer; status = Locked; ..