module Marketplace.Trading.Otc.Model where

import DA.Finance.Types (Asset, Account)
import DA.Optional (fromSomeNote)
import DA.Set (singleton)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Issuance.Instrument.Model(Bond(..))
import Marketplace.Settlement.Hierarchical.Util (createInstructions, getAccount, Status(..), SettlementMode(..))
import Marketplace.Settlement.Htlc.Util (createInstructionsHtlc, HtlcState(..))
import Marketplace.Settlement.Htlc.Dvp qualified as Htlc
import Marketplace.Settlement.Hierarchical.Dvp qualified as Hierarchical
import Marketplace.Trading.Model (Side(..))
import SwiftMessage.Util
import SwiftMessage.Message(SwiftOutboundMessage(..), SwiftMessageType(..), SwiftMessage(..))
import SwiftMessage.Model.MT548

template Order
  with
    operator : Party
    provider : Party
    customer : Party
    counterparty : Party
    deliveryRegistrar : Party
    paymentRegistrar : Party
    id : Text
    delivery : Asset
    payment : Asset
    side : Side
    settlementMode : SettlementMode
    hashlockOpt : Optional Text
  where
    signatory operator, provider, customer
    observer counterparty

    choice Accept : ContractId Match
      controller counterparty
      do
        create Match with order = this

    choice Reject : ()
      controller counterparty
      do
        pure ()

    choice Cancel : ()
      controller customer
      do
        pure ()

-- helper data record for Instruct choices in Match
data SettlementResult = SettlementResult with
  settlementId : Text

  deliverer : Party
  payer : Party
  delivererSecAccount : Account
  delivererCashAccount : Account
  payerSecAccount : Account
  payerCashAccount : Account

template Match
  with
    order : Order
  where
    signatory signatory order, order.counterparty

    let
      createSettlementResult : Order -> Update SettlementResult
      createSettlementResult Order{..} = do
        let
          settlementId = id <> "-" <> partyToText customer <> "-" <> partyToText counterparty
          payer = if side == Buy then customer else counterparty
          deliverer = if side == Buy then counterparty else customer
        (_, payerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, payer)
        (_, delivererSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, deliverer)
        let
          payerSecAccount = getAccount False payerSettlementInfo payer
          payerCashAccount = getAccount True payerSettlementInfo payer
          delivererSecAccount = getAccount False delivererSettlementInfo deliverer
          delivererCashAccount = getAccount True delivererSettlementInfo deliverer
        pure $ SettlementResult with ..
      
      createSettlementStatusAndProcessingAdvice : Order -> SettlementResult -> Date -> Update SettlementStatusAndProcessingAdvice
      createSettlementStatusAndProcessingAdvice Order{..} SettlementResult{..} dateOfSettlement = do
        (_, bond) <- fetchByKey @Bond (delivery.id.signatories, delivery.id.label)
        let 
          instrumentId = bond.isin <> "-" <> delivery.id.label
          settledAmount = payment.quantity
          settledQty = delivery.quantity
          buyer = payer
          buyerSafekeepingAcc = payerSecAccount
          receivingAgent = payerSecAccount.provider
          seller = deliverer
          sellerSafekeepingAcc = delivererSecAccount
          deliveringAgent = delivererSecAccount.provider
          dateOfTrade = dateOfSettlement
        pure $ SettlementStatusAndProcessingAdvice with ..

      sendSwiftMessage : Text -> SettlementStatusAndProcessingAdvice -> SettlementMode -> Party -> Party -> Update ()
      sendSwiftMessage settlementId settlementStatusAndProcessingAdvice settlementMode operator agent = do
        let
          paymentMode = if settlementMode == Fop then FREE else APMT
          mt548_buy = createMT548Details settlementStatusAndProcessingAdvice RECE paymentMode  
          mt548_sell = createMT548Details settlementStatusAndProcessingAdvice DELI paymentMode
        create SwiftOutboundMessage with referenceId = settlementId; provider = operator; consumer = operator; status = Finalized; observers = singleton agent; swiftMessage = MT548 (mt548_buy); swiftMessageType = MT548_buy_t
        create SwiftOutboundMessage with referenceId = settlementId; provider = operator; consumer = operator; status = Finalized; observers = singleton agent; swiftMessage = MT548 (mt548_sell); swiftMessageType = MT548_sell_t
        pure ()

    nonconsuming choice Instruct : ContractId Hierarchical.Dvp
      with dateOfSettlement : Date
      controller order.operator
      do
        settlementResult@SettlementResult {..} <- createSettlementResult order
        let Order{..} = order
        deliverySis <- createInstructions False operator operator deliveryRegistrar delivererSecAccount payerSecAccount settlementId 0 delivery
        instructionIds <-
            if settlementMode == Dvp
            then do
              paymentSis <- createInstructions True operator operator paymentRegistrar payerCashAccount delivererCashAccount settlementId (length deliverySis) payment
              map (.instructionId) <$> mapA fetch (deliverySis <> paymentSis)
            else do
              map (.instructionId) <$> mapA fetch deliverySis

        settlementStatusAndProcessingAdvice <- createSettlementStatusAndProcessingAdvice order settlementResult dateOfSettlement
        sendSwiftMessage settlementId settlementStatusAndProcessingAdvice settlementMode operator operator 
        create Hierarchical.Dvp with operator; agent = operator; deliverer; payer; settlementId; instructionIds; delivery; payment; status = Instructed; settlementMode
      
    nonconsuming choice InstructHtlc : ContractId Htlc.Dvp
      with 
        expiry : Time
        dateOfSettlement : Date
      controller order.operator
      do 
        settlementResult@SettlementResult {..} <- createSettlementResult order
        let Order{..} = order
            hashlock = fromSomeNote "No hashlock specified for HTLC" hashlockOpt
        deliverySis <- createInstructionsHtlc False operator deliveryRegistrar deliverer delivererSecAccount payer payerSecAccount settlementId 0 delivery hashlock expiry
        instructionIds <- map (.instructionId) <$> mapA fetch deliverySis
        settlementStatusAndProcessingAdvice <- createSettlementStatusAndProcessingAdvice order settlementResult dateOfSettlement
        sendSwiftMessage settlementId settlementStatusAndProcessingAdvice settlementMode operator payer
        create Htlc.Dvp with delivererAgent = deliverer; payerAgent = payer; status = Locked; ..