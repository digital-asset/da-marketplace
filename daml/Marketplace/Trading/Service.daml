
module Marketplace.Trading.Service where

import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Types (Account)
import Marketplace.Trading.Model qualified as Order
import Marketplace.Trading.Error (Error (..))
import Marketplace.Utils

type T = Service

whenCollateral : Order.TradeCollateral -> (ContractId AssetDeposit -> Update (ContractId AssetDeposit)) -> Update Order.TradeCollateral
whenCollateral (Order.Cleared x) _ = return $ Order.Cleared x
whenCollateral (Order.Collateral depositCid) fn = Order.Collateral <$> fn depositCid

-- | Represents a Master Service Agreement between two parties for the provision of order execution
-- An execution service is separate from the clearing & settlement of trades. i.e. we support
-- so-called 'give-up' trading.
template Service
  with
    operator : Party
    provider : Party -- counterparty
    customer : Party -- order originator
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    controller customer can
      nonconsuming RequestCreateOrder : ContractId CreateOrderRequest
        with
          order : Order.T
        do
          create CreateOrderRequest with order, ..

    controller customer, provider can
      -- | This choice can be called to create a public order (i.e. self-approval)
      nonconsuming CreateOrder : (ContractId Order.T, ContractId Order.State)
        with order : Order.T
         do 
          request <- exercise self RequestCreateOrder with order
          exercise request AcknowledgeRequest
          
                        
    choice Terminate : ()
      with
        ctrl : Party
      controller ctrl
      do pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        do
          createOrLookup Service with ..

      Decline : ()
        do
          return ()

    controller provider can
      Withdraw : ()
        do pure ()

template Request
  with
    customer : Party
    provider : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory customer

    controller customer can
      Cancel : ()
        do pure ()

    controller provider can
      Reject : ()
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
  --       assertAccounts provider tradingAccount allocationAccount
        createOrLookup Service with ..

template CreateOrderRequest
  with
    provider : Party -- counterparty
    customer : Party -- originator
    operator : Party
    order : Order.T
    -- collateral : Order.TradeCollateral
  where
    signatory provider, customer

    key (provider, order.id) : (Party, Order.OrderId)
    maintainer key._1

    let serviceKey = (operator, provider, customer)

    controller provider can
      AcknowledgeRequest : (ContractId Order.T, ContractId Order.State)
        do
          o <- create order 
          s <- create (Order.newState order) with status = Order.PendingExecution
          pure (o, s)

      AcknowledgeAndFill : (ContractId Order.Execution, ContractId Order.T, ContractId Order.State, ContractId Order.State ) 
        with contraCid : ContractId Order.T
        do
          o <- create order
          s <- create (Order.newState order)
          (e, s, s') <- exercise o Order.Cross with contraCid
          pure (e, o, s, s')

      RejectRequest : (ContractId Order.T, ContractId Order.State)
        with
          errorCode : Int
          errorMessage : Text
        do
          o <- create order
          s <- create (Order.newState order) with status = Order.Rejected $ Error (show errorCode) errorMessage
          pure (o, s)

{-
template CancelOrderRequest
  with
    provider : Party
    customer : Party
    operator : Party
    details : Order.Details
  where
    signatory provider, customer

    key (provider, details.id) : (Party, Text)
    maintainer key._1

    let serviceKey = (operator, provider, customer)

    controller provider can
      nonconsuming AcknowledgeCancel : (ContractId Order.T, Order.TradeCollateral)
        do
          exerciseByKey @Service serviceKey CancelOrder with cancelOrderRequestCid = self

      nonconsuming FailureCancel : ContractId Order.T
        with
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service serviceKey RejectCancellation with cancelOrderRequestCid = self, ..
-}
