module Marketplace.Trading.Service where

import DA.Foldable (sequence_)
import DA.Optional (whenSome)
import DA.Set qualified as Set
import DA.Finance.Asset (AssetDeposit, AssetDeposit_Lock(..), AssetDeposit_Unlock(..))
import DA.Finance.Utils (fetchAndArchive)
import Marketplace.Custody.Service qualified as Custody
import Marketplace.Trading.Model qualified as Order
import Marketplace.Clearing.Service qualified as Clearing
import Marketplace.Trading.Confirmation.Model qualified as Confirmation
import Marketplace.Trading.Error (Error (..))
import Marketplace.Utils

type T = Service

whenCollateral : Order.TradeCollateral -> (ContractId AssetDeposit -> Update (ContractId AssetDeposit)) -> Update Order.TradeCollateral
whenCollateral (Order.Cleared x) _ = return $ Order.Cleared x
whenCollateral (Order.Collateral depositCid) fn = Order.Collateral <$> fn depositCid

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    let
      unlockCollateral : Order.TradeCollateral -> Update Order.TradeCollateral
      unlockCollateral = \case
        Order.Cleared party         -> return $ Order.Cleared party
        Order.Collateral depositCid -> Order.Collateral <$> exercise depositCid AssetDeposit_Unlock

    controller customer can
      nonconsuming RequestCreateOrder : Either (ContractId Order.T)
                                               (ContractId Order.T, ContractId CreateOrderRequest, Order.TradeCollateral)
        with
          collateral : Order.TradeCollateral
          details : Order.Details
        do
          createdAt <- getTime

          let
            status = Order.New
            providerOrderId = None
            executions = []
            remainingQuantity = details.asset.quantity
            detailsWithDepositedFees : Update Order.Details
            detailsWithDepositedFees = case details.optExchangeFee of
              Some feeDepositCid -> do
                newDepositCid <- exercise feeDepositCid AssetDeposit_Lock with newLockers = Set.fromList [ provider ]
                return details with optExchangeFee = Some newDepositCid
              None -> return details

          case collateral of
            (Order.Collateral depositCid) -> do
                lookupByKey @Custody.Service (operator, details.receivableAccount.provider, customer) >>= \case
                  None -> do
                    let reason = Error with code = "3003"; message = "Customer does not have a custodial relationship with the custodian of the quoted asset"
                    Left <$> create Order.Order with status = Order.Rejected{reason}; ..
                  Some _ -> do
                    details <- detailsWithDepositedFees
                    collateral <- Order.Collateral <$> exercise depositCid AssetDeposit_Lock with newLockers = Set.fromList [ provider ]
                    createOrderRequestCid <- create CreateOrderRequest with ..
                    orderCid <- create Order.Order with ..

                    return $ Right (orderCid, createOrderRequestCid, collateral)

            (Order.Cleared clearinghouse) -> do
              optClearingService <- lookupByKey @Clearing.Service (operator,clearinghouse,customer)
              case optClearingService of
                None -> do
                  let reason = Error with code = "3001"; message = "Customer is not a member of clearinghouse"
                  Left <$> create Order.Order with status = Order.Rejected{reason}; ..

                (Some serviceCid) -> exercise serviceCid Clearing.ApproveTrade >>= \case
                    True -> do
                        details <- detailsWithDepositedFees
                        createOrderRequestCid <- create CreateOrderRequest with ..
                        orderCid <- create Order.Order with ..
                        return $ Right (orderCid, createOrderRequestCid, collateral)
                    False -> do
                      let reason = Error with code = "3002"; message = "Rejected by Clearinghouse"
                      Left <$> create Order.Order with status = Order.Rejected{reason}; ..

      nonconsuming RequestCancelOrder : (ContractId Order.T, ContractId CancelOrderRequest)
        with
          orderCid : ContractId Order.T
        do
          order@Order.Order{..} <- fetchAndArchive orderCid

          orderCid <- create order with status = Order.PendingCancellation
          cancelOrderRequestCid <- create CancelOrderRequest with ..

          return (orderCid, cancelOrderRequestCid)

    controller provider can
      nonconsuming AcknowledgeOrderRequest : ContractId Order.T
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          providerOrderId : Text
        do
          CreateOrderRequest{..} <- fetchAndArchive createOrderRequestCid
          (orderCid, order) <- fetchByKey (provider, details.id)

          -- TODO: Confirm what to do with this business ACK when received out of the expected order.
          --  Should we set the providerOrderId but leave the status as is ? Should we check if this value is already set ? What to do if it's already set ? etc.
          case order.status of
            Order.New -> do
              archive orderCid
              create order with status = Order.PendingExecution; providerOrderId = Some providerOrderId
            _ -> return orderCid

      nonconsuming RejectOrderRequest : (ContractId Order.T, Order.TradeCollateral)
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          CreateOrderRequest{details, collateral} <- fetch createOrderRequestCid
          (orderCid, order) <- fetchByKey (provider, details.id)
          archive orderCid

          let reason = Error with code = show errorCode; message = errorMessage
          orderCid <- create order with status = Order.Rejected with reason
          collateral <- unlockCollateral collateral
          whenSome details.optExchangeFee \depositCid -> exercise depositCid AssetDeposit_Unlock >> pure ()

          return (orderCid, collateral)

      nonconsuming MarketOrderCancelRequest : (ContractId Order.T, Order.TradeCollateral)
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          providerOrderId : Text
          cancelledQuantity : Decimal
        do
          CreateOrderRequest{details} <- fetch createOrderRequestCid
          (orderCid, order) <- fetchByKey (provider, details.id)

          let isFullCancellation = cancelledQuantity >= order.details.asset.quantity
              isWaitingExecution = order.status `elem` [Order.New, Order.PendingExecution]
              isMarketOrder = order.details.orderType == Order.Market

          if isMarketOrder && isFullCancellation && isWaitingExecution
            then do
              sequence_ [archive orderCid, archive createOrderRequestCid]
              orderCid <- create order with status = Order.Cancelled, providerOrderId = Some providerOrderId
              collateral <- unlockCollateral order.collateral

              return (orderCid, collateral)
            else return (orderCid, order.collateral)

      nonconsuming CancelOrder : (ContractId Order.T, Order.TradeCollateral)
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
        do
          CancelOrderRequest{..} <- fetchAndArchive cancelOrderRequestCid
          (orderCid, order@Order.Order{..}) <- fetchByKey (provider, details.id)
          archive orderCid

          orderCid <- create order with status = Order.Cancelled
          collateral <- unlockCollateral order.collateral
          whenSome details.optExchangeFee \depositCid -> exercise depositCid AssetDeposit_Unlock >> pure ()

          return (orderCid, collateral)

      nonconsuming RejectCancellation : ContractId Order.T
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          CancelOrderRequest{..} <- fetchAndArchive cancelOrderRequestCid
          (orderCid, order) <- fetchByKey (provider, details.id)
          archive orderCid

          let reason = Error with code = show errorCode; message = errorMessage
          create order with status = Order.CancellationRejected with reason

    controller operator, provider can
      nonconsuming SignConfirmation : ContractId Confirmation.T
        with
          confirmationCid : ContractId Confirmation.T
        do
          exercise confirmationCid Confirmation.Sign with ctrl = customer, ..

    choice Terminate : ()
      with
        ctrl : Party
      controller ctrl
      do pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        with
        do
          createOrLookup Service with ..

      Decline : ()
        do
          return ()

    controller provider can
      Withdraw : ()
        do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer

    controller customer can
      Cancel : ()
        do pure ()

    controller provider can
      Reject : ()
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        createOrLookup Service with ..

template CreateOrderRequest
  with
    provider : Party
    customer : Party
    operator : Party
    details : Order.Details
    collateral : Order.TradeCollateral
  where
    signatory provider, customer

    key (provider, details.id) : (Party, Text)
    maintainer key._1

    let serviceKey = (operator, provider, customer)

    controller provider can
      nonconsuming AcknowledgeRequest : ContractId Order.T
        with
          providerOrderId : Text
        do
          exerciseByKey @Service serviceKey AcknowledgeOrderRequest with createOrderRequestCid = self, ..

      nonconsuming RejectRequest : (ContractId Order.T, Order.TradeCollateral)
        with
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service serviceKey RejectOrderRequest with createOrderRequestCid = self, ..

      nonconsuming CancelRequest : (ContractId Order.T, Order.TradeCollateral)
        with
          providerOrderId : Text
          cancelledQuantity : Decimal
        do
          exerciseByKey @Service serviceKey MarketOrderCancelRequest with createOrderRequestCid = self, ..

template CancelOrderRequest
  with
    provider : Party
    customer : Party
    operator : Party
    details : Order.Details
  where
    signatory provider, customer

    key (provider, details.id) : (Party, Text)
    maintainer key._1

    let serviceKey = (operator, provider, customer)

    controller provider can
      nonconsuming AcknowledgeCancel : (ContractId Order.T, Order.TradeCollateral)
        do
          exerciseByKey @Service serviceKey CancelOrder with cancelOrderRequestCid = self

      nonconsuming FailureCancel : ContractId Order.T
        with
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service serviceKey RejectCancellation with cancelOrderRequestCid = self, ..
