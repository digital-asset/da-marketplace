module Marketplace.Trading.TradeInstruction where

import DA.Assert ((===))
import DA.Finance.Asset (AssetDeposit, AssetDeposit_Split(..))
import DA.Finance.Trade.SettlementInstruction (SettlementInstruction(..), SettlementInstruction_Process(..), SettlementDetails(..))
import DA.Finance.Trade.Dvp (Dvp(..), SettlementStatus(..))
import DA.Finance.Types (Id(..), Asset(..), Account(..), MasterAgreement(..))
import DA.Finance.Utils (assertOnOrAfterDateMsg, zipChecked, fetchAndArchive)
import DA.List (head, last)
import DA.Next.Set (Set, empty, insert, fromList)
import DA.Optional (whenSome)
import Marketplace.Listing (Listing)
import Marketplace.Trading.Order qualified as Order

data CustomerAccounts = CustomerAccounts with
    customer : Party
    allocationAccount : Account
    tradingAccount : Account
  deriving (Eq, Show)

type T = TradeInstruction

template TradeInstruction
  with
    operator : Party
    provider : Party
    buyer : Party
    seller : Party
    signed : Set Party
    accounts : [CustomerAccounts]
  where
    signatory signed

    key (provider, buyer, seller) : (Party, Party, Party)
    maintainer key._1

    choice Sign : ContractId TradeInstruction
      with
        ctrl : Party
        allocationAccount : Account
        tradingAccount : Account
      controller ctrl
      do
        assert (ctrl == buyer || ctrl == seller)
        create this with
          signed = insert ctrl signed
          accounts = CustomerAccounts with customer = ctrl; .. :: accounts

    controller provider can
      Process : ContractId Trade
        with
          fill : Order.ExecutionFill
          buyCid : ContractId Order.T
          sellCid : ContractId Order.T
        do
          [buy, sell] <- forA [buyCid, sellCid] fetchAndArchive

          -- TODO: Check that price matches limit order price, quantity is less than order qty
          paymentCurrencyId <- (.quotedAssetId) . snd <$> fetchByKey @Listing (operator, provider, buy.orderDetails.symbol)

          let
            filledQuantity = fill.executedQuantity
            filledPrice = fill.executedPrice
            matchId = fill.matchId
            delivery = buy.orderDetails.asset with quantity = filledQuantity
            payment = Asset with id = paymentCurrencyId, quantity = filledPrice * filledQuantity
            tradeId = Id with signatories = fromList [ provider, buy.customer, sell.customer ]; label = matchId; version = 0
            masterAgreement = MasterAgreement with party1 = buy.customer, party2 = sell.customer; id = tradeId
            status = SettlementStatus_Instructed
            settlementDate = None
            deliveries = [ delivery ]
            payments = [ payment ]
            observers = empty
            deliveryAsset = buy.orderDetails.asset with quantity = filledQuantity
            paymentAsset = payment

          [buyDepositCid, sellDepositCid] <- forA [buy, sell] (\order -> do
            let
              isPartialFill = filledQuantity < buy.remainingQuantity
              status = if isPartialFill then Order.PartiallyExecuted else Order.FullyExecuted
              executionFills = fill :: order.executionFills
              remainingQuantity = order.remainingQuantity - filledQuantity
              quantities = [case order.orderDetails.side of
                    Order.Buy  -> filledQuantity * filledPrice
                    Order.Sell -> filledQuantity]

            create order with status, executionFills, remainingQuantity
            if isPartialFill then
              head <$> exercise order.depositCid AssetDeposit_Split with ..
            else
              pure order.depositCid
            )

          let
            getAccount customer accountType = accountType . head $ filter (\account -> account.customer == customer) accounts
            deliverySteps = [ SettlementDetails with senderAccount = getAccount seller (.allocationAccount); receiverAccount = getAccount buyer  (.tradingAccount); depositCid = Some sellDepositCid ]
            paymentSteps =  [ SettlementDetails with senderAccount = getAccount buyer  (.allocationAccount); receiverAccount = getAccount seller (.tradingAccount); depositCid = Some buyDepositCid  ]

          dvpCid <- create Dvp with ..
          deliveryInstructionCid <- create SettlementInstruction with steps = deliverySteps; asset = deliveryAsset; ..
          paymentInstructionCid <- create SettlementInstruction with steps = paymentSteps; asset = paymentAsset; ..
          create Trade with deliveryInstructionCids = [deliveryInstructionCid]; paymentInstructionCids = [paymentInstructionCid]; ..

template Trade
  with
    operator : Party
    provider : Party
    buyer : Party
    seller : Party
    dvpCid : ContractId Dvp
    deliveryInstructionCids : [ContractId SettlementInstruction]
    paymentInstructionCids : [ContractId SettlementInstruction]
  where
    signatory operator, provider, buyer, seller

    controller operator, provider can
      Settle : (ContractId Dvp, [[ContractId AssetDeposit]], [[ContractId AssetDeposit]])
        do
          dvp <- fetchAndArchive dvpCid
          dvp.status === SettlementStatus_Instructed
          whenSome dvp.settlementDate (assertOnOrAfterDateMsg "expects settlementDate <= now")

          let seller = if dvp.buyer == dvp.masterAgreement.party1 then dvp.masterAgreement.party2 else dvp.masterAgreement.party1

          let work sender receiver (asset, instructionCid) = do
                instruction <- fetch instructionCid
                instruction.masterAgreement === dvp.masterAgreement
                instruction.tradeId === dvp.tradeId
                instruction.asset === asset
                (head instruction.steps).senderAccount.owner === sender
                (last instruction.steps).receiverAccount.owner === receiver
                exercise instructionCid SettlementInstruction_Process

          dvpNewCid <- create dvp with status = SettlementStatus_Settled
          paymentDepositCids <- mapA (work dvp.buyer seller) $ zipChecked dvp.payments paymentInstructionCids
          deliveryDepositCids <- mapA (work seller dvp.buyer) $ zipChecked dvp.deliveries deliveryInstructionCids
          pure (dvpNewCid, paymentDepositCids, deliveryDepositCids)