module Marketplace.Trading.Model where

import DA.Set (Set, toList)
import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Types (Account, Id(..), Asset(..))
import Marketplace.Trading.Error qualified as Error

data Side
    = Buy
    | Sell
  deriving (Eq, Show)

data TimeInForce --TODO: split this into 'expiry' and 'entry'
    = GTC
      -- ^ Good Till Cancelled (Rests on book until cancellation)
    | GTD with
        expiryDate : Int
      -- ^ Good Till Date (At expiryDate, order will be automatically cancelled).
      -- UTC date and time in seconds
    | GAA
      -- ^ Good At Auction (Expires after auction if not filled)
    | IOC
      -- ^ Immediate Or Cancel (Allows for partial fills)
    | FOK
      -- ^ Fill Or Kill (All or nothing)
  deriving (Eq, Show)

data Details = Details with
    id : Text
    listingId : Text
    asset : Asset
    side : Side
    price : Decimal
    timeInForce : TimeInForce
    optExchangeFee : Optional (ContractId AssetDeposit)
  deriving (Eq, Show)

data Status
    = New
    | PendingExecution
    | PartiallyExecuted
    | FullyExecuted
    | Rejected with
        reason : Error.T
    | PendingCancellation
    | CancellationRejected with
        reason : Error.T
    | Cancelled
  deriving (Eq, Show)

template Execution 
  with
    maker: Party
    taker: Party
    makerOrderCid : ContractId Order
    takerOrderCid : ContractId Order
    quantity : Decimal
    price : Decimal
    timestamp : Time
  where
    signatory maker, taker

data TradeCollateral
    = Cleared with
        clearinghouse: Party
    | Collateral (ContractId AssetDeposit)
  deriving (Show, Eq)

{-
-- | Lens for deposit collateral
pledgedDeposit : TradeCollateral -> Optional (ContractId AssetDeposit)
pledgedDeposit (Collateral depositCid) = Some depositCid
pledgedDeposit (Cleared _) = None

isClearedOrder : Order -> Bool
isClearedOrder Order{collateral = Cleared _} = True
isClearedOrder _                             = False
-}

type T = Order

type OrderId = Text

-- | Initializes a new `State` record from an `Order`
newState : Order -> State
newState order = State with
  originator = order.originator
  executor = order.executor
  orderId = order.details.id
  status = New
  quantityRemaining = order.details.asset.quantity


-- | These are fields that are static throughout the lifetime of the order
-- An order represents a firm intent to exchange an asset vs the `executor`, which must
-- approve the order through the `Trading.Service`. Once approved, an order can be executed
-- with the `Match` choice. There is no 'last-look'.
template Order
  with
    originator : Party
    executor : Party
    details : Details
    -- createdAt : Time -- can't guarantee this in on a bare create
  where
    signatory originator, executor 

    key (originator, details.id) : (Party, OrderId)
    maintainer key._1

    controller executor can 
      -- | (partially) match against an existing order
      nonconsuming Cross : (ContractId Execution, ContractId State, ContractId State)
        with contraCid : ContractId Order
        do timestamp <- getTime
           contraOrder <- fetch contraCid
           (contraStateCid, contraState) <- fetchByKey (originator, contraOrder.details.id)
           (stateCid, state) <- fetchByKey (executor, this.details.id)
           let order = this
               quantity = min state.quantityRemaining contraState.quantityRemaining
               execution = Execution with
                 maker = originator
                 taker = executor
                 makerOrderCid = self -- TODO: What if we amend the order? e.g. change price?
                 takerOrderCid = contraCid
                 quantity
                 price = contraOrder.details.price
                 timestamp
           assertMsg "order direction is the same" $ order.details.side /= contraOrder.details.side
           assertMsg "invalid price" case order.details.side of
             Buy -> order.details.price <= contraOrder.details.price
             Sell -> order.details.price >= contraOrder.details.price
           archive stateCid
           archive contraStateCid
           [stateCid', contraStateCid'] <- forA [state, contraState] \s ->
             let quantityRemaining = s.quantityRemaining - execution.quantity
             in create s with  --TODO: validate FOK orders, handle IOC
                  status = if quantityRemaining > 0.0 then PartiallyExecuted else FullyExecuted
                  quantityRemaining
           executionCid <- create execution
           return (executionCid, stateCid', contraStateCid')

      -- | create a brand new order and (partially) match against this one atomically
    nonconsuming choice Fill : (ContractId Execution, ContractId Order, ContractId State, ContractId State)
      with counterparty : Party -- | ^ May be different from executor, e.g. in case of a give-up
           contraOrder : Order
      controller counterparty
         do 
           contraCid <- create contraOrder
           create $ newState contraOrder
           (e, s, s') <- exercise self Cross with contraCid
           return (e, contraCid, s, s')

-- | These are (exogenous) fields that change through the lifetime of the order, and are updated
-- by the executor
template State
  with 
    originator : Party
    executor : Party
    orderId : OrderId
    status : Status
    quantityRemaining : Decimal
  where
    signatory executor
    observer originator
    key (executor, orderId) : (Party, OrderId)
    maintainer key._1
    ensure case status of
      New -> quantityRemaining > 0.0
      PendingExecution -> quantityRemaining > 0.0
      PartiallyExecuted -> quantityRemaining > 0.0
      FullyExecuted -> quantityRemaining <= 0.0
      _ -> True
   
template Booking
  with
    deposit: AssetDeposit
    allocations : [Allocation]
  where
    signatory signatory deposit ++ (allocations >>= toList . (.account.id.signatories))

data Allocation = Allocation
  with
    ratio : Decimal
    account : Account
  deriving (Eq, Show)

data Fee = Fee with
    amount : Decimal
    currency : Id
    timeInEffect : Time
  deriving (Show, Eq)

template FeeSchedule
  with
    operator : Party
    provider : Party
    currentFee : Fee
    pastFees : [Fee]
    feeAccount : Account
    observers : Set Party
  where
    signatory provider
    key (operator, provider) : (Party, Party)
    maintainer key._2
    observer observers

    controller provider can
      UpdateFeeSchedule : ContractId FeeSchedule
        with
          amount : Decimal
          currency : Id
        do
          timeInEffect <- getTime
          let newFee = Fee with ..
          create this with currentFee = newFee; pastFees = currentFee :: pastFees
