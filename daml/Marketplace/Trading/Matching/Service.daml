module Marketplace.Trading.Matching.Service where

import Marketplace.Trading.Model qualified as Order
import Marketplace.Utils

template Service
  with
    operator : Party
    provider : Party
  where
    signatory operator, provider

    key provider : Party
    maintainer key
{-
    controller provider can
      -- | Return matched orders with updated execution state
      nonconsuming MatchOrders : (ContractId Order.Execution, ContractId Order.State, ContractId Order.State)
        with execution: Order.Execution
        do
          e <- create execution
          [o1, o2] <- forA [execution.makerOrderId, execution.takerOrderId] 
            \orderId -> do
              (orderStateCid, orderState) <- fetchByKey @Order.State (provider, orderId)
              (_, order) <- fetchByKey @Order.T (provider, orderId)
              
              let
                quantityRemaining = orderState.quantityRemaining - execution.quantity --FIXME handle overfills
                status = if quantityRemaining > 0.0 then Order.PartiallyExecuted else Order.FullyExecuted 

              archive orderStateCid
              create orderState with quantityRemaining, status 
          pure (e, o1, o2)
-}

    controller operator can
      Terminate : ()
        do return ()

template Offer
  with
    operator : Party
    provider : Party
  where
    signatory operator

    controller provider can
      Accept : ContractId Service
        do
          createOrLookup Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    provider : Party
    operator : Party
  where
    signatory provider

    controller operator can
      Approve : ContractId Service
        do
          createOrLookup Service with ..

      Reject : ()
        do
          return ()
