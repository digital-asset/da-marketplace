module Marketplace.Trading.Confirmation.Model where

import DA.List (head)
import DA.Foldable (forA_)
import DA.Finance.Asset (AssetDeposit, AssetDeposit_Split(..))
import DA.Finance.Types (Account(..))
import DA.Finance.Utils (fetchAndArchive)
import DA.Set (Set, insert)
import Marketplace.Settlement.Model qualified as Settlement
import qualified Marketplace.Rule.AllocationAccount as AllocationAccountRule (T, Transfer(..))
import Marketplace.Trading.Model qualified as Order
import DA.Optional.Total (whenSome)
import DA.Functor (void)

-- TODO: Try to turn this into a service

data CustomerAccounts = CustomerAccounts with
    customer : Party
    allocationAccount : Account
    tradingAccount : Account
  deriving (Eq, Show)

getAccount : [CustomerAccounts] -> (CustomerAccounts -> Account) -> Party -> Account
getAccount accounts accountType customer = accountType . head $ filter (\account -> account.customer == customer) accounts

type T = Confirmation

template Confirmation
  with
    operator : Party
    provider : Party
    buyer : Party
    seller : Party
    accounts : [CustomerAccounts]
    execution : Order.Execution
    signed : Set Party
  where
    signatory signed

    choice Sign : ContractId Confirmation
      with
        ctrl : Party
        allocationAccount : Account
        tradingAccount : Account
      controller ctrl
      do
        assert (ctrl == buyer || ctrl == seller)
        create this with
          signed = insert ctrl signed
          accounts = (CustomerAccounts with customer = ctrl; ..) :: accounts

    controller provider can
      ProcessCleared : ()
        with
          buyCid : ContractId Order.T
          sellCid : ContractId Order.T
        do
          forA_ [buyCid, sellCid] $ \orderCid -> do
            order <- fetchAndArchive orderCid
            let
              isPartialFill = execution.quantity < order.remainingQuantity
              executions = execution :: order.executions
              remainingQuantity = order.remainingQuantity - execution.quantity
              quantities = [case order.details.side of
                Order.Buy  -> execution.quantity * execution.price
                Order.Sell -> execution.quantity]

            if isPartialFill
              then do
                create order with executions, remainingQuantity, status = Order.PartiallyExecuted
              else do
                create order with executions, remainingQuantity, status = Order.FullyExecuted
            return ()

      Process : ContractId Settlement.SettlementInstruction
        with
          buyCid : ContractId Order.T
          sellCid : ContractId Order.T
        do
          [buyOrder, sellOrder] <- forA [buyCid, sellCid] fetchAndArchive

          -- TODO: Check that price matches limit order price, quantity is less than order qty, rounding, etc
          -- paymentCurrencyId <- (.quotedAssetId) . snd <$> fetchByKey @Listing (operator, provider, buyOrder.details.symbol)

          [payment, delivery] <- forA [(buyOrder, buyer, seller), (sellOrder, seller, buyer)] (\(order, party, counterparty) -> do
            let
              isPartialFill = execution.quantity < order.remainingQuantity
              executions = execution :: order.executions
              remainingQuantity = order.remainingQuantity - execution.quantity
              quantities = [case order.details.side of
                Order.Buy  -> execution.quantity * execution.price
                Order.Sell -> execution.quantity]
              getAllocationAccount = getAccount accounts (.allocationAccount)
              getTradingAccount    = getAccount accounts (.tradingAccount)

            let transferToFeeAccount : ContractId AssetDeposit -> Update (ContractId AssetDeposit)
                transferToFeeAccount depositCid = do
                  feeAccount <- (.feeAccount) . snd <$> fetchByKey @Order.FeeSchedule (operator, provider)
                  exerciseByKey @AllocationAccountRule.T (getAllocationAccount party).id
                      AllocationAccountRule.Transfer with transferTo = feeAccount; ..

            let (Order.Collateral depositCid) = order.collateral
            depositCid <- if isPartialFill
              then do
                newOptExchangeFee <- case order.details.optExchangeFee of
                  None               -> return None
                  Some feeDepositCid -> do
                    feeQuantity <- (.asset.quantity) <$> fetch feeDepositCid
                    let feeToTake = roundBankers 2 $ feeQuantity * (execution.quantity / order.remainingQuantity)
                    [feeDepositCid, remainingFeeDepositCid] <- exercise feeDepositCid AssetDeposit_Split with quantities = [feeToTake]
                    transferToFeeAccount feeDepositCid
                    return $ Some remainingFeeDepositCid

                (depositCid :: depositRemainingCid :: _) <- exercise depositCid AssetDeposit_Split with ..
                create order with
                  executions, remainingQuantity
                  collateral = Order.Collateral depositRemainingCid, status = Order.PartiallyExecuted
                  details = order.details with optExchangeFee = newOptExchangeFee
                pure depositCid
              else do
                whenSome order.details.optExchangeFee (void . transferToFeeAccount)
                create order with
                  executions, remainingQuantity
                  status = Order.FullyExecuted, details = order.details with optExchangeFee = None
                pure depositCid

            pure Settlement.SettlementDetails with depositCid; senderAccount = getAllocationAccount party; receiverAccount = getTradingAccount counterparty
            )

          create Settlement.SettlementInstruction with ..
