module Marketplace.Trading.Confirmation.Model where

import DA.List (head)
import DA.Foldable (forA_)
import DA.Finance.Asset (AssetDeposit, AssetDeposit_Split(..))
import DA.Finance.Types (Account(..))
import DA.Finance.Utils (fetchAndArchive)
import DA.Set (Set, insert)
import Marketplace.Settlement.Model qualified as Settlement
import Marketplace.Trading.Model qualified as Order
import DA.Optional.Total (optionalToList)
import Marketplace.Rule.AllocationAccount qualified as Allocation
import Marketplace.Rule.AllocationAccount (AllocationAccountRule(..))

-- TODO: Try to turn this into a service

data CustomerAccounts = CustomerAccounts with
    customer : Party
    allocationAccount : Account
    tradingAccount : Account
  deriving (Eq, Show)

getAccount : [CustomerAccounts] -> (CustomerAccounts -> Account) -> Party -> Account
getAccount accounts accountType customer = accountType . head $ filter (\account -> account.customer == customer) accounts

type T = Confirmation

template Confirmation
  with
    operator : Party
    provider : Party
    buyer : Party
    seller : Party
    accounts : [CustomerAccounts]
    execution : Order.Execution
    signed : Set Party
  where
    signatory signed

    choice Sign : ContractId Confirmation
      with
        ctrl : Party
        allocationAccount : Account
        tradingAccount : Account
      controller ctrl
      do
        assert (ctrl == buyer || ctrl == seller)
        create this with
          signed = insert ctrl signed
          accounts = (CustomerAccounts with customer = ctrl; ..) :: accounts

    controller provider can
      ProcessCleared : ()
        with
          buyCid : ContractId Order.T
          sellCid : ContractId Order.T
        do
          forA_ [buyCid, sellCid] $ \orderCid -> do
            order <- fetchAndArchive orderCid
            let
              isPartialFill = execution.quantity < order.remainingQuantity
              executions = execution :: order.executions
              remainingQuantity = order.remainingQuantity - execution.quantity
              quantities = [case order.details.side of
                Order.Buy  -> execution.quantity * execution.price
                Order.Sell -> execution.quantity]

            if isPartialFill
              then do
                create order with executions, remainingQuantity, status = Order.PartiallyExecuted
              else do
                create order with executions, remainingQuantity, status = Order.FullyExecuted
            return ()

      Process : ContractId Settlement.SettlementInstruction
        with
          buyCid : ContractId Order.T
          sellCid : ContractId Order.T
        do
          [buyOrder, sellOrder] <- forA [buyCid, sellCid] fetchAndArchive

          -- TODO: Check that price matches limit order price, quantity is less than order qty, rounding, etc
          -- paymentCurrencyId <- (.quotedAssetId) . snd <$> fetchByKey @Listing (operator, provider, buyOrder.details.symbol)

          details <- concat <$> forA [(buyOrder, buyer, seller), (sellOrder, seller, buyer)] (\(order, party, counterparty) -> do
            let
              isPartialFill = execution.quantity < order.remainingQuantity
              executions = execution :: order.executions
              remainingQuantity = order.remainingQuantity - execution.quantity
              quantities = [case order.details.side of
                Order.Buy  -> execution.quantity * execution.price
                Order.Sell -> execution.quantity]
              getAllocationAccount = getAccount accounts (.allocationAccount)
              getTradingAccount    = getAccount accounts (.tradingAccount)

            let createFeeDetails : ContractId AssetDeposit -> Update Settlement.SettlementDetails
                createFeeDetails depositCid = do
                  feeAccount <- (.feeAccount) . snd <$> fetchByKey @Order.FeeSchedule (operator, provider)
                  pure $ Settlement.SettlementDetails with depositCid; senderAccount = getAllocationAccount party; receiverAccount = feeAccount

            let (Order.Collateral depositCid) = order.collateral
            (depositCid, optFeeDetails) <- if isPartialFill
              then do
                (newOptExchangeFee, feeDetails) <- case order.details.optExchangeFee of
                  None               -> return (None, None)
                  Some feeDepositCid -> do
                    feeQuantity <- (.asset.quantity) <$> fetch feeDepositCid
                    let feeToTake = roundBankers 2 $ feeQuantity * (execution.quantity / order.remainingQuantity)
                    [feeDepositCid, remainingFeeDepositCid] <- exercise feeDepositCid AssetDeposit_Split with quantities = [feeToTake]
                    feeDetails <- createFeeDetails feeDepositCid
                    return $ (Some remainingFeeDepositCid, Some feeDetails)

                (depositCid :: depositRemainingCid :: _) <- exercise depositCid AssetDeposit_Split with quantities
                create order with
                  executions, remainingQuantity
                  collateral = Order.Collateral depositRemainingCid, status = Order.PartiallyExecuted
                  details = order.details with optExchangeFee = newOptExchangeFee
                pure (depositCid, feeDetails)
              else do
                optFeeDetails <- case order.details.optExchangeFee of
                  Some feeCid -> Some <$> createFeeDetails feeCid
                  _           -> return None

                depositCid <- exercise depositCid AssetDeposit_Split with quantities >>= \case
                  [depositCid] -> pure depositCid
                  (depositCid :: remainingDepositCid :: _) -> do
                    exerciseByKey @AllocationAccountRule (getAllocationAccount party).id Allocation.Withdraw with transferTo = (getTradingAccount party); depositCid = remainingDepositCid
                    pure depositCid
                  [] -> pure depositCid

                create order with
                  executions, remainingQuantity
                  status = Order.FullyExecuted, details = order.details with optExchangeFee = None
                pure (depositCid, optFeeDetails)

            let tradeDetails = Settlement.SettlementDetails with depositCid; senderAccount = getAllocationAccount party; receiverAccount = getTradingAccount counterparty
            pure $ optionalToList optFeeDetails <> [tradeDetails]
            )

          create Settlement.SettlementInstruction with ..
