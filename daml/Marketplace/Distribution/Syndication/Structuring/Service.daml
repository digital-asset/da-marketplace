module Marketplace.Distribution.Syndication.Structuring.Service where

import DA.Finance.Types (Id)
import DA.Finance.Utils (fetchAndArchive)
import DA.Foldable (forA_)
import DA.Optional (catOptionals)
import Marketplace.Distribution.Syndication.Structuring.Model (Deal(..), CreateTranche(..), Tranche, CreateDealRequest(..), AddTrancheRequest(..))
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Distribution.Syndication.BookBuilding.Model qualified as BookBuilding
import Marketplace.Settlement.Hierarchical.Util (SettlementMode)
import Marketplace.Utils

type S = Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice RequestCreateDeal : ContractId CreateDealRequest
      with
        dealId : Text
      controller customer
        do
          create CreateDealRequest with ..

    nonconsuming choice RequestAddTranche : ContractId AddTrancheRequest
      with
        settlementBank : Party
        bndBank : Party
        cashProvider : Party
        bondRegistrar : Party
        payingAgent : Party
        dealId : Text
        trancheId : Text
        deliveryId : Id
        paymentId : Id
        size : Decimal
        issuerSettlementMode : SettlementMode
        bndSettlementMode : SettlementMode
      controller customer
        do
          create AddTrancheRequest with ..

    nonconsuming choice CloseBook : [ContractId Bidding.Allocation]
      with
        buildRequestCids : [ContractId BookBuilding.BuildRequest]
        bidCids : [ContractId Bidding.Bid]
        allocations : [(Party, Decimal)]
        offeredPrice : Decimal
      controller customer
        do
          let
            allocate bidCid = do
              bid <- fetch bidCid
              case find (\(p, _) -> p == bid.investor) allocations of
                Some (_, offeredQuantity) -> do
                  Some <$> exercise bidCid Bidding.Allocate with offeredPrice; offeredQuantity
                None -> do
                  exercise bidCid Bidding.Reject
                  pure None
          forA_ buildRequestCids (`exercise` BookBuilding.Delete)
          catOptionals <$> mapA allocate bidCids

    nonconsuming choice CreateDeal : ContractId Deal
      with
        createDealRequestCid : ContractId CreateDealRequest
      controller provider
        do
          CreateDealRequest{..} <- fetchAndArchive createDealRequestCid
          create Deal with dealProvider = provider; issuer = customer; trancheIds = []; ..

    nonconsuming choice AddTranche : (ContractId Deal, ContractId Tranche)
      with
        addTrancheRequestCid : ContractId AddTrancheRequest
      controller provider
        do
          AddTrancheRequest{..} <- fetchAndArchive addTrancheRequestCid
          exerciseByKey @Deal (operator, customer, dealId) CreateTranche with ..

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider
    observer customer
    
    choice Accept : ContractId Service
      controller customer
        do
          createOrLookup Service with ..

    choice Decline : ()
      controller customer
        do
          return ()

    choice Withdraw : ()
      controller provider
        do pure ()

template Request
  with
    provider : Party
    customer : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
        do pure ()

    choice Reject : ()
      controller provider
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        createOrLookup Service with ..
