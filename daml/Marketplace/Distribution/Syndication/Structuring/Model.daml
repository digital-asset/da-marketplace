module Marketplace.Distribution.Syndication.Structuring.Model where

import DA.Finance.Types (Id, Account, Asset(..))
import DA.List (groupOn, singleton)
import DA.Optional (fromSome)
import DA.Set (fromList)
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Settlement.Hierarchical (SettlementInstruction(..), Trade(..), Status(..))

template CreateDealRequest
  with
    operator : Party
    provider : Party
    customer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    dealId : Text
    priceId : Id
  where
    signatory operator, provider, customer

template AddTrancheRequest
  with
    operator : Party
    provider : Party
    customer : Party
    dealId : Text
    tranche : Asset
  where
    signatory operator, provider, customer

template AccountInfo
  with
    operator : Party
    party : Party
    ownAccount : Optional Account
    cashAccount : Optional Account
    securitiesAccount : Optional Account
  where
    signatory operator, party

    key (operator, party) : (Party, Party)
    maintainer key._1


createInstructions : Bool -> Party -> Party -> Party -> Text -> Int -> Asset -> Account -> Account -> Update [ContractId SettlementInstruction]
createInstructions isCash operator agent rootProvider settlementId instructionIdx asset senderAccount receiverAccount = do
  let
    createInstruction sender receiver sAcc rAcc siAsset instIdx = do
      let si = SettlementInstruction with senderAccount = sAcc; receiverAccount = rAcc; asset = siAsset; signed = []; depositCid = None; instructionId = show instIdx; ..
      if sender == receiver then pure [] else singleton <$> create si
  if senderAccount.provider == rootProvider && receiverAccount.provider == rootProvider then do -- TODO: Could shortcut this if common custodian is found earlier below in the hierarchy
    createInstruction senderAccount.owner receiverAccount.owner senderAccount receiverAccount asset instructionIdx
  else if senderAccount.provider == rootProvider then do
    (_, providerAccountInfo) <- fetchByKey @AccountInfo (operator, receiverAccount.provider)
    let providerAccount = if isCash then fromSome providerAccountInfo.cashAccount else fromSome providerAccountInfo.securitiesAccount
    sis1 <- createInstruction receiverAccount.provider receiverAccount.owner (fromSome providerAccountInfo.ownAccount) receiverAccount (asset with id.signatories = fromList [providerAccountInfo.party]) instructionIdx
    sis2 <- createInstructions isCash operator agent rootProvider settlementId (instructionIdx + 1) asset senderAccount providerAccount
    pure $ sis1 <> sis2
  else if receiverAccount.provider == rootProvider then do
    (_, providerAccountInfo) <- fetchByKey @AccountInfo (operator, senderAccount.provider)
    let providerAccount = if isCash then fromSome providerAccountInfo.cashAccount else fromSome providerAccountInfo.securitiesAccount
    sis1 <- createInstruction senderAccount.owner senderAccount.provider senderAccount (fromSome providerAccountInfo.ownAccount) (asset with id.signatories = fromList [providerAccountInfo.party]) instructionIdx
    sis2 <- createInstructions isCash operator agent rootProvider settlementId (instructionIdx + 1) asset providerAccount receiverAccount
    pure $ sis1 <> sis2
  else do
    (_, senderProviderAccountInfo) <- fetchByKey @AccountInfo (operator, senderAccount.provider)
    let senderProviderAccount = if isCash then fromSome senderProviderAccountInfo.cashAccount else fromSome senderProviderAccountInfo.securitiesAccount
    sis1 <- createInstruction senderAccount.owner senderAccount.provider senderAccount (fromSome senderProviderAccountInfo.ownAccount) (asset with id.signatories = fromList [senderProviderAccountInfo.party]) instructionIdx
    (_, receiverProviderAccountInfo) <- fetchByKey @AccountInfo (operator, receiverAccount.provider)
    let receiverProviderAccount = if isCash then fromSome receiverProviderAccountInfo.cashAccount else fromSome receiverProviderAccountInfo.securitiesAccount
    sis2 <- createInstruction receiverAccount.provider receiverAccount.owner (fromSome receiverProviderAccountInfo.ownAccount) receiverAccount (asset with id.signatories = fromList [receiverProviderAccountInfo.party]) (instructionIdx + 1)
    sis3 <- createInstructions isCash operator agent rootProvider settlementId (instructionIdx + 2) asset senderProviderAccount receiverProviderAccount
    pure $ sis1 <> sis2 <> sis3

template Deal
  with
    operator : Party
    structurer : Party
    issuer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    tranches : [Asset]
    dealId : Text
    priceId : Id
  where
    signatory operator, structurer, issuer

    key (operator, issuer, dealId) : (Party, Party, Text)
    maintainer key._1

    controller operator can
      nonconsuming InstructIssuerSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            grouped = groupOn (\c -> c.asset.id.label) confirmations
            settleTranche confs asset = do
              let
                filtered = filter (\c -> c.asset.id.label == asset.id.label) confs
                quantities = map (.asset.quantity) filtered
                aggregate = sum quantities
                aggregateAsset = asset with quantity = aggregate
                aggregatePrice = Asset with id = priceId; quantity = aggregate * price
                settlementId = asset.id.label <> "-" <> partyToText issuer <> "-" <> partyToText settlementBank
              (_, issuerAccountInfo) <- fetchByKey @AccountInfo (operator, issuer)
              (_, settlementBankAccountInfo) <- fetchByKey @AccountInfo (operator, settlementBank)
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementId 0 aggregateAsset (fromSome issuerAccountInfo.securitiesAccount) (fromSome settlementBankAccountInfo.securitiesAccount)
              cashSis <- createInstructions True operator bondRegistrar cashProvider settlementId (length bondSis) aggregatePrice (fromSome settlementBankAccountInfo.cashAccount) (fromSome issuerAccountInfo.cashAccount)
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              create Trade with operator; agent = bondRegistrar; deliverer = issuer; payer = settlementBank; settlementId; instructionIds; delivery = aggregateAsset; payment = aggregatePrice; status = Instructed
          mapA (settleTranche confirmations) tranches

      nonconsuming InstructBndSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            grouped = groupOn (\c -> c.asset.id.label) confirmations
            settleTranche confs asset = do
              let
                filtered = filter (\c -> c.asset.id.label == asset.id.label) confs
                quantities = map (.asset.quantity) filtered
                aggregate = sum quantities
                aggregateAsset = asset with quantity = aggregate
                aggregatePrice = Asset with id = priceId; quantity = aggregate * price
                settlementId = asset.id.label <> "-" <> partyToText settlementBank <> "-" <> partyToText bndBank
              (_, settlementBankAccountInfo) <- fetchByKey @AccountInfo (operator, settlementBank)
              (_, bndBankAccountInfo) <- fetchByKey @AccountInfo (operator, bndBank)
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementId 0 aggregateAsset (fromSome settlementBankAccountInfo.securitiesAccount) (fromSome bndBankAccountInfo.securitiesAccount)
              cashSis <- createInstructions True operator bondRegistrar cashProvider settlementId (length bondSis) aggregatePrice (fromSome bndBankAccountInfo.cashAccount) (fromSome settlementBankAccountInfo.cashAccount)
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = aggregateAsset; payment = aggregatePrice; status = Instructed
          mapA (settleTranche confirmations) tranches

      nonconsuming InstructInvestorSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            grouped = groupOn (\c -> c.asset.id.label) confirmations
            settleInvestor asset conf = do
              let
                aggregatePrice = conf.price with quantity = conf.price.quantity * conf.asset.quantity
                settlementId = asset.id.label <> "-" <> partyToText bndBank <> "-" <> partyToText conf.investor
              (_, bndBankAccountInfo) <- fetchByKey @AccountInfo (operator, bndBank)
              (_, investorAccountInfo) <- fetchByKey @AccountInfo (operator, conf.investor)
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementId 0 conf.asset (fromSome bndBankAccountInfo.securitiesAccount) (fromSome investorAccountInfo.securitiesAccount)
              cashSis <- createInstructions True operator bondRegistrar cashProvider settlementId (length bondSis) aggregatePrice (fromSome investorAccountInfo.cashAccount) (fromSome bndBankAccountInfo.cashAccount)
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = conf.asset; payment = aggregatePrice; status = Instructed
            settleTranche confs asset = do
              let
                filtered = filter (\c -> c.asset.id.label == asset.id.label) confs
              mapA (settleInvestor asset) filtered
          concat <$> mapA (settleTranche confirmations) tranches
