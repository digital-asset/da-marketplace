module Marketplace.Distribution.Syndication.Structuring.Model where

import DA.Finance.Types (Id, Asset(..))
import DA.List (groupOn)
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Settlement.Hierarchical (createInstructions, Trade(..), Status(..))

template CreateDealRequest
  with
    operator : Party
    provider : Party
    customer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    dealId : Text
    priceId : Id
  where
    signatory operator, provider, customer

template AddTrancheRequest
  with
    operator : Party
    provider : Party
    customer : Party
    dealId : Text
    tranche : Asset
  where
    signatory operator, provider, customer

template Deal
  with
    operator : Party
    structurer : Party
    issuer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    tranches : [Asset]
    dealId : Text
    priceId : Id
  where
    signatory operator, structurer, issuer

    key (operator, issuer, dealId) : (Party, Party, Text)
    maintainer key._1

    controller operator can
      nonconsuming InstructIssuerSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            grouped = groupOn (\c -> c.asset.id.label) confirmations
            settleTranche confs asset = do
              let
                filtered = filter (\c -> c.asset.id.label == asset.id.label) confs
                quantities = map (.asset.quantity) filtered
                aggregate = sum quantities
                aggregateAsset = asset with quantity = aggregate
                aggregatePrice = Asset with id = priceId; quantity = aggregate * price
                settlementId = asset.id.label <> "-" <> partyToText issuer <> "-" <> partyToText settlementBank
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar issuer settlementBank settlementId 0 aggregateAsset
              cashSis <- createInstructions True operator bondRegistrar cashProvider settlementBank issuer settlementId (length bondSis) aggregatePrice
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              create Trade with operator; agent = bondRegistrar; deliverer = issuer; payer = settlementBank; settlementId; instructionIds; delivery = aggregateAsset; payment = aggregatePrice; status = Instructed
          mapA (settleTranche confirmations) tranches

      nonconsuming InstructBndSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            grouped = groupOn (\c -> c.asset.id.label) confirmations
            settleTranche confs asset = do
              let
                filtered = filter (\c -> c.asset.id.label == asset.id.label) confs
                quantities = map (.asset.quantity) filtered
                aggregate = sum quantities
                aggregateAsset = asset with quantity = aggregate
                aggregatePrice = Asset with id = priceId; quantity = aggregate * price
                settlementId = asset.id.label <> "-" <> partyToText settlementBank <> "-" <> partyToText bndBank
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementBank bndBank settlementId 0 aggregateAsset
              cashSis <- createInstructions True operator bondRegistrar cashProvider bndBank settlementBank settlementId (length bondSis) aggregatePrice
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = aggregateAsset; payment = aggregatePrice; status = Instructed
          mapA (settleTranche confirmations) tranches

      nonconsuming InstructInvestorSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            grouped = groupOn (\c -> c.asset.id.label) confirmations
            settleInvestor asset conf = do
              let
                aggregatePrice = conf.price with quantity = conf.price.quantity * conf.asset.quantity
                settlementId = asset.id.label <> "-" <> partyToText bndBank <> "-" <> partyToText conf.investor
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar bndBank conf.investor settlementId 0 conf.asset
              cashSis <- createInstructions True operator bondRegistrar cashProvider conf.investor bndBank settlementId (length bondSis) aggregatePrice
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = conf.asset; payment = aggregatePrice; status = Instructed
            settleTranche confs asset = do
              let
                filtered = filter (\c -> c.asset.id.label == asset.id.label) confs
              mapA (settleInvestor asset) filtered
          concat <$> mapA (settleTranche confirmations) tranches
