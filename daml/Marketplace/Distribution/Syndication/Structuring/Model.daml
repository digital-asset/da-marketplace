module Marketplace.Distribution.Syndication.Structuring.Model where

import DA.Finance.Types (Id, Asset(..), Account)
import DA.Set (fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Settlement.Hierarchical (createInstructions, getAccount, Trade(..), Status(..), SettlementMode(..))
import Marketplace.Settlement.Htlc.Trade qualified as Htlc
import Marketplace.Settlement.Htlc.Util (createInstructionsHtlc, HtlcState(..))
import Marketplace.Issuance.Instrument.Model(Bond(..))
import SwiftMessage.Message (SwiftMessage(MT547), SwiftMessage(MT545), SwiftMessage(MT544), SwiftMessage(MT546), SwiftMessageType(..), SwiftOutboundMessage(..))
import SwiftMessage.Model.MT544
import SwiftMessage.Model.MT545
import SwiftMessage.Model.MT546
import SwiftMessage.Model.MT547
import SwiftMessage.Util

template CreateDealRequest
  with
    operator : Party
    provider : Party
    customer : Party
    dealId : Text
  where
    signatory operator, provider, customer

template AddTrancheRequest
  with
    operator : Party
    provider : Party
    customer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    payingAgent : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
    issuerSettlementMode : SettlementMode
    bndSettlementMode : SettlementMode
  where
    signatory operator, provider, customer

template Deal
  with
    operator : Party
    dealProvider : Party
    issuer : Party
    dealId : Text
    trancheIds : [Text]
  where
    signatory operator, dealProvider, issuer

    key (operator, issuer, dealId) : (Party, Party, Text)
    maintainer key._1

    controller issuer can
      CreateTranche : (ContractId Deal, ContractId Tranche)
        with
          trancheId : Text
          deliveryId : Id
          paymentId : Id
          size : Decimal
          settlementBank : Party
          bndBank : Party
          cashProvider : Party
          bondRegistrar : Party
          payingAgent : Party
          issuerSettlementMode : SettlementMode
          bndSettlementMode : SettlementMode
        do
          dealCid <- create this with trancheIds = trancheIds <> [trancheId]
          trancheCid <- create Tranche with trancheProvider = dealProvider; ..
          pure (dealCid, trancheCid)
-- helper data record for InstructSettlement choices in Tranche
data SettlementResult = SettlementResult with
  settledAmount : Decimal
  settlementId : Text
  totalAsset : Asset
  totalPrice : Asset
  
  deliverer : Party
  payer : Party
  delivererSecAccount : Account
  delivererCashAccount : Account
  payerSecAccount : Account
  payerCashAccount : Account

template Tranche
  with
    operator : Party
    trancheProvider : Party
    issuer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    payingAgent : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
    issuerSettlementMode : SettlementMode
    bndSettlementMode : SettlementMode
  where
    signatory operator, trancheProvider, issuer
    observer settlementBank, bndBank

    key (operator, issuer, dealId, trancheId) : (Party, Party, Text, Text)
    maintainer key._1

    -- helper fuction to send swift message
    let
      createNewSettlementMessage: Text -> SwiftMessage -> SwiftMessageType -> Update (ContractId SwiftOutboundMessage)
      createNewSettlementMessage referenceId swiftMessage swiftMessageType =
        create SwiftOutboundMessage with provider = operator; consumer = operator; status = Pending; observers = fromList [bondRegistrar]; ..

      sendSwiftMessage : Party -> Party -> Decimal -> Decimal -> Id -> Text -> Date -> Date -> Date -> SettlementMode -> Update ()
      sendSwiftMessage seller buyer settledQty settledAmount settledCurrency settlementId dateOfTrade dateOfSettlement effDateOfSettlement settlementMode = do
        (_, sellerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, seller)
        (_, receiverSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, buyer)
        (_, bond) <- fetchByKey @Bond (fromList [bondRegistrar, issuer], deliveryId.label)
        let
          instrumentId = bond.isin <> "-" <> deliveryId.label
          buyerSafekeepingAcc = getAccount False receiverSettlementInfo buyer
          sellerSafekeepingAcc = getAccount False sellerSettlementInfo seller
        if settlementMode == Dvp then do
          let
            mt545 = createMT545Details instrumentId settledQty buyerSafekeepingAcc.provider sellerSafekeepingAcc.provider seller buyer
                    settledAmount settledCurrency
                    dateOfTrade dateOfSettlement effDateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"

            mt547 = createMT547Details instrumentId settledQty buyerSafekeepingAcc.provider sellerSafekeepingAcc.provider seller buyer
                    settledAmount settledCurrency
                    dateOfTrade dateOfSettlement effDateOfSettlement dateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"
          createNewSettlementMessage settlementId (MT545 mt545) MT545_t
          createNewSettlementMessage settlementId (MT547 mt547) MT547_t
        else do
          let
            mt544 = createMT544Details instrumentId settledQty buyerSafekeepingAcc.provider buyerSafekeepingAcc.provider seller buyer
                    dateOfTrade dateOfSettlement effDateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"

            mt546 = createMT546Details instrumentId settledQty buyerSafekeepingAcc.provider sellerSafekeepingAcc.provider seller buyer
                    dateOfTrade dateOfSettlement effDateOfSettlement dateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"
          createNewSettlementMessage settlementId (MT544 mt544) MT544_t
          createNewSettlementMessage settlementId (MT546 mt546) MT546_t
        pure ()

      createSettlementResult : Decimal -> Party -> Party -> Update SettlementResult
      createSettlementResult price deliverer payer = do
        let
          settledAmount = size * price
          settlementId = deliveryId.label <> "-" <> partyToText deliverer <> "-" <> partyToText payer
          totalAsset = Asset with id = deliveryId; quantity = size
          totalPrice = Asset with id = paymentId; quantity = settledAmount
        (_, delivererSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, deliverer)
        (_, payerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, payer)

        let
            delivererSecAccount = getAccount False delivererSettlementInfo deliverer
            delivererCashAccount = getAccount True delivererSettlementInfo deliverer
            payerSecAccount = getAccount False payerSettlementInfo payer
            payerCashAccount = getAccount True payerSettlementInfo payer
        pure $ SettlementResult with ..
      
      -- always from bndBank to investor
      createSettlementResultWithConfirmation : Bidding.Confirmation -> Decimal -> Update SettlementResult
      createSettlementResultWithConfirmation conf price = do
        let
          settledAmount = conf.price.quantity * conf.asset.quantity
          settlementId = deliveryId.label <> "-" <> partyToText bndBank <> "-" <> partyToText conf.investor
          totalAsset = conf.asset
          totalPrice = conf.price with quantity = settledAmount
        (_, bndBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, bndBank)
        (_, investorSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, conf.investor)

        let 
          delivererSecAccount = getAccount False bndBankSettlementInfo bndBank
          delivererCashAccount = getAccount True bndBankSettlementInfo bndBank
          payerSecAccount = getAccount False investorSettlementInfo conf.investor
          payerCashAccount = getAccount True investorSettlementInfo conf.investor
        pure $ SettlementResult with deliverer = bndBank; payer = conf.investor; ..

      createSettlementInstructions : SettlementResult -> Bool -> Update [Text]
      createSettlementInstructions SettlementResult{..} isCashLegRequired = do
        bondSis <- createInstructions False operator bondRegistrar bondRegistrar delivererSecAccount payerSecAccount settlementId 0 totalAsset
        if isCashLegRequired then do
          cashSis <- createInstructions True operator bondRegistrar cashProvider payerCashAccount delivererCashAccount settlementId (length bondSis) totalPrice
          map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
        else 
          map (.instructionId) <$> mapA fetch bondSis
      
      createSettlementInstructionsHtlc : SettlementResult -> Text -> Time -> Update [Text]
      createSettlementInstructionsHtlc SettlementResult{..} hashlock expiry = do
          bondSis <- createInstructionsHtlc False operator bondRegistrar deliverer delivererSecAccount payer payerSecAccount settlementId 0 totalAsset hashlock expiry
          map (.instructionId) <$> mapA fetch bondSis

    controller operator can
      nonconsuming InstructIssuerSettlement : ContractId Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          assertMsg "InstructIssuerSettlement cannot be used with issuerSettlementMode = Htlc" (issuerSettlementMode /= Htlc) 
          
          settlementResult@SettlementResult{..} <- createSettlementResult price issuer settlementBank
          instructionIds <- createSettlementInstructions settlementResult (issuerSettlementMode == Dvp)
        
          sendSwiftMessage issuer settlementBank size settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement issuerSettlementMode
          create Trade with operator; agent = bondRegistrar; deliverer = issuer; payer = settlementBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Instructed; settlementMode = issuerSettlementMode

      nonconsuming InstructIssuerSettlementHtlc : ContractId Htlc.Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
          hashlock : Text
          expiry : Time
        do
          assertMsg "InstructIssuerSettlementHtlc can only be used with issuerSettlementMode = Htlc" (issuerSettlementMode == Htlc)
          
          settlementResult@SettlementResult{..} <- createSettlementResult price issuer settlementBank
          instructionIds <- createSettlementInstructionsHtlc settlementResult hashlock expiry
          
          create Htlc.Trade with operator; deliverer = issuer; delivererAgent = issuer; payer = settlementBank; payerAgent = settlementBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Locked; settlementMode = issuerSettlementMode; hashlock; expiry

      nonconsuming InstructBndSettlement : ContractId Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          assertMsg "InstructBndSettlement cannot be used with bndSettlementMode = Htlc" (bndSettlementMode /= Htlc) 
          settlementResult@SettlementResult{..} <- createSettlementResult price settlementBank bndBank
          instructionIds <- createSettlementInstructions settlementResult (bndSettlementMode == Dvp)

          sendSwiftMessage settlementBank bndBank size settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement bndSettlementMode
          create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Instructed; settlementMode = bndSettlementMode

      nonconsuming InstructBndSettlementHtlc : ContractId Htlc.Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
          hashlock : Text
          expiry : Time
        do
          assertMsg "InstructBndSettlementHtlc can only be used with bndSettlementMode = Htlc" (bndSettlementMode == Htlc)
          
          settlementResult@SettlementResult{..} <- createSettlementResult price settlementBank bndBank
          instructionIds <- createSettlementInstructionsHtlc settlementResult hashlock expiry
          
          create Htlc.Trade with operator; deliverer = settlementBank; delivererAgent = settlementBank; payer = bndBank; payerAgent = bndBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Locked; settlementMode = issuerSettlementMode; hashlock; expiry

      nonconsuming InstructInvestorSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          confirmations <- zip confirmationCids <$> mapA fetch confirmationCids
          let
            filtered = filter (\(_, c) -> c.asset.id == deliveryId) confirmations
            settleConfirmation (confCid, conf) = do
              assertMsg "InstructInvestorSettlement cannot be used with confirmation settlementmode = Htlc" (conf.settlementMode /= Htlc) 
              
              settlementResult@SettlementResult {..} <- createSettlementResultWithConfirmation conf price
              assertMsg "Total confirmed amount is larger than available quantity" $ totalAsset.quantity <= size
              
              instructionIds <- createSettlementInstructions settlementResult (conf.settlementMode == Dvp)
              
              sendSwiftMessage settlementBank bndBank totalAsset.quantity settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement conf.settlementMode
              exercise confCid Bidding.Delete
              create Trade with operator; agent = bondRegistrar; deliverer = bndBank; payer = conf.investor; settlementId; instructionIds; delivery = conf.asset; payment = totalPrice; status = Instructed; settlementMode = conf.settlementMode
          mapA settleConfirmation filtered

      nonconsuming InstructInvestorSettlementHtlc : [(Party, ContractId Htlc.Trade)]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
          hashlock : Text
          expiry : Time
        do
          confirmations <- zip confirmationCids <$> mapA fetch confirmationCids
          let
            filtered = filter (\(_, c) -> c.asset.id == deliveryId) confirmations
            settleConfirmation : (ContractId Bidding.Confirmation, Bidding.Confirmation) -> Update (Party, ContractId Htlc.Trade)
            settleConfirmation (confCid, conf) = do
              assertMsg "InstructInvestorSettlementHtlc can only be used with confirmation settlementmode = Htlc" (conf.settlementMode == Htlc)
              
              settlementResult@SettlementResult{..} <- createSettlementResultWithConfirmation conf price
              assertMsg "Total confirmed amount is larger than available quantity" $ totalAsset.quantity <= size
              
              instructionIds <- createSettlementInstructionsHtlc settlementResult hashlock expiry              
              
              exercise confCid Bidding.Delete
              tradeCid <- create Htlc.Trade with operator; deliverer = bndBank; delivererAgent = bndBank; payer = conf.investor; payerAgent = conf.investor; settlementId; instructionIds; delivery = conf.asset; payment = totalPrice; status = Locked; settlementMode = issuerSettlementMode; hashlock; expiry              
              pure (conf.investor, tradeCid)
          mapA settleConfirmation filtered