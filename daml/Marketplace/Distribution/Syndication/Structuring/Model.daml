module Marketplace.Distribution.Syndication.Structuring.Model where

import DA.Finance.Types (Id, Asset(..))
import DA.Set (fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Settlement.Hierarchical (createInstructions, getAccount, Trade(..), Status(..))
import Marketplace.Issuance.Instrument.Model(Bond(..))
import SwiftMessage.Model.MT545
import SwiftMessage.Model.MT547
import SwiftMessage.Util
import SwiftMessage.Message (SwiftMessage(MT547), SwiftMessage(MT545), SwiftMessageType(..), SwiftOutboundMessage(..))

template CreateDealRequest
  with
    operator : Party
    provider : Party
    customer : Party
    dealId : Text
  where
    signatory operator, provider, customer

template AddTrancheRequest
  with
    operator : Party
    provider : Party
    customer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    payingAgent : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
  where
    signatory operator, provider, customer

template Deal
  with
    operator : Party
    dealProvider : Party
    issuer : Party
    dealId : Text
    trancheIds : [Text]
  where
    signatory operator, dealProvider, issuer

    key (operator, issuer, dealId) : (Party, Party, Text)
    maintainer key._1

    controller issuer can
      CreateTranche : (ContractId Deal, ContractId Tranche)
        with
          trancheId : Text
          deliveryId : Id
          paymentId : Id
          size : Decimal
          settlementBank : Party
          bndBank : Party
          cashProvider : Party
          bondRegistrar : Party
          payingAgent : Party
        do
          dealCid <- create this with trancheIds = trancheIds <> [trancheId]
          trancheCid <- create Tranche with trancheProvider = dealProvider; ..
          pure (dealCid, trancheCid)

template Tranche
  with
    operator : Party
    trancheProvider : Party
    issuer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    payingAgent : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
  where
    signatory operator, trancheProvider, issuer
    observer settlementBank, bndBank

    key (operator, issuer, dealId, trancheId) : (Party, Party, Text, Text)
    maintainer key._1

    -- helper fuction to send swift message
    let
      sendSwiftMessage : Party -> Party -> Decimal -> Decimal -> Id -> Text -> Date -> Date -> Date -> Update (ContractId SwiftOutboundMessage)
      sendSwiftMessage seller buyer settledQty settledAmount settledCurrency settlementId dateOfTrade dateOfSettlement effDateOfSettlement = do
        (_, sellerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, seller)
        (_, receiverSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, buyer)
        (_, bond) <- fetchByKey @Bond (fromList [bondRegistrar, issuer], deliveryId.label)
        let
          instrumentId = bond.isin <> "-" <> deliveryId.label
          buyerSafekeepingAcc = getAccount False receiverSettlementInfo buyer
          sellerSafekeepingAcc = getAccount False sellerSettlementInfo seller
          mt545 = createMT545Details instrumentId settledQty buyerSafekeepingAcc.provider seller settledAmount settledCurrency
                    dateOfTrade dateOfSettlement effDateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"

          mt547 = createMT547Details instrumentId settledQty sellerSafekeepingAcc.provider seller settledAmount settledCurrency
                    dateOfTrade dateOfSettlement effDateOfSettlement dateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"
        create SwiftOutboundMessage with referenceId = settlementId; provider = operator ; consumer = operator; swiftMessage=MT545 (mt545); swiftMessageType=MT545_t; status=Pending; observers= fromList [bondRegistrar]
        create SwiftOutboundMessage with referenceId = settlementId; provider = operator ; consumer = operator; swiftMessage=MT547 (mt547); swiftMessageType=MT547_t; status=Pending; observers=fromList [bondRegistrar]

    controller operator can
      nonconsuming InstructIssuerSettlement : ContractId Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          let
            settledAmount = size * price
            totalAsset = Asset with id = deliveryId; quantity = size
            totalPrice = Asset with id = paymentId; quantity = settledAmount
            settlementId = deliveryId.label <> "-" <> partyToText issuer <> "-" <> partyToText settlementBank
          (_, issuerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, issuer)
          (_, settlementBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, settlementBank)
          let
            issuerCashAccount = getAccount True issuerSettlementInfo issuer
            settlementBankCashAccount = getAccount True settlementBankSettlementInfo settlementBank
            issuerSecuritiesAccount = getAccount False issuerSettlementInfo issuer
            settlementBankSecuritiesAccount = getAccount False settlementBankSettlementInfo settlementBank
          bondSis <- createInstructions False operator bondRegistrar bondRegistrar issuerSecuritiesAccount settlementBankSecuritiesAccount settlementId 0 totalAsset
          cashSis <- createInstructions True operator bondRegistrar cashProvider settlementBankCashAccount issuerCashAccount settlementId (length bondSis) totalPrice
          instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
          sendSwiftMessage issuer settlementBank size settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement
          create Trade with operator; agent = bondRegistrar; deliverer = issuer; payer = settlementBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Instructed

      nonconsuming InstructBndSettlement : ContractId Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          let
            settledAmount = size * price
            totalAsset = Asset with id = deliveryId; quantity = size
            totalPrice = Asset with id = paymentId; quantity = settledAmount
            settlementId = deliveryId.label <> "-" <> partyToText settlementBank <> "-" <> partyToText bndBank
          (_, bndBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, bndBank)
          (_, settlementBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, settlementBank)
          let
            bndBankCashAccount = getAccount True bndBankSettlementInfo bndBank
            settlementBankCashAccount = getAccount True settlementBankSettlementInfo settlementBank
            bndBankSecuritiesAccount = getAccount False bndBankSettlementInfo bndBank
            settlementBankSecuritiesAccount = getAccount False settlementBankSettlementInfo settlementBank
          bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementBankSecuritiesAccount bndBankSecuritiesAccount settlementId 0 totalAsset
          cashSis <- createInstructions True operator bondRegistrar cashProvider bndBankCashAccount settlementBankCashAccount settlementId (length bondSis) totalPrice
          instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
          sendSwiftMessage settlementBank bndBank size settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement
          create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Instructed

      nonconsuming InstructInvestorSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          confirmations <- zip confirmationCids <$> mapA fetch confirmationCids
          let
            filtered = filter (\(_, c) -> c.asset.id == deliveryId) confirmations
            settleConfirmation (confCid, conf) = do
              let
                aggregate = conf.asset.quantity
                settledAmount = conf.price.quantity * conf.asset.quantity
                aggregatePrice = conf.price with quantity = settledAmount
                settlementId = deliveryId.label <> "-" <> partyToText bndBank <> "-" <> partyToText conf.investor
              (_, bndBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, bndBank)
              (_, investorSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, conf.investor)
              let
                bndBankCashAccount = getAccount True bndBankSettlementInfo bndBank
                investorCashAccount = getAccount True investorSettlementInfo conf.investor
                bndBankSecuritiesAccount = getAccount False bndBankSettlementInfo bndBank
                investorSecuritiesAccount = getAccount False investorSettlementInfo conf.investor
              assertMsg "Total confirmed amount is larger than available quantity" $ aggregate <= size
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar bndBankSecuritiesAccount investorSecuritiesAccount settlementId 0 conf.asset
              cashSis <- createInstructions True operator bondRegistrar cashProvider investorCashAccount bndBankCashAccount settlementId (length bondSis) aggregatePrice
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              sendSwiftMessage settlementBank bndBank aggregate settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement
              exercise confCid Bidding.Delete
              create Trade with operator; agent = bondRegistrar; deliverer = bndBank; payer = conf.investor; settlementId; instructionIds; delivery = conf.asset; payment = aggregatePrice; status = Instructed
          mapA settleConfirmation filtered
