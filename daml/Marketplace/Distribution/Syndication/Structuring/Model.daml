module Marketplace.Distribution.Syndication.Structuring.Model where

import DA.Finance.Types (Id, Asset(..))
import DA.Set (fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Settlement.Hierarchical (createInstructions, getAccount, Trade(..), Status(..), SettlementMode(..))
import Marketplace.Settlement.Htlc.Trade qualified as Htlc
import Marketplace.Settlement.Htlc.Util (createInstructionsHtlc, HtlcState(..))
import Marketplace.Issuance.Instrument.Model(Bond(..))
import SwiftMessage.Message (SwiftMessage(MT547), SwiftMessage(MT545), SwiftMessage(MT544), SwiftMessage(MT546), SwiftMessageType(..), SwiftOutboundMessage(..))
import SwiftMessage.Model.MT544
import SwiftMessage.Model.MT545
import SwiftMessage.Model.MT546
import SwiftMessage.Model.MT547
import SwiftMessage.Util

template CreateDealRequest
  with
    operator : Party
    provider : Party
    customer : Party
    dealId : Text
  where
    signatory operator, provider, customer

template AddTrancheRequest
  with
    operator : Party
    provider : Party
    customer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    payingAgent : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
    issuerSettlementMode : SettlementMode
    bndSettlementMode : SettlementMode
  where
    signatory operator, provider, customer

template Deal
  with
    operator : Party
    dealProvider : Party
    issuer : Party
    dealId : Text
    trancheIds : [Text]
  where
    signatory operator, dealProvider, issuer

    key (operator, issuer, dealId) : (Party, Party, Text)
    maintainer key._1

    controller issuer can
      CreateTranche : (ContractId Deal, ContractId Tranche)
        with
          trancheId : Text
          deliveryId : Id
          paymentId : Id
          size : Decimal
          settlementBank : Party
          bndBank : Party
          cashProvider : Party
          bondRegistrar : Party
          payingAgent : Party
          issuerSettlementMode : SettlementMode
          bndSettlementMode : SettlementMode
        do
          dealCid <- create this with trancheIds = trancheIds <> [trancheId]
          trancheCid <- create Tranche with trancheProvider = dealProvider; ..
          pure (dealCid, trancheCid)

template Tranche
  with
    operator : Party
    trancheProvider : Party
    issuer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    payingAgent : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
    issuerSettlementMode : SettlementMode
    bndSettlementMode : SettlementMode
  where
    signatory operator, trancheProvider, issuer
    observer settlementBank, bndBank

    key (operator, issuer, dealId, trancheId) : (Party, Party, Text, Text)
    maintainer key._1

    -- helper fuction to send swift message
    let
      createNewSettlementMessage: Text -> SwiftMessage -> SwiftMessageType -> Update (ContractId SwiftOutboundMessage)
      createNewSettlementMessage referenceId swiftMessage swiftMessageType =
        create SwiftOutboundMessage with provider = operator; consumer = operator; status = Pending; observers = fromList [bondRegistrar]; ..

      sendSwiftMessage : Party -> Party -> Decimal -> Decimal -> Id -> Text -> Date -> Date -> Date -> SettlementMode -> Update ()
      sendSwiftMessage seller buyer settledQty settledAmount settledCurrency settlementId dateOfTrade dateOfSettlement effDateOfSettlement settlementMode = do
        (_, sellerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, seller)
        (_, receiverSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, buyer)
        (_, bond) <- fetchByKey @Bond (fromList [bondRegistrar, issuer], deliveryId.label)
        let
          instrumentId = bond.isin <> "-" <> deliveryId.label
          buyerSafekeepingAcc = getAccount False receiverSettlementInfo buyer
          sellerSafekeepingAcc = getAccount False sellerSettlementInfo seller
        if settlementMode == Dvp then do
          let
            mt545 = createMT545Details instrumentId settledQty buyerSafekeepingAcc.provider sellerSafekeepingAcc.provider seller buyer
                    settledAmount settledCurrency
                    dateOfTrade dateOfSettlement effDateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"

            mt547 = createMT547Details instrumentId settledQty buyerSafekeepingAcc.provider sellerSafekeepingAcc.provider seller buyer
                    settledAmount settledCurrency
                    dateOfTrade dateOfSettlement effDateOfSettlement dateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"
          createNewSettlementMessage settlementId (MT545 mt545) MT545_t
          createNewSettlementMessage settlementId (MT547 mt547) MT547_t
        else do
          let
            mt544 = createMT544Details instrumentId settledQty buyerSafekeepingAcc.provider buyerSafekeepingAcc.provider seller buyer
                    dateOfTrade dateOfSettlement effDateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"

            mt546 = createMT546Details instrumentId settledQty buyerSafekeepingAcc.provider sellerSafekeepingAcc.provider seller buyer
                    dateOfTrade dateOfSettlement effDateOfSettlement dateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc sellerSafekeepingAcc "safekeepingPlace" "placeOfSettlement"
          createNewSettlementMessage settlementId (MT544 mt544) MT544_t
          createNewSettlementMessage settlementId (MT546 mt546) MT546_t
        pure ()

    controller operator can
      nonconsuming InstructIssuerSettlement : ContractId Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          let
            settledAmount = size * price
            totalAsset = Asset with id = deliveryId; quantity = size
            totalPrice = Asset with id = paymentId; quantity = settledAmount
            settlementId = deliveryId.label <> "-" <> partyToText issuer <> "-" <> partyToText settlementBank
          (_, issuerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, issuer)
          (_, settlementBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, settlementBank)

          let
            issuerSecuritiesAccount = getAccount False issuerSettlementInfo issuer
            settlementBankSecuritiesAccount = getAccount False settlementBankSettlementInfo settlementBank
          bondSis <- createInstructions False operator bondRegistrar bondRegistrar issuerSecuritiesAccount settlementBankSecuritiesAccount settlementId 0 totalAsset

          instructionIds <-
            if issuerSettlementMode == Dvp
            then do
              let
                issuerCashAccount = getAccount True issuerSettlementInfo issuer
                settlementBankCashAccount = getAccount True settlementBankSettlementInfo settlementBank
              cashSis <- createInstructions True operator bondRegistrar cashProvider settlementBankCashAccount issuerCashAccount settlementId (length bondSis) totalPrice
              map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
            else if issuerSettlementMode == Fop
            then do
              map (.instructionId) <$> mapA fetch bondSis
            else do
              fail "InstructIssuerSettlement cannot be used with issuerSettlementMode = Htlc"
          sendSwiftMessage issuer settlementBank size settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement issuerSettlementMode
          create Trade with operator; agent = bondRegistrar; deliverer = issuer; payer = settlementBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Instructed; settlementMode = issuerSettlementMode

      nonconsuming InstructIssuerSettlementHtlc : ContractId Htlc.Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
          hashlock : Text
          expiry : Time
        do
          let
            settledAmount = size * price
            totalAsset = Asset with id = deliveryId; quantity = size
            totalPrice = Asset with id = paymentId; quantity = settledAmount
            settlementId = deliveryId.label <> "-" <> partyToText settlementBank <> "-" <> partyToText bndBank
          (_, issuerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, issuer)
          (_, settlementBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, settlementBank)

          let
            issuerSecuritiesAccount = getAccount False issuerSettlementInfo issuer
            settlementBankSecuritiesAccount = getAccount False settlementBankSettlementInfo settlementBank
          bondSis <- createInstructionsHtlc False operator bondRegistrar issuer issuerSecuritiesAccount settlementBank settlementBankSecuritiesAccount settlementId 0 totalAsset hashlock expiry

          instructionIds <-
            if issuerSettlementMode == Htlc
            then do
              map (.instructionId) <$> mapA fetch bondSis
            else do
              fail "InstructIssuerSettlementHtlc can only be used with issuerSettlementMode = Htlc"
          create Htlc.Trade with operator; deliverer = issuer; delivererAgent = issuer; payer = settlementBank; payerAgent = settlementBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Locked; settlementMode = issuerSettlementMode; hashlock; expiry

      nonconsuming InstructBndSettlement : ContractId Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          let
            settledAmount = size * price
            totalAsset = Asset with id = deliveryId; quantity = size
            totalPrice = Asset with id = paymentId; quantity = settledAmount
            settlementId = deliveryId.label <> "-" <> partyToText settlementBank <> "-" <> partyToText bndBank
          (_, bndBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, bndBank)
          (_, settlementBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, settlementBank)
          instructionIds <-
            if bndSettlementMode == Dvp
            then do
              let
                bndBankCashAccount = getAccount True bndBankSettlementInfo bndBank
                settlementBankCashAccount = getAccount True settlementBankSettlementInfo settlementBank
                bndBankSecuritiesAccount = getAccount False bndBankSettlementInfo bndBank
                settlementBankSecuritiesAccount = getAccount False settlementBankSettlementInfo settlementBank
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementBankSecuritiesAccount bndBankSecuritiesAccount settlementId 0 totalAsset
              cashSis <- createInstructions True operator bondRegistrar cashProvider bndBankCashAccount settlementBankCashAccount settlementId (length bondSis) totalPrice
              map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
            else do
              let
                bndBankSecuritiesAccount = getAccount False bndBankSettlementInfo bndBank
                settlementBankSecuritiesAccount = getAccount False settlementBankSettlementInfo settlementBank
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementBankSecuritiesAccount bndBankSecuritiesAccount settlementId 0 totalAsset
              map (.instructionId) <$> mapA fetch bondSis
          sendSwiftMessage settlementBank bndBank size settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement bndSettlementMode
          create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Instructed; settlementMode = bndSettlementMode

      nonconsuming InstructBndSettlementHtlc : ContractId Htlc.Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
          hashlock : Text
          expiry : Time
        do
          let
            settledAmount = size * price
            totalAsset = Asset with id = deliveryId; quantity = size
            totalPrice = Asset with id = paymentId; quantity = settledAmount
            settlementId = deliveryId.label <> "-" <> partyToText issuer <> "-" <> partyToText settlementBank
          (_, bndBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, bndBank)
          (_, settlementBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, settlementBank)

          let
            bndBankSecuritiesAccount = getAccount False bndBankSettlementInfo bndBank
            settlementBankSecuritiesAccount = getAccount False settlementBankSettlementInfo settlementBank
          bondSis <- createInstructionsHtlc False operator bondRegistrar settlementBank settlementBankSecuritiesAccount bndBank bndBankSecuritiesAccount settlementId 0 totalAsset hashlock expiry

          instructionIds <-
            if bndSettlementMode == Htlc
            then do
              map (.instructionId) <$> mapA fetch bondSis
            else do
              fail "InstructIssuerSettlementHtlc can only be used with issuerSettlementMode = Htlc"
          create Htlc.Trade with operator; deliverer = settlementBank; delivererAgent = settlementBank; payer = bndBank; payerAgent = bndBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Locked; settlementMode = issuerSettlementMode; hashlock; expiry

      nonconsuming InstructInvestorSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          confirmations <- zip confirmationCids <$> mapA fetch confirmationCids
          let
            filtered = filter (\(_, c) -> c.asset.id == deliveryId) confirmations
            settleConfirmation (confCid, conf) = do
              let
                aggregate = conf.asset.quantity
                settledAmount = conf.price.quantity * conf.asset.quantity
                aggregatePrice = conf.price with quantity = settledAmount
                settlementId = deliveryId.label <> "-" <> partyToText bndBank <> "-" <> partyToText conf.investor
              (_, bndBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, bndBank)
              (_, investorSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, conf.investor)
              instructionIds <-
                if conf.settlementMode == Dvp
                then do
                  let
                    bndBankCashAccount = getAccount True bndBankSettlementInfo bndBank
                    investorCashAccount = getAccount True investorSettlementInfo conf.investor
                    bndBankSecuritiesAccount = getAccount False bndBankSettlementInfo bndBank
                    investorSecuritiesAccount = getAccount False investorSettlementInfo conf.investor
                  assertMsg "Total confirmed amount is larger than available quantity" $ aggregate <= size
                  bondSis <- createInstructions False operator bondRegistrar bondRegistrar bndBankSecuritiesAccount investorSecuritiesAccount settlementId 0 conf.asset
                  cashSis <- createInstructions True operator bondRegistrar cashProvider investorCashAccount bndBankCashAccount settlementId (length bondSis) aggregatePrice
                  map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
                else do
                  let
                    bndBankSecuritiesAccount = getAccount False bndBankSettlementInfo bndBank
                    investorSecuritiesAccount = getAccount False investorSettlementInfo conf.investor
                  assertMsg "Total confirmed amount is larger than available quantity" $ aggregate <= size
                  bondSis <- createInstructions False operator bondRegistrar bondRegistrar bndBankSecuritiesAccount investorSecuritiesAccount settlementId 0 conf.asset
                  map (.instructionId) <$> mapA fetch bondSis
              sendSwiftMessage settlementBank bndBank aggregate settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement conf.settlementMode
              exercise confCid Bidding.Delete
              create Trade with operator; agent = bondRegistrar; deliverer = bndBank; payer = conf.investor; settlementId; instructionIds; delivery = conf.asset; payment = aggregatePrice; status = Instructed; settlementMode = conf.settlementMode
          mapA settleConfirmation filtered

      nonconsuming InstructInvestorSettlementHtlc : [(Party, ContractId Htlc.Trade)]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
          hashlock : Text
          expiry : Time
        do
          confirmations <- zip confirmationCids <$> mapA fetch confirmationCids
          let
            filtered = filter (\(_, c) -> c.asset.id == deliveryId) confirmations
            settleConfirmation : (ContractId Bidding.Confirmation, Bidding.Confirmation) -> Update (Party, ContractId Htlc.Trade)
            settleConfirmation (confCid, conf) = do
              let
                aggregate = conf.asset.quantity
                settledAmount = conf.price.quantity * conf.asset.quantity
                aggregatePrice = conf.price with quantity = settledAmount
                settlementId = deliveryId.label <> "-" <> partyToText bndBank <> "-" <> partyToText conf.investor
              (_, bndBankSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, bndBank)
              (_, investorSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, conf.investor)
              let
                bndBankSecuritiesAccount = getAccount False bndBankSettlementInfo bndBank
                investorSecuritiesAccount = getAccount False investorSettlementInfo conf.investor
              assertMsg "Total confirmed amount is larger than available quantity" $ aggregate <= size
              bondSis <- createInstructionsHtlc False operator bondRegistrar bndBank bndBankSecuritiesAccount conf.investor investorSecuritiesAccount settlementId 0 conf.asset hashlock expiry
              instructionIds <-
                if conf.settlementMode == Htlc
                then do
                  map (.instructionId) <$> mapA fetch bondSis
                else do
                  fail "InstructIssuerSettlementHtlc can only be used with issuerSettlementMode = Htlc"
              exercise confCid Bidding.Delete
              tradeCid <- create Htlc.Trade with operator; deliverer = bndBank; delivererAgent = bndBank; payer = conf.investor; payerAgent = conf.investor; settlementId; instructionIds; delivery = conf.asset; payment = aggregatePrice; status = Locked; settlementMode = issuerSettlementMode; hashlock; expiry              
              pure (conf.investor, tradeCid)
          mapA settleConfirmation filtered