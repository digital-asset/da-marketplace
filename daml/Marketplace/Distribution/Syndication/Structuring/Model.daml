module Marketplace.Distribution.Syndication.Structuring.Model where

import DA.Finance.Types (Id, Asset(..))
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Settlement.Hierarchical (createInstructions, Trade(..), Status(..))

template CreateDealRequest
  with
    operator : Party
    provider : Party
    customer : Party
    dealId : Text
  where
    signatory operator, provider, customer

template AddTrancheRequest
  with
    operator : Party
    provider : Party
    customer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
  where
    signatory operator, provider, customer

template Deal
  with
    operator : Party
    dealProvider : Party
    issuer : Party
    dealId : Text
    trancheIds : [Text]
  where
    signatory operator, dealProvider, issuer

    key (operator, issuer, dealId) : (Party, Party, Text)
    maintainer key._1

    controller issuer can
      CreateTranche : (ContractId Deal, ContractId Tranche)
        with
          trancheId : Text
          deliveryId : Id
          paymentId : Id
          size : Decimal
          settlementBank : Party
          bndBank : Party
          cashProvider : Party
          bondRegistrar : Party
        do
          dealCid <- create this with trancheIds = trancheIds <> [trancheId]
          trancheCid <- create Tranche with trancheProvider = dealProvider; ..
          pure (dealCid, trancheCid)

template Tranche
  with
    operator : Party
    trancheProvider : Party
    issuer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
  where
    signatory operator, trancheProvider, issuer
    observer settlementBank, bndBank

    key (operator, issuer, dealId, trancheId) : (Party, Party, Text, Text)
    maintainer key._1

    controller operator can
      nonconsuming InstructIssuerSettlement : ContractId Trade
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            filtered = filter (\c -> c.asset.id == deliveryId) confirmations
            quantities = map (.asset.quantity) filtered
            aggregate = sum quantities
            aggregateAsset = Asset with id = deliveryId; quantity = aggregate
            aggregatePrice = Asset with id = paymentId; quantity = aggregate * price
            settlementId = deliveryId.label <> "-" <> partyToText issuer <> "-" <> partyToText settlementBank
          assertMsg "Total confirmed amount is larger than available quantity" $ aggregate <= size
          bondSis <- createInstructions False operator bondRegistrar bondRegistrar issuer settlementBank settlementId 0 aggregateAsset
          cashSis <- createInstructions True operator bondRegistrar cashProvider settlementBank issuer settlementId (length bondSis) aggregatePrice
          instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
          create Trade with operator; agent = bondRegistrar; deliverer = issuer; payer = settlementBank; settlementId; instructionIds; delivery = aggregateAsset; payment = aggregatePrice; status = Instructed

      nonconsuming InstructBndSettlement : ContractId Trade
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            filtered = filter (\c -> c.asset.id == deliveryId) confirmations
            quantities = map (.asset.quantity) filtered
            aggregate = sum quantities
            aggregateAsset = Asset with id = deliveryId; quantity = aggregate
            aggregatePrice = Asset with id = paymentId; quantity = aggregate * price
            settlementId = deliveryId.label <> "-" <> partyToText settlementBank <> "-" <> partyToText bndBank
          assertMsg "Total confirmed amount is larger than available quantity" $ aggregate <= size
          bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementBank bndBank settlementId 0 aggregateAsset
          cashSis <- createInstructions True operator bondRegistrar cashProvider bndBank settlementBank settlementId (length bondSis) aggregatePrice
          instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
          create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = aggregateAsset; payment = aggregatePrice; status = Instructed

      nonconsuming InstructInvestorSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
        do
          confirmations <- mapA fetch confirmationCids
          let
            filtered = filter (\c -> c.asset.id == deliveryId) confirmations
            settleConfirmation conf = do
              let
                aggregatePrice = conf.price with quantity = conf.price.quantity * conf.asset.quantity
                settlementId = deliveryId.label <> "-" <> partyToText bndBank <> "-" <> partyToText conf.investor
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar bndBank conf.investor settlementId 0 conf.asset
              cashSis <- createInstructions True operator bondRegistrar cashProvider conf.investor bndBank settlementId (length bondSis) aggregatePrice
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = conf.asset; payment = aggregatePrice; status = Instructed
          mapA settleConfirmation filtered
