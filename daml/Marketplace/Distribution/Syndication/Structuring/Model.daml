module Marketplace.Distribution.Syndication.Structuring.Model where

import DA.Finance.Types (Id, Asset(..))
import DA.Optional (fromSomeNote)
import DA.Set (fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Settlement.Hierarchical (createInstructions, Trade(..), Status(..))
import Marketplace.Issuance.Instrument.Model(Bond(..))
import SwiftMessage.Model.MT545
import SwiftMessage.Model.MT547
import SwiftMessage.Util
import SwiftMessage.Message (SwiftMessage(MT547), SwiftMessage(MT545), SwiftMessageType(..), SwiftOutboundMessage(..))

template CreateDealRequest
  with
    operator : Party
    provider : Party
    customer : Party
    dealId : Text
  where
    signatory operator, provider, customer

template AddTrancheRequest
  with
    operator : Party
    provider : Party
    customer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    payingAgent : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
  where
    signatory operator, provider, customer

template Deal
  with
    operator : Party
    dealProvider : Party
    issuer : Party
    dealId : Text
    trancheIds : [Text]
  where
    signatory operator, dealProvider, issuer

    key (operator, issuer, dealId) : (Party, Party, Text)
    maintainer key._1

    controller issuer can
      CreateTranche : (ContractId Deal, ContractId Tranche)
        with
          trancheId : Text
          deliveryId : Id
          paymentId : Id
          size : Decimal
          settlementBank : Party
          bndBank : Party
          cashProvider : Party
          bondRegistrar : Party
          payingAgent : Party
        do
          dealCid <- create this with trancheIds = trancheIds <> [trancheId]
          trancheCid <- create Tranche with trancheProvider = dealProvider; ..
          pure (dealCid, trancheCid)

template Tranche
  with
    operator : Party
    trancheProvider : Party
    issuer : Party
    settlementBank : Party
    bndBank : Party
    cashProvider : Party
    bondRegistrar : Party
    payingAgent : Party
    dealId : Text
    trancheId : Text
    deliveryId : Id
    paymentId : Id
    size : Decimal
  where
    signatory operator, trancheProvider, issuer
    observer settlementBank, bndBank

    key (operator, issuer, dealId, trancheId) : (Party, Party, Text, Text)
    maintainer key._1

    -- helper fuction to send swift message
    let
      sendSwiftMessage : Party -> Party -> Decimal -> Decimal -> Id -> Text -> Date -> Date -> Date -> Update (ContractId SwiftOutboundMessage)
      sendSwiftMessage seller buyer settledQty settledAmount settledCurrency settlementId dateOfTrade dateOfSettlement effDateOfSettlement = do
        (_, sellerAccountInfo) <- fetchByKey @Custody.SettlementInfo (operator, seller)
        (_, receiverAccountInfo) <- fetchByKey @Custody.SettlementInfo (operator, buyer)
        (_, bond) <- fetchByKey @Bond (fromList [bondRegistrar, issuer], deliveryId.label)
        let
          getSecurityAcc accInfo = fromSomeNote "current party has not security account" accInfo.securitiesAccount
          instrumentId = bond.isin <> "-" <> deliveryId.label
          buyerSafekeepingAcc = getSecurityAcc receiverAccountInfo
          sellerSafkeepingAcc = getSecurityAcc sellerAccountInfo
          mt545 = createMT545Details instrumentId settledQty buyerSafekeepingAcc.provider seller settledAmount settledCurrency
                    dateOfTrade dateOfSettlement effDateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc (getSecurityAcc sellerAccountInfo) "safekeepingPlace" "placeOfSettlement"

          mt547 = createMT547Details instrumentId settledQty sellerSafkeepingAcc.provider seller settledAmount settledCurrency
                    dateOfTrade dateOfSettlement effDateOfSettlement dateOfSettlement
                    settlementId settlementId buyerSafekeepingAcc (getSecurityAcc sellerAccountInfo) "safekeepingPlace" "placeOfSettlement"
        create SwiftOutboundMessage with referenceId = settlementId; provider = operator ; consumer = operator; swiftMessage=MT545 (mt545); swiftMessageType=MT545_t; status=Pending; observers= fromList [bondRegistrar]
        create SwiftOutboundMessage with referenceId = settlementId; provider = operator ; consumer = operator; swiftMessage=MT547 (mt547); swiftMessageType=MT547_t; status=Pending; observers=fromList [bondRegistrar]

    controller operator can
      nonconsuming InstructIssuerSettlement : ContractId Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          let
            settledAmount = size * price
            totalAsset = Asset with id = deliveryId; quantity = size
            totalPrice = Asset with id = paymentId; quantity = settledAmount
            settlementId = deliveryId.label <> "-" <> partyToText issuer <> "-" <> partyToText settlementBank
          bondSis <- createInstructions False operator bondRegistrar bondRegistrar issuer settlementBank settlementId 0 totalAsset
          cashSis <- createInstructions True operator bondRegistrar cashProvider settlementBank issuer settlementId (length bondSis) totalPrice
          instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
          sendSwiftMessage issuer settlementBank size settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement
          create Trade with operator; agent = bondRegistrar; deliverer = issuer; payer = settlementBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Instructed

      nonconsuming InstructBndSettlement : ContractId Trade
        with
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          let
            settledAmount = size * price
            totalAsset = Asset with id = deliveryId; quantity = size
            totalPrice = Asset with id = paymentId; quantity = settledAmount
            settlementId = deliveryId.label <> "-" <> partyToText settlementBank <> "-" <> partyToText bndBank
          bondSis <- createInstructions False operator bondRegistrar bondRegistrar settlementBank bndBank settlementId 0 totalAsset
          cashSis <- createInstructions True operator bondRegistrar cashProvider bndBank settlementBank settlementId (length bondSis) totalPrice
          instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
          sendSwiftMessage settlementBank bndBank size settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement
          create Trade with operator; agent = bondRegistrar; deliverer = settlementBank; payer = bndBank; settlementId; instructionIds; delivery = totalAsset; payment = totalPrice; status = Instructed

      nonconsuming InstructInvestorSettlement : [ContractId Trade]
        with
          confirmationCids : [ContractId Bidding.Confirmation]
          price : Decimal
          dateOfTrade : Date
          dateOfSettlement : Date
        do
          confirmations <- zip confirmationCids <$> mapA fetch confirmationCids
          let
            filtered = filter (\(_, c) -> c.asset.id == deliveryId) confirmations
            settleConfirmation (confCid, conf) = do
              let
                aggregate = conf.asset.quantity
                settledAmount = conf.price.quantity * conf.asset.quantity
                aggregatePrice = conf.price with quantity = settledAmount
                settlementId = deliveryId.label <> "-" <> partyToText bndBank <> "-" <> partyToText conf.investor
              assertMsg "Total confirmed amount is larger than available quantity" $ aggregate <= size
              bondSis <- createInstructions False operator bondRegistrar bondRegistrar bndBank conf.investor settlementId 0 conf.asset
              cashSis <- createInstructions True operator bondRegistrar cashProvider conf.investor bndBank settlementId (length bondSis) aggregatePrice
              instructionIds <- map (.instructionId) <$> mapA fetch (bondSis <> cashSis)
              sendSwiftMessage settlementBank bndBank aggregate settledAmount paymentId settlementId dateOfTrade dateOfSettlement dateOfSettlement
              exercise confCid Bidding.Delete
              create Trade with operator; agent = bondRegistrar; deliverer = bndBank; payer = conf.investor; settlementId; instructionIds; delivery = conf.asset; payment = aggregatePrice; status = Instructed
          mapA settleConfirmation filtered
