module Marketplace.Distribution.Bidding.Request where

import DA.List (head, last)
import DA.Finance.Asset (AssetDeposit, AssetDeposit_Split(..))
import DA.Finance.Types (Account)
import DA.Finance.Utils (fetchAndArchive)
import Marketplace.Settlement qualified as Settlement
import Marketplace.Settlement (SettlementInstruction(..))
import Marketplace.Distribution.Auction.Model qualified as Auction
import Marketplace.Distribution.Bidding.Model qualified as Bidding
import Marketplace.Trading.AllocationAccountRule qualified as Allocation
import Marketplace.Trading.AllocationAccountRule (AllocationAccountRule(..))

type T = Request

template Request
  with
    operator : Party
    provider : Party
    customer : Party
    auctionId : Text
  where
    signatory operator, provider, customer

    key (customer, auctionId) : (Party, Text)
    maintainer key._1

    controller customer can
      nonconsuming SubmitBid : ContractId Bidding.Bid
        with
          details : Bidding.Details
          tradingAccount : Account
          allocationAccount : Account
          depositCid : ContractId AssetDeposit
          publishBid : Bool
        do
          -- TODO: Check for parallism of this choice
          deposit <- fetch depositCid
          (_, auction) <- fetchByKey @Auction.AuctionObserver (customer, auctionId)
          assertMsg ("Deposit does not cover submitted bid") (deposit.asset.quantity >= details.price * details.quantity)
          assertMsg ("Deposited asset does not match the auction's quoted asset") (deposit.asset.id.label == auction.quotedAssetId.label)

          depositCid <- exerciseByKey @AllocationAccountRule allocationAccount.id Allocation.Deposit with ..
          create Bidding.Bid with status = Bidding.Pending; publish = publishBid; assetId = auction.asset.id; issuer = auction.customer; ..

    controller provider can
      nonconsuming ProcessAllocation : (ContractId Bidding.T, ContractId AssetDeposit)
        with
          bidCid : ContractId Bidding.T
          quantity : Decimal
          amount : Decimal
          price : Decimal
        do
          -- Fetch Bid -> Extract their deposit -> Split and return unused allocation (if necessary) to the investor -> Update Bid Status
          bid <- fetch bidCid
          bidDeposit <- fetch bid.depositCid
          bidDepositCid <- if bidDeposit.asset.quantity > amount
                              then do
                                splitDepositCids <- exercise bid.depositCid AssetDeposit_Split with quantities = [amount]
                                exerciseByKey @AllocationAccountRule bid.allocationAccount.id Allocation.Withdraw with transferTo = bid.tradingAccount; depositCid = last splitDepositCids
                                pure $ head splitDepositCids
                              else pure bid.depositCid

          let newStatus = if bid.details.quantity == quantity
                            then Bidding.FullAllocation with ..
                            else Bidding.PartialAllocation with ..
          bidCid <- exercise self UpdateBidStatus with ..

          pure (bidCid, bidDepositCid)

      nonconsuming UpdateBidStatus : ContractId Bidding.T
        with
          bidCid : ContractId Bidding.T
          newStatus : Bidding.Status
        do
          bid <- fetchAndArchive bidCid

          create bid with status = newStatus

    nonconsuming choice GenerateSettlementInstrution : ContractId Settlement.SettlementInstruction
      with
        delivery : Settlement.SettlementDetails
        payment : Settlement.SettlementDetails
        issuer : Party
      controller issuer
      do
        (_, auction) <- fetchByKey @Auction.T (provider, auctionId)
        assertMsg ("Unexpected Issuer " <> show issuer <> "for Auction") (auction.customer == issuer)

        create SettlementInstruction with buyer = customer; seller = issuer; ..
