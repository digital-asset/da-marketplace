{-# LANGUAGE MultiWayIf #-}

module Marketplace.Distribution.Auction where

import DA.Action (foldlA)
import DA.Next.Set (fromList, empty)
import DA.List (sortOn, mapAccumL)
import DA.Foldable (forA_)
import DA.Finance.Types (Asset, Account(..), Id)
import DA.Finance.Asset (AssetDeposit(..), AssetDeposit_Split(..))
import DA.Finance.Asset.Settlement (AssetSettlementRule(..))
import DA.Finance.Utils (fetchAndArchive)
import Marketplace.Trading.AllocationAccountRule (AllocationAccountRule(..), Withdraw(..), Deposit(..))
import Marketplace.Distribution.Bid qualified as Bid
import Marketplace.Distribution.Bid (Bid(..))
import Marketplace.Settlement qualified as Settlement

type T = Service

data Allocation = Allocation with
    bid : Bid
    quantity : Decimal
  deriving (Eq, Show)

-- | A map/accumulator function for processing a submitted bid.
-- Accepts the remaining quantity and price as an accululator along the current Bid as input
-- Output is the updated accululator (if applicable) along with the Bid mapped to an Allocation (depending on the accumulator and bid information)
dutchAuction : (Decimal, Decimal) -> Bid -> ((Decimal, Decimal), Allocation)
dutchAuction acc@(0.0, _)   bid@Bid{..} = (acc, Allocation with quantity = 0.0; ..)
dutchAuction (remaining, _) bid@Bid{..} =
  let
    quantity = details.quantity
    bidPrice = details.price
  in
    if remaining >= quantity
      then ((remaining - quantity, bidPrice), Allocation with ..)
      else ((0.0, bidPrice), Allocation with quantity = remaining; ..)

-- | Takes a list and splits it based off a predicate. Values which match the predicate go in the right list of the tuple
splitList : (a -> Bool) -> [a] -> ([a], [a])
splitList p xs = foldr (\x (y,z) -> if p x then (y, x :: z) else (x :: y, z)) ([],[]) xs

-- | Returns a bidder's allocation to their trading account
withdrawAllocation : Bid -> Update (ContractId AssetDeposit)
withdrawAllocation bid@Bid{..} = do
    exerciseByKey @AllocationAccountRule allocationAccount.id Withdraw with transferTo = tradingAccount; ..

-- | Updates a bid's status
updateBidStatus : Bid.Status -> Bid -> Update (ContractId Bid)
updateBidStatus newStatus bid@Bid{..} = do
    -- exerciseByKey @Bid (assetId, customer) Bid.UpdateStatus with ..
    exerciseByKey @Bid.T (bid.assetId, bid.customer) Bid.UpdateStatus with ..

data SettleAllocation = SettleAllocation with
    operator : Party
    provider : Party
    allocation : Allocation
    price : Decimal
    issuer : Party
    issuerReceivableAccount : Account
  deriving (Eq, Show)

generateSettlementInstruction : (Optional (ContractId AssetDeposit), [ContractId Settlement.SettlementInstruction]) -> SettleAllocation -> Update (Optional (ContractId AssetDeposit), [ContractId Settlement.SettlementInstruction])
generateSettlementInstruction (None, _) _ = error "Auction:generateSettlementInstruction - Issuers AssetDeposit has no remaining units to allocate"
generateSettlementInstruction (Some issuerDepositCid, settlementInstructionCids) SettleAllocation{..} = do
    let
      allocatedQuantity = allocation.quantity
      bid = allocation.bid
      allocatedAmount = allocatedQuantity * price
      newStatus = if bid.details.quantity == allocatedQuantity
                    then Bid.FullAllocation with ..
                    else Bid.PartialAllocation with quantity = allocatedQuantity; ..

    -- | Process bid side
    (_, bidDepositCid) <- exerciseByKey @Bid.T (bid.assetId, bid.customer) Bid.ProcessAllocation with quantity = allocatedQuantity; amount = allocatedAmount; ..
    let
      buyer = bid.customer
      payment = Settlement.SettlementDetails with senderAccount = bid.allocationAccount; depositCid = bidDepositCid; receiverAccount = issuerReceivableAccount

    -- | Process issuer side
    -- 1/ Extract their deposit
    -- 2/ Split allocation quantity from this deposit, get the deposit matching the allocation. Can only result in either :
        -- two asset deposits - One with the allocation, one with the remaining
        -- one asset deposit - Should only occur on processing the last bid when the auction is fully allocated
    -- 3/ Create the settlement details for delivery of the asset to the buyer
    issuerDeposit <- fetch issuerDepositCid
    issuerDepositCids <- exercise issuerDepositCid AssetDeposit_Split with quantities = [allocatedQuantity]
    let
      seller = issuer
      (allocatedDepositCid, remainingDepositCidOpt) = case issuerDepositCids of
        (x :: [])      -> (x, None)
        (x :: y :: []) -> (x, Some y)
        _ -> error "Auction:generateSettlementInstruction - Unexpected AssetDeposit split"
      delivery = Settlement.SettlementDetails with senderAccount = issuerDeposit.account; depositCid = allocatedDepositCid; receiverAccount = bid.tradingAccount

    -- | Create the Settlement Instruction to deliver the asset against the payment atomically
    settlementInstructionCid <- exerciseByKey @Bid.T (bid.assetId, bid.customer) Bid.GenerateSettlementInstrution with ..

    pure (remainingDepositCidOpt, settlementInstructionCid :: settlementInstructionCids)

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    nonconsuming choice OfferBidder : ContractId Bid.Offer
      with
        submitter : Party
        auctionCid : ContractId Auction
        bidder : Party
      controller submitter
      do
        assertMsg ("Unauthorised Submitter - " <> show submitter) (submitter `elem` [provider, customer])
        Auction{..} <- fetch auctionCid
        create Bid.Offer with issuer = customer; customer = bidder; ..

    nonconsuming choice RemoveBidderOffer : ()
      with
        submitter : Party
        bidOfferCid : ContractId Bid.Offer
      controller submitter
      do
        assertMsg ("Unauthorised Submitter - " <> show submitter) (submitter `elem` [provider, customer])
        archive bidOfferCid

    nonconsuming choice RemoveBidder : ()
      with
        submitter : Party
        bidServiceCid : ContractId Bid
      controller submitter
      do
        assertMsg ("Unauthorised Submitter - " <> show submitter) (submitter `elem` [provider, customer])
        archive bidServiceCid

    nonconsuming choice AddLeadBidder : ContractId LeadBidder
      with
        submitter : Party
        leadBidCid : ContractId Bid
      controller submitter
      do
        assertMsg ("Unauthorised Submitter - " <> show submitter) (submitter `elem` [provider, customer])
        bid <- fetch leadBidCid
        (_, auction) <- fetchByKey @Auction (bid.provider, bid.assetId)
        assertMsg ("Unexpected lead bidder - " <> show bid.customer) (bid.customer == auction.leadBidder)

        let
          allocationPercentage = roundBankers 2 $ bid.details.quantity / auction.asset.quantity
          leadBidder = bid.customer
        create LeadBidder with ..

    controller customer can
      nonconsuming RequestCreateAuction : ContractId CreateAuctionRequest
        with
          leadBidder : Party
          asset : Asset
          quotedAssetId : Id
          assetDepositCid : ContractId AssetDeposit
          allocationAccount : Account
          receivableAccount : Account
          floorPrice : Decimal
        do
          create CreateAuctionRequest with ..

      nonconsuming CancelAuctionRequest : ()
        with
          createAuctionRequestCid : ContractId CreateAuctionRequest
        do
          archive createAuctionRequestCid

    controller provider can
      nonconsuming CreateAuction : ContractId Auction
        with
          createAuctionRequestCid : ContractId CreateAuctionRequest
        do
          CreateAuctionRequest{..} <- fetchAndArchive createAuctionRequestCid

          -- Deposit the asset into the allocation account so they cannot be transferred/withdrawn without the signatore of the Auctioneer
          depositCid <- exerciseByKey @AllocationAccountRule allocationAccount.id Deposit with depositCid = assetDepositCid; ..
          create Auction with status = Open; ..

      nonconsuming RejectAuction : ()
        with
          createAuctionRequestCid : ContractId CreateAuctionRequest
        do
          archive createAuctionRequestCid

      nonconsuming ProcessAuction : (ContractId Auction, [ContractId Settlement.SettlementInstruction])
        with
          auctionCid : ContractId Auction
          bidCids : [ContractId Bid]
        do
          auction@Auction{..} <- fetch auctionCid
          assertMsg "Auction already successfully processed" (status `elem` [Open, NoValidBids])
          bids <- forA bidCids fetch

          -- Split bids on those above / below the floor price -> Sort valid bids descendingly -> Execute Auction -> Split auction result on allocated / unallocated (ie, zero allocation)
          let
            (validBids, invalidBids) = splitList (\bid -> bid.details.price < floorPrice) bids
            sortedBids = sortOn (\bid -> Down bid.details) validBids
            ((remaining, finalPrice), allocations) = mapAccumL dutchAuction (asset.quantity, 0.0) sortedBids
            (allocatedBids, unallocatedBids) = splitList (\allocation -> allocation.quantity == 0.0) allocations

          -- Return assets of all invalid and unallocated bids. Also update their bid status accordingly
          forA_ invalidBids $ withdrawAllocation *> updateBidStatus Bid.Invalid
          forA_ ((.bid) `map` unallocatedBids) $ withdrawAllocation *> updateBidStatus Bid.NoAllocation

          -- Generate Settlement instructions for allocated bids
          let settleAllocations = (\allocation -> SettleAllocation with price = finalPrice; issuer = customer; issuerReceivableAccount = receivableAccount; ..) <$> allocatedBids
          (_, siCids) <- foldlA generateSettlementInstruction (Some depositCid, []) settleAllocations

          -- Update Auction contract with the outcome of the auction processing
          let newStatus = if
                | remaining == asset.quantity -> NoValidBids
                | remaining > 0.0             -> ParticallyAllocated with ..
                | otherwise                   -> FullyAllocated with ..
          auctionCid <- archive auctionCid *> create auction with status = newStatus

          pure (auctionCid, siCids)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        do
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    customer : Party
    provider : Party
  where
    signatory operator, customer

    controller provider can
      Approve : ContractId Service
        do
          create Service with ..

      Reject : ()
        do
          return ()

template CreateAuctionRequest
  with
    operator : Party
    provider : Party
    customer : Party
    leadBidder : Party
    asset : Asset
    assetDepositCid : ContractId AssetDeposit
    quotedAssetId : Id
    allocationAccount : Account
    receivableAccount : Account
    floorPrice : Decimal
  where
    signatory operator, provider, customer

template LeadBidder
  with
    operator : Party
    provider : Party
    customer : Party
    leadBidder : Party
    allocationPercentage : Decimal
  where
    signatory operator, provider, customer --, leadBidder --> Should the leadBidder be a signatory ? Cannot in this form due to missing authorisation :(

data Status
    = Open
    | ParticallyAllocated with
        finalPrice : Decimal
        remaining : Decimal
    | FullyAllocated with
        finalPrice : Decimal
    | NoValidBids
  deriving (Eq, Show)

template Auction
  with
    operator : Party
    provider : Party
    customer : Party
    leadBidder : Party
    asset : Asset
    quotedAssetId : Id
    depositCid : ContractId AssetDeposit
    receivableAccount : Account
    floorPrice : Decimal
    status : Status
  where
    signatory operator, provider, customer
    ensure asset.quantity > 0.0

    key (provider, asset.id) : (Party, Id)
    maintainer key._1
