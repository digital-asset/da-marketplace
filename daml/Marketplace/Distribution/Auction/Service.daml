{-# LANGUAGE MultiWayIf #-}

module Marketplace.Distribution.Auction.Service where

import DA.Action (foldlA)
import DA.Foldable (forA_)
import DA.List (sortOn, mapAccumL)
import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Types (Account, Asset, Id)
import DA.Finance.Utils (fetchAndArchive)
import Marketplace.Settlement qualified as Settlement
import Marketplace.Distribution.Auction.Model qualified as Auction
import Marketplace.Distribution.Auction.Model (Auction(..))
import Marketplace.Distribution.Auction.Utils (dutchAuction, splitList, withdrawAllocation, updateBidStatus, generateSettlementInstruction)
import Marketplace.Distribution.Bid.Service qualified as Bid
import Marketplace.Distribution.Bid.Model qualified as Bid
import Marketplace.Trading.AllocationAccountRule qualified as Allocation
import Marketplace.Trading.AllocationAccountRule (AllocationAccountRule(..))

type S = Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    nonconsuming choice OfferBidder : ContractId Bid.Offer
      with
        submitter : Party
        auctionCid : ContractId Auction.T
        bidder : Party
      controller submitter
      do
        assertMsg ("Unauthorised Submitter - " <> show submitter) (submitter `elem` [provider, customer])
        Auction{..} <- fetch auctionCid
        create Bid.Offer with issuer = customer; customer = bidder; ..

    nonconsuming choice RemoveBidderOffer : ()
      with
        submitter : Party
        bidOfferCid : ContractId Bid.Offer
      controller submitter
      do
        assertMsg ("Unauthorised Submitter - " <> show submitter) (submitter `elem` [provider, customer])
        archive bidOfferCid

    nonconsuming choice RemoveBidder : ()
      with
        submitter : Party
        bidServiceCid : ContractId Bid.S
      controller submitter
      do
        assertMsg ("Unauthorised Submitter - " <> show submitter) (submitter `elem` [provider, customer])
        archive bidServiceCid

    nonconsuming choice AddLeadBidder : ContractId LeadBidder
      with
        submitter : Party
        leadBidCid : ContractId Bid.T
      controller submitter
      do
        assertMsg ("Unauthorised Submitter - " <> show submitter) (submitter `elem` [provider, customer])
        bid <- fetch leadBidCid
        (_, auction) <- fetchByKey @Auction (bid.provider, bid.assetId)
        assertMsg ("Unexpected lead bidder - " <> show bid.customer) (bid.customer == auction.leadBidder)

        let
          allocationPercentage = roundBankers 2 $ bid.details.quantity / auction.asset.quantity
          leadBidder = bid.customer
        create LeadBidder with ..

    controller customer can
      nonconsuming RequestCreateAuction : ContractId CreateAuctionRequest
        with
          leadBidder : Party
          asset : Asset
          quotedAssetId : Id
          assetDepositCid : ContractId AssetDeposit
          allocationAccount : Account
          receivableAccount : Account
          floorPrice : Decimal
        do
          create CreateAuctionRequest with ..

      nonconsuming CancelAuctionRequest : ()
        with
          createAuctionRequestCid : ContractId CreateAuctionRequest
        do
          archive createAuctionRequestCid

    controller provider can
      nonconsuming CreateAuction : ContractId Auction.T
        with
          createAuctionRequestCid : ContractId CreateAuctionRequest
        do
          CreateAuctionRequest{..} <- fetchAndArchive createAuctionRequestCid

          -- Deposit the asset into the allocation account so they cannot be transferred/withdrawn without the signatore of the Auctioneer
          depositCid <- exerciseByKey @AllocationAccountRule allocationAccount.id Allocation.Deposit with depositCid = assetDepositCid; ..
          create Auction with status = Auction.Open; ..

      nonconsuming RejectAuction : ()
        with
          createAuctionRequestCid : ContractId CreateAuctionRequest
        do
          archive createAuctionRequestCid

      nonconsuming ProcessAuction : (ContractId Auction.T, [ContractId Settlement.SettlementInstruction])
        with
          auctionCid : ContractId Auction.T
          bidCids : [ContractId Bid.T]
        do
          auction@Auction{..} <- fetch auctionCid
          assertMsg "Auction already successfully processed" (status `elem` [Auction.Open, Auction.NoValidBids])
          bids <- forA bidCids fetch

          -- Split bids on those above / below the floor price -> Sort valid bids descendingly -> Execute Auction -> Split auction result on allocated / unallocated (ie, zero allocation)
          let
            (validBids, invalidBids) = splitList (\bid -> bid.details.price < floorPrice) bids
            sortedBids = sortOn (\bid -> Down bid.details) validBids
            ((remaining, finalPrice), allocations) = mapAccumL dutchAuction (asset.quantity, 0.0) sortedBids
            (allocatedBids, unallocatedBids) = splitList (\allocation -> allocation.quantity == 0.0) allocations

          -- Return assets of all invalid and unallocated bids. Also update their bid status accordingly
          forA_ invalidBids $ withdrawAllocation *> updateBidStatus Bid.Invalid
          forA_ ((.bid) `map` unallocatedBids) $ withdrawAllocation *> updateBidStatus Bid.NoAllocation

          -- Generate Settlement instructions for allocated bids
          let settleAllocations = (\allocation -> Auction.SettleAllocation with price = finalPrice; issuer = customer; issuerReceivableAccount = receivableAccount; ..) <$> allocatedBids
          (_, siCids) <- foldlA generateSettlementInstruction (Some depositCid, []) settleAllocations

          -- Update Auction contract with the outcome of the auction processing
          let newStatus = if
                | remaining == asset.quantity -> Auction.NoValidBids
                | remaining > 0.0             -> Auction.ParticallyAllocated with ..
                | otherwise                   -> Auction.FullyAllocated with ..
          auctionCid <- archive auctionCid *> create auction with status = newStatus

          pure (auctionCid, siCids)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        do
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    customer : Party
    provider : Party
  where
    signatory operator, customer

    controller provider can
      Approve : ContractId Service
        do
          create Service with ..

      Reject : ()
        do
          return ()

template CreateAuctionRequest
  with
    operator : Party
    provider : Party
    customer : Party
    leadBidder : Party
    asset : Asset
    assetDepositCid : ContractId AssetDeposit
    quotedAssetId : Id
    allocationAccount : Account
    receivableAccount : Account
    floorPrice : Decimal
  where
    signatory operator, provider, customer

template LeadBidder
  with
    operator : Party
    provider : Party
    customer : Party
    leadBidder : Party
    allocationPercentage : Decimal
  where
    signatory operator, provider, customer