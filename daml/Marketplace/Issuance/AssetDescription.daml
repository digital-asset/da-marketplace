module Marketplace.Issuance.AssetDescription where
-- Consider merging into DA.Finance.Types.Asset

import DA.Finance.Types (Account, Id)
import DA.Set (Set)
import DA.Map (Map, size)
import DA.Map qualified as Map
import ContingentClaims.Claim qualified as C
import ContingentClaims.Claim.Serializable (Claim(..), Inequality(..))
import ContingentClaims.Observation (Observation(..))
import ContingentClaims.Observation qualified as O

type T = AssetDescription
type Claims = Claim Date Decimal Id
type Version = Int

deriving instance Ord x => Ord (Observation Date x)
deriving instance Ord (Inequality Date Decimal)
deriving instance Ord (Claim Date Decimal Id)

newtype CFI = CFI Text deriving (Show, Eq)

equity : CFI
equity = CFI "EXXXXX"

currency : CFI
currency = CFI "TCXXXX"

future : CFI
future = CFI "FXXXXX"

forward : CFI
forward = CFI "JXXXXX"

bond : CFI
bond = CFI "DBXXXX"

europeanCall : CFI
europeanCall = CFI "OCEXXX"

putWarrant : CFI
putWarrant = CFI "RWXXPX"

convertibleShare : CFI
convertibleShare = CFI "ECXXXX"

unknown : CFI
unknown = CFI "XXXXXX"

template AssetDescription
  with
    assetId: Id
    -- ^ This is the master record for the asset, and has embedded it's unique identifier
    description: Text
    -- ^ Short description of the asset, mainly for display purposes
    cfi: CFI
    -- ^ Type of asset
    issuer: Party
    -- ^ The counterparty for any @claims@
    claims: Claims
    -- ^ Rights and obligations of the holder (and issuer)
    safekeepingAccount: Account
    -- ^ Source account used for issuing the security and any subsequent corporate actions, e.g. paying out a coupon.
    -- terms: Text
    -- ^ Any further contract terms not captured in @claims@; typically a URI.
    -- authorized: Decimal
    -- ^ Number of shares/contracts authorized for issuance
    -- issued: Decimal
    -- ^ Number of shares/contracts already issued for trading
    -- issuePrice: (Decimal, Asset)
    -- ^ The price & currency of the *initial* offer.
    observers : Set Party
  where
    signatory assetId.signatories <> safekeepingAccount.id.signatories
    observer observers

    key assetId : Id
    maintainer key.signatories

    nonconsuming choice GetMaturity : Date
      with
        party : Party
      controller party
      do
        let cs = C.deserialize claims
        case C.deserialize claims of
          (C.When (O.DateEqu (O.DateIdentity, O.DateConst t)) _) -> return t
          _ -> error "Product does not have a maturity date"


-- Used to do a reverse lookup of the version # given the claims (passed-in from the API)
template Index
  with
    assetLabel: Text
    descriptionSignatories: Set Party
    versions: Map Claims Version
  where
    signatory descriptionSignatories
    key (descriptionSignatories, assetLabel) : (Set Party, Text)
    maintainer key._1

    controller descriptionSignatories can
      LookupOrInsert : (ContractId Index, Version) with claims : Claims
        do
          case Map.lookup claims versions of
             Some version -> return (self, version)
             None -> do
               let nextVersion = size versions
               cid <- create this with versions = Map.insert claims nextVersion versions
               return (cid, nextVersion)

