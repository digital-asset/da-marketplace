module Marketplace.Issuance.Instrument.Service where

import ClaimToken.Model
import ContingentClaims.Claim.Serializable (Claim(And, Give, Zero))
import DA.Optional (whenSome)
import DA.Set (empty, fromList)
import Marketplace.Issuance.AssetDescription
import Marketplace.Issuance.CFI qualified as CFI
import Marketplace.Issuance.Service qualified as Issuance
import Marketplace.Issuance.Instrument.Model (getClaims, Bond(..), Swap(..))

type T = Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    controller customer can
      nonconsuming RequestBond : (ContractId Issuance.OriginationRequest, ContractId Bond)
        with
          bond : Bond
          observers : [Party]
        do
          let cfi = CFI.bond
          claims <- getClaims operator provider bond.stream bond.currencyId bond.maturityDate True
          bondCid <- create bond
          whenSome bond.claimTokenId (\claimTokenId -> do 
                                  let id = (bond.id with label = claimTokenId)
                                  create ClaimToken with id; originalId = bond.id; observers = fromList observers
                                  create ClaimTokenR with id; originalId = bond.id; observers = fromList observers
                                  -- create dummy asset description for claim token
                                  create AssetDescription with assetId = id; description = "claim-token-" <> bond.id.label; cfi = CFI.other; issuer = customer; claims = Zero; registrar = provider; observers = empty
                                  pure ())
          assetCid <- exerciseByKey @Issuance.Service (operator, provider, customer) Issuance.RequestOrigination with assetLabel = bond.id.label; cfi; description = bond.id.label; claims; observers = observers
          pure (assetCid, bondCid)

      nonconsuming RequestSwap : (ContractId Issuance.OriginationRequest, ContractId Swap)
        with
          swap : Swap
          observers : [Party]
        do
          let cfi = CFI.CFI with code = "SRXXXX"
          pay <- getClaims operator provider (Some swap.pay) swap.payCurrencyId swap.maturityDate False
          receive <- getClaims operator provider (Some swap.receive) swap.receiveCurrencyId swap.maturityDate False
          let claims = And [ Give pay, receive ]
          swapCid <- create swap
          assetCid <- exerciseByKey @Issuance.Service (operator, provider, customer) Issuance.RequestOrigination with assetLabel = swap.id.label; cfi; description = swap.id.label; claims; observers = observers
          pure (assetCid, swapCid)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        do
          create Service with ..

      Decline : ()
        do pure ()

    controller provider can
      Withdraw : ()
        do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    controller customer can
      Cancel : ()
        do pure ()

    controller provider can
      Reject : ()
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        create Service with ..
