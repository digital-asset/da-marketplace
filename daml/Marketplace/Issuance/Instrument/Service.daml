module Marketplace.Issuance.Instrument.Service where

import ClaimToken.Model
import ContingentClaims.Claim.Serializable (Claim(And, Give, Zero))
import DA.Optional (whenSome)
import DA.Set (empty, fromList)
import Marketplace.Issuance.AssetDescription
import Marketplace.Issuance.CFI qualified as CFI
import Marketplace.Issuance.Service qualified as Issuance
import Marketplace.Issuance.Instrument.Model (getClaims, Bond(..), Swap(..))

type T = Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice RequestBond : (ContractId Issuance.OriginationRequest, ContractId Bond)
      with
        bond : Bond
        observers : [Party]
      controller customer
        do
          let cfi = CFI.bond
          claims <- getClaims operator provider bond.stream bond.currencyId bond.maturityDate True
          bondCid <- create bond
          whenSome bond.claimTokenId (\claimTokenId -> do 
                                  let id = (bond.id with label = claimTokenId)
                                  create ClaimToken with id; originalId = bond.id; observers = fromList observers
                                  create ClaimTokenR with id; originalId = bond.id; observers = fromList observers
                                  -- create dummy asset description for claim token
                                  create AssetDescription with assetId = id; description = "claim-token-" <> bond.id.label; cfi = CFI.other; issuer = customer; claims = Zero; registrar = provider; observers = empty
                                  pure ())
          assetCid <- exerciseByKey @Issuance.Service (operator, provider, customer) Issuance.RequestOrigination with assetLabel = bond.id.label; cfi; description = bond.id.label; claims; observers = observers
          pure (assetCid, bondCid)

    nonconsuming choice RequestSwap : (ContractId Issuance.OriginationRequest, ContractId Swap)
      with
        swap : Swap
        observers : [Party]
      controller customer
        do
          let cfi = CFI.CFI with code = "SRXXXX"
          pay <- getClaims operator provider (Some swap.pay) swap.payCurrencyId swap.maturityDate False
          receive <- getClaims operator provider (Some swap.receive) swap.receiveCurrencyId swap.maturityDate False
          let claims = And [ Give pay, receive ]
          swapCid <- create swap
          assetCid <- exerciseByKey @Issuance.Service (operator, provider, customer) Issuance.RequestOrigination with assetLabel = swap.id.label; cfi; description = swap.id.label; claims; observers = observers
          pure (assetCid, swapCid)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
        do
          create Service with ..

    choice Decline : ()
      controller customer
        do pure ()

    choice Withdraw : ()
      controller provider
        do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
        do pure ()

    choice Reject : ()
      controller provider
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        create Service with ..
