module Marketplace.Issuance.Instrument.Bond.Service where

import ContingentClaims.Claim (serialize)
import ContingentClaims.FinancialClaim (fixed)
import DA.Date (toGregorian)
import DA.Finance.Base.HolidayCalendar (BusinessDayAdjustment(..), HolidayCalendar)
import DA.Finance.Base.RollConvention (PeriodEnum(..), RollConventionEnum(DOM))
import DA.Finance.Base.Schedule (createSchedule, Frequency(..), PeriodicSchedule(..))
import Marketplace.Issuance.CFI (CFI(..))
import Marketplace.Issuance.Service qualified as Issuance
import Marketplace.Issuance.Instrument.Bond.Model (FixedRateBond(..))

type T = Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    controller customer can
      nonconsuming RequestFixedRate : (ContractId Issuance.OriginationRequest, ContractId FixedRateBond)
        with
          bond : FixedRateBond
        do
          calendars <- mapA (\id -> fetchByKey @HolidayCalendar (operator, provider, id)) bond.calendarIds
          let
            cfi = CFI with code = "DBXXXX"
            calendarData = map ((.calendar) . snd) calendars
            (y, m, d) = toGregorian bond.issueDate
            periodicSchedule = PeriodicSchedule with
              effectiveDate = bond.issueDate
              terminationDate = bond.maturityDate
              firstRegularPeriodStartDate = None
              lastRegularPeriodEndDate = None
              frequency = Frequency with period = bond.couponPeriod; periodMultiplier = bond.couponPeriodMultiplier; rollConvention = DOM d
              businessDayAdjustment = BusinessDayAdjustment with calendarIds = bond.calendarIds; convention = bond.businessDayConvention
              effectiveDateBusinessDayAdjustment = None
              terminationDateBusinessDayAdjustment = None
              stubPeriodType = None
            schedule = createSchedule calendarData periodicSchedule
            dates = map (.adjustedEndDate) schedule
            coupon = case bond.couponPeriod of
              D -> error "Daily coupon period not supported"
              W -> error "Weekly coupon period not supported"
              M -> bond.couponPerAnnum * (intToDecimal bond.couponPeriodMultiplier / 12.0)
              Y -> bond.couponPerAnnum
            claims = serialize $ fixed 1.0 coupon bond.currencyId dates
          debug dates
          bondCid <- create bond
          assetCid <- exerciseByKey @Issuance.Service (operator, provider, customer) Issuance.RequestOrigination with assetLabel = bond.id.label; cfi; description = bond.id.label; claims; observers = []
          pure (assetCid, bondCid)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        do
          create Service with ..

      Decline : ()
        do pure ()

    controller provider can
      Withdraw : ()
        do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    controller customer can
      Cancel : ()
        do pure ()

    controller provider can
      Reject : ()
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        create Service with ..
