module Marketplace.Lifecycle.Model where

import DA.Finance.Asset (AssetDeposit, AssetDeposit_Upgrade(..))
import DA.Finance.Types (Asset(..), Id)
import DA.Foldable (forA_)
import DA.Set (fromList, toList)
import Marketplace.Settlement.Hierarchical (createInstructions, Delivery(..), Status(..))

template Today
  with
    operator : Party
    provider : Party
    date : Date
  where
    signatory operator, provider

    key (operator, provider) : (Party, Party)
    maintainer key._1

    choice SetDate : ContractId Today
      with
        newDate : Date
      controller provider
      do
        create this with date = newDate

template Observation
  with
    operator : Party
    provider : Party
    label : Text
    date : Date
    value : Decimal
  where
    signatory operator, provider

    key (operator, provider, label, date) : (Party, Party, Text, Date)
    maintainer key._1

template SnapshotRequest
  with
    operator : Party
    bondRegistrar : Party
    custodian : Party
    assetId : Id
    newVersion : Int
  where
    signatory operator, bondRegistrar
    observer custodian

    choice Forward : [ContractId SnapshotRequest]
      with
        depositCids : [ContractId AssetDeposit]
      controller custodian
      do
        deposits <- zip depositCids <$> mapA fetch depositCids
        debug deposits
        let holders = toList . fromList $ map ((.account.owner) . snd) $ filter (\(_, d) -> d.asset.id.label == assetId.label && d.asset.id.version == assetId.version) deposits
        forA_ depositCids $ (\cid -> exercise cid AssetDeposit_Upgrade with newVersion)
        mapA (\c -> create this with custodian = c) holders

    choice Provide : [ContractId Snapshot]
      with
        depositCids : [ContractId AssetDeposit]
      controller custodian
      do
        deposits <- zip depositCids <$> mapA fetch depositCids
        let filtered = filter (\(_, d) -> d.asset.id.label == assetId.label && d.asset.id.version == assetId.version) deposits
        depCids <- mapA (\(cid, _) -> exercise cid AssetDeposit_Upgrade with newVersion) filtered
        upgraded <- mapA fetch depCids
        let snapshots = map (\deposit -> Snapshot with ..) upgraded
        mapA create snapshots

template Snapshot
  with
    operator : Party
    bondRegistrar : Party
    custodian : Party
    deposit : AssetDeposit
  where
    signatory operator, bondRegistrar, custodian

    choice Delete : ()
      controller bondRegistrar
      do pure ()

template Effect
  with
    operator : Party
    issuer : Party
    bondRegistrar : Party
    cashProvider : Party
    lifecycleId : Text
    assetId : Id
    newVersion : Int
    date : Date
    payouts : [(Decimal, Id)]
    expired : Bool
  where
    signatory operator, issuer, bondRegistrar

    nonconsuming choice RequestSnapshot : ContractId SnapshotRequest
      controller bondRegistrar
      do
        create SnapshotRequest with custodian = bondRegistrar; ..

    choice Instruct : [ContractId Delivery]
      with
        snapshotCids : [ContractId Snapshot]
      controller operator
      do
        let
          indexedPayouts = zip [0 .. length payouts - 1] payouts
          createInstructionsForPayout : Snapshot -> (Int, (Decimal, Id)) -> Update (ContractId Delivery)
          createInstructionsForPayout snapshot (index, (amount, id)) = do
            let
              settlementId = lifecycleId <> "-" <> partyToText snapshot.deposit.account.owner <> "-" <> show index
              instructionIdx = 0
              asset = Asset with id; quantity = amount * snapshot.deposit.asset.quantity
              sender = if amount > 0.0 then issuer else snapshot.deposit.account.owner
              receiver = if amount > 0.0 then snapshot.deposit.account.owner else issuer
            instructionCids <- createInstructions True operator bondRegistrar cashProvider sender receiver settlementId instructionIdx asset
            instructionIds <- map (.instructionId) <$> mapA fetch instructionCids
            create Delivery with operator; agent = bondRegistrar; sender; receiver; settlementId; instructionIds; asset; status = Instructed
          createInstructionsForSnapshot : ContractId Snapshot -> Update [ContractId Delivery]
          createInstructionsForSnapshot snapshotCid = do
            snapshot <- fetch snapshotCid
            deliveryCids <-
              if expired
              then do
                let
                  settlementId = lifecycleId <> "-" <> partyToText snapshot.deposit.account.owner <> "-Expiry"
                  asset = snapshot.deposit.asset with id.signatories = fromList [bondRegistrar, issuer]
                instructionCids <- createInstructions False operator bondRegistrar bondRegistrar snapshot.deposit.account.owner issuer settlementId 0 asset
                instructionIds <- map (.instructionId) <$> mapA fetch instructionCids
                dCid <- create Delivery with operator; agent = bondRegistrar; sender = snapshot.deposit.account.owner; receiver = issuer; settlementId; instructionIds; asset; status = Instructed
                dCids <- mapA (createInstructionsForPayout snapshot) indexedPayouts
                pure $ dCid :: dCids
              else
                mapA (createInstructionsForPayout snapshot) indexedPayouts
            exercise snapshotCid Delete
            pure deliveryCids
        concat <$> mapA createInstructionsForSnapshot snapshotCids
