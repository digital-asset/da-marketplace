module Marketplace.Lifecycle.Model where

import ContingentClaims.Claim.Serializable (Claim(..))
import DA.Finance.Asset (AssetDeposit, AssetDeposit_Upgrade(..))
import DA.Finance.Types (Account, Asset(..), Id)
import DA.Foldable (forA_)
import DA.List (dedup)
import DA.Set (fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Issuance.Instrument.Model qualified as Instrument
import Marketplace.Settlement.Hierarchical (createInstructions, getAccount, Delivery(..), Status(..))
import SwiftMessage.Message (SwiftMessage(MT566), SwiftMessageType(..), SwiftOutboundMessage(..))
import SwiftMessage.Model.MT566
import SwiftMessage.Util
import DA.Text (isInfixOf)

type Claims = Claim Date Decimal Id
template Today
  with
    operator : Party
    provider : Party
    date : Date
  where
    signatory operator, provider

    key (operator, provider) : (Party, Party)
    maintainer key._1

    choice SetDate : ContractId Today
      with
        newDate : Date
      controller provider
      do
        create this with date = newDate

template Observation
  with
    operator : Party
    provider : Party
    label : Text
    date : Date
    value : Decimal
  where
    signatory operator, provider

    key (operator, provider, label, date) : (Party, Party, Text, Date)
    maintainer key._1

template SnapshotRequest
  with
    operator : Party
    bondRegistrar : Party
    custodian : Party
    payingAgent : Party
    assetId : Id
    newVersion : Int
  where
    signatory operator, bondRegistrar
    observer custodian

    choice Forward : [ContractId SnapshotRequest]
      with
        depositCids : [ContractId AssetDeposit]
      controller custodian
      do
        deposits <- zip depositCids <$> mapA fetch depositCids
        let
          filtered = filter (\(_, d) -> d.asset.id.label == assetId.label && d.asset.id.version == assetId.version) deposits
          holders = dedup $ map ((.account.owner) . snd) filtered
        forA_ filtered $ (\(cid, _) -> exercise cid AssetDeposit_Upgrade with newVersion)
        mapA (\c -> create this with custodian = c) holders

    choice Provide : [ContractId Snapshot]
      with
        depositCids : [ContractId AssetDeposit]
      controller custodian
      do
        deposits <- zip depositCids <$> mapA fetch depositCids
        let filtered = filter (\(_, d) -> d.asset.id.label == assetId.label && d.asset.id.version == assetId.version) deposits
        forA_ filtered (\(cid, _) -> exercise cid AssetDeposit_Upgrade with newVersion)
        let snapshots = map (\(_, deposit) -> Snapshot with ..) filtered
        mapA create snapshots

template Snapshot
  with
    operator : Party
    bondRegistrar : Party
    custodian : Party
    payingAgent : Party
    assetId : Id
    deposit : AssetDeposit
  where
    signatory operator, bondRegistrar, custodian
    observer payingAgent

    choice Delete : ()
      controller operator
      do pure ()

template Effect
  with
    operator : Party
    issuer : Party
    bondRegistrar : Party
    cashProvider : Party
    payingAgent : Party
    lifecycleId : Text
    assetId : Id
    newVersion : Int
    date : Date
    payouts : [(Decimal, Id)]
    expired : Bool
  where
    signatory operator, issuer, payingAgent
    observer bondRegistrar

    nonconsuming choice RequestSnapshot : ContractId SnapshotRequest
      controller bondRegistrar
      do
        create SnapshotRequest with custodian = bondRegistrar; ..

    choice Instruct : [ContractId Delivery]
      with
        snapshotCids : [ContractId Snapshot]
      controller operator
      do
        let
          sendSwiftMessage : Text -> Account -> Asset -> Update ()
          sendSwiftMessage settlementId buyerSafekeepingAcc asset = do
            let              
              getRedemptionDate : Date -> Date -> Optional Date
              getRedemptionDate maturityDate payoutDate = if payoutDate == maturityDate then Some payoutDate else Nothing
            if "BOND" `isInfixOf` assetId.label then do -- todo this is a temporary hack
              (_, bond) <- fetchByKey @Instrument.Bond (fromList [issuer, bondRegistrar], assetId.label)
            
              let
                instrumentId = bond.isin <> assetId.label
                faceAmount = asset.quantity
                currency = asset.id
                maturityDate = bond.maturityDate
                payoutDate = date
                redemptionDate = getRedemptionDate maturityDate payoutDate
                mt566 = createMT566Details instrumentId buyerSafekeepingAcc CR faceAmount currency maturityDate payoutDate redemptionDate
              create SwiftOutboundMessage with referenceId = settlementId; provider = operator ; consumer = operator; swiftMessage=MT566 (mt566); swiftMessageType=MT566_t; status=Pending; observers=fromList [payingAgent]
              pure ()
            else pure ()
          
          indexedPayouts = zip [0 .. length payouts - 1] payouts
          createInstructionsForPayout : Snapshot -> (Int, (Decimal, Id)) -> Update (ContractId Delivery)
          createInstructionsForPayout snapshot (index, (amount, id)) = do
            let
              settlementId = lifecycleId <> "-" <> partyToText snapshot.deposit.account.owner <> "-" <> show index
              instructionIdx = 0
              asset = Asset with id; quantity = (abs amount) * snapshot.deposit.asset.quantity
              sender = if amount > 0.0 then issuer else snapshot.deposit.account.owner
              receiver = if amount > 0.0 then snapshot.deposit.account.owner else issuer
            (_, senderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, sender)
            (_, receiverSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiver)
            let
              senderAccount = getAccount True senderSettlementInfo sender
              receiverAccount = getAccount True receiverSettlementInfo receiver
            instructionCids <- createInstructions True operator payingAgent cashProvider senderAccount receiverAccount settlementId instructionIdx asset
            instructionIds <- map (.instructionId) <$> mapA fetch instructionCids
            sendSwiftMessage settlementId receiverAccount asset
            create Delivery with operator; agent = payingAgent; sender; receiver; settlementId; instructionIds; asset; status = Instructed
          createInstructionsForSnapshot : ContractId Snapshot -> Update [ContractId Delivery]
          createInstructionsForSnapshot snapshotCid = do
            snapshot <- fetch snapshotCid
            deliveryCids <-
              if expired
              then do
                let
                  settlementId = lifecycleId <> "-" <> partyToText snapshot.deposit.account.owner <> "-Expiry"
                  asset = snapshot.deposit.asset with id.signatories = fromList [bondRegistrar, issuer]; id.version = newVersion
                  sender = snapshot.deposit.account.owner
                  receiver = bondRegistrar
                (_, senderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, sender)
                (_, receiverSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiver)
                let
                  senderAccount = getAccount False senderSettlementInfo sender
                  receiverAccount = getAccount False receiverSettlementInfo receiver
                instructionCids <- createInstructions False operator payingAgent bondRegistrar senderAccount receiverAccount settlementId 0 asset
                instructionIds <- map (.instructionId) <$> mapA fetch instructionCids
                dCid <- create Delivery with operator; agent = payingAgent; sender; receiver; settlementId; instructionIds; asset; status = Instructed
                dCids <- mapA (createInstructionsForPayout snapshot) indexedPayouts
                pure $ dCid :: dCids
              else
                mapA (createInstructionsForPayout snapshot) indexedPayouts
            exercise snapshotCid Delete
            pure deliveryCids
        concat <$> mapA createInstructionsForSnapshot snapshotCids
