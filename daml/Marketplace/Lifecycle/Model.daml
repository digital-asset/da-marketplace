module Marketplace.Lifecycle.Model where

import DA.Finance.Asset (AssetDeposit, AssetDeposit_Upgrade(..))
import DA.Finance.Types (Asset(..), Id)
import Marketplace.Settlement.Hierarchical (createInstructions, Payment(..), SettlementInstruction(..), Status(..))

template Today
  with
    operator : Party
    provider : Party
    date : Date
  where
    signatory operator, provider

    key (operator, provider) : (Party, Party)
    maintainer key._1

template Observation
  with
    operator : Party
    provider : Party
    label : Text
    date : Date
    value : Decimal
  where
    signatory operator, provider

    key (operator, provider, label, date) : (Party, Party, Text, Date)
    maintainer key._1

template Effect
  with
    operator : Party
    issuer : Party
    bondRegistrar : Party
    cashProvider : Party
    recipient : Party
    lifecycleId : Text
    assetId : Id
    newVersion : Int
    date : Date
    payouts : [(Decimal, Id)]
  where
    signatory operator, issuer, bondRegistrar
    observer recipient

    choice Instruct : ([ContractId Effect], [(ContractId Payment, [ContractId SettlementInstruction])])
      with
        custodians : [Party]
        depositCids : [ContractId AssetDeposit]
      controller operator, recipient
      do
        let
          createInstructionsForAssetDeposit : (Decimal, Id) -> ContractId AssetDeposit -> Update (ContractId Payment, [ContractId SettlementInstruction])
          createInstructionsForAssetDeposit (amount, id) depositCid = do
            deposit <- fetch depositCid
            let
              settlementId = lifecycleId <> "-" <> partyToText deposit.account.owner
              instructionIdx = 0
              payment = Asset with id; quantity = amount * deposit.asset.quantity
              sender = if amount > 0.0 then issuer else deposit.account.owner
              receiver = if amount > 0.0 then deposit.account.owner else issuer
            exercise depositCid AssetDeposit_Upgrade with newVersion
            instructionCids <- createInstructions True operator bondRegistrar cashProvider sender receiver settlementId instructionIdx payment
            instructionIds <- map (.instructionId) <$> mapA fetch instructionCids
            paymentCid <- create Payment with operator; agent = bondRegistrar; payer = sender; payee = receiver; settlementId; instructionIds; payment; status = Instructed
            pure (paymentCid, instructionCids)
          createInstructionsForPayout : (Decimal, Id) -> Update [(ContractId Payment, [ContractId SettlementInstruction])]
          createInstructionsForPayout payout = do
            mapA (createInstructionsForAssetDeposit payout) depositCids
        effectCids <- mapA (\c -> create this with recipient = c) custodians
        instructionCids <- concat <$> mapA createInstructionsForPayout payouts
        pure (effectCids, instructionCids)
