module Marketplace.Lifecycle.Model where

import ContingentClaims.Claim.Serializable (Claim(..))
import DA.Finance.Types (Account, Asset(..), Id)
import DA.Set (fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Issuance.AssetDescription
import Marketplace.Issuance.CFI qualified as CFI
import Marketplace.Issuance.Instrument.Model qualified as Instrument
import Marketplace.Snapshot.Model
import Marketplace.Settlement.Hierarchical.Delivery (Delivery(..))
import Marketplace.Settlement.Hierarchical.Dvd (Dvd(..))
import Marketplace.Settlement.Hierarchical.Instruction (Instruction(..))
import Marketplace.Settlement.Hierarchical.Util (createInstructions, getAccount, Status(..))
import SwiftMessage.Message (SwiftMessage(MT566), SwiftMessageType(..), SwiftOutboundMessage(..))
import SwiftMessage.Model.MT566
import SwiftMessage.Util

type Claims = Claim Date Decimal Id
template Today
  with
    operator : Party
    provider : Party
    date : Date
  where
    signatory operator, provider

    key (operator, provider) : (Party, Party)
    maintainer key._1

    choice SetDate : ContractId Today
      with
        newDate : Date
      controller provider
      do
        create this with date = newDate

template Observation
  with
    operator : Party
    provider : Party
    label : Text
    date : Date
    value : Decimal
  where
    signatory operator, provider

    key (operator, provider, label, date) : (Party, Party, Text, Date)
    maintainer key._1

template Effect
  with
    operator : Party
    issuer : Party
    bondRegistrar : Party
    cashProvider : Party
    payingAgent : Party
    lifecycleId : Text
    assetId : Id
    newVersion : Int
    date : Date
    payouts : [(Decimal, Id)]
    expired : Bool
  where
    signatory operator, issuer, payingAgent
    observer bondRegistrar

    choice Instruct : ([ContractId Dvd], [ContractId Delivery])
      with
        snapshotCids : [ContractId Snapshot]
      controller operator
      do
        let
          sendSwiftMessage : Party -> Account -> Account -> Asset -> Decimal -> Update (Optional PayoutRefId)
          sendSwiftMessage receiver buyerSafekeepingAcc buyerCashAcc asset amount = do
            (_, description) <- fetchByKey @AssetDescription assetId
            if (description.cfi == CFI.bond) then do
              (_, bond) <- fetchByKey @Instrument.Bond (fromList [issuer, bondRegistrar], assetId.label)

              let
                instrumentId = bond.isin <> "-" <> assetId.label
                faceAmount = asset.quantity
                currency = asset.id
                maturityDate = bond.maturityDate
                payoutDate = date
                redemptionDate = getRedemptionDate maturityDate payoutDate
                mt566 = createMT566Details instrumentId assetId description.cfi issuer buyerSafekeepingAcc buyerCashAcc CRED faceAmount currency maturityDate payoutDate redemptionDate
                isRedempt = (amount == bond.unitPar)
                refId = PayoutRefId with ..
              create SwiftOutboundMessage with referenceId = show refId; provider = operator ; consumer = operator; swiftMessage=MT566 (mt566); swiftMessageType=MT566_t; status=Pending; observers=fromList [payingAgent]
              pure $ Some refId
            else pure None

          indexedPayouts = zip [0 .. length payouts - 1] payouts
          
          createInstructionsForDelivery : Text -> Party -> Party -> Asset -> Int -> Update [ContractId Instruction]
          createInstructionsForDelivery settlementId sender receiver asset idx = do
            (_, senderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, sender)
            (_, receiverSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiver)
            let
              senderAccount = getAccount False senderSettlementInfo sender
              receiverAccount = getAccount False receiverSettlementInfo receiver
            createInstructions False operator payingAgent bondRegistrar senderAccount receiverAccount settlementId idx asset
          
          createInstructionsForPayout : Snapshot -> (Int, (Decimal, Id)) -> Update (ContractId Delivery)
          createInstructionsForPayout snapshot (index, (amount, id)) = do
            let
              settlementId = lifecycleId <> "-" <> partyToText snapshot.deposit.account.owner <> "-" <> show index
              instructionIdx = 0
              asset = Asset with id; quantity = (abs amount) * snapshot.deposit.asset.quantity
              sender = if amount > 0.0 then issuer else snapshot.deposit.account.owner
              receiver = if amount > 0.0 then snapshot.deposit.account.owner else issuer
            (_, senderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, sender)
            (_, receiverSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiver)
            let
              senderAccount = getAccount True senderSettlementInfo sender
              receiverSecAccount = getAccount False receiverSettlementInfo receiver
              receiverCashAccount = getAccount True receiverSettlementInfo receiver

            instructionCids <- createInstructions True operator payingAgent cashProvider senderAccount receiverCashAccount settlementId instructionIdx asset
            instructionIds <- map (.instructionId) <$> mapA fetch instructionCids
            payoutRefIdOpt <- sendSwiftMessage receiver receiverSecAccount receiverCashAccount asset amount
            let refIdOpt = show <$> payoutRefIdOpt
            create Delivery with operator; agent = payingAgent; sender; receiver; settlementId; refIdOpt; instructionIds; asset; status = Instructed

          createInstructionsForSnapshot : ContractId Snapshot -> Update ([ContractId Dvd], [ContractId Delivery])
          createInstructionsForSnapshot snapshotCid = do
            snapshot <- fetch snapshotCid
            let 
              settlementId = lifecycleId <> "-" <> partyToText snapshot.deposit.account.owner
              asset = snapshot.deposit.asset with id.signatories = fromList [bondRegistrar, issuer]
              bondHolder = snapshot.deposit.account.owner
            deliveryCids <-
              if expired
              then do
                let settlementIdExp = settlementId <> "-Expiry"
                instructionCids <- createInstructionsForDelivery settlementIdExp bondHolder bondRegistrar asset 0
                instructionIds <- map (.instructionId) <$> mapA fetch instructionCids
                dCid <- create Delivery with operator; agent = payingAgent; sender = bondHolder; receiver = bondRegistrar; settlementId = settlementIdExp; refIdOpt = None; instructionIds; asset; status = Instructed
                dCids <- mapA (createInstructionsForPayout snapshot) indexedPayouts
                pure ([], dCid :: dCids)
              else do
                let 
                  settlementIdUpgrade = settlementId <> "-Upgrade"
                  delivery1 = asset
                  delivery2 = asset with id.version = newVersion
                  deliverer1 = bondHolder
                  deliverer2 = bondRegistrar
                let
                instruction1Cids <- createInstructionsForDelivery settlementIdUpgrade deliverer1 deliverer2 delivery1 0
                instruction2Cids <- createInstructionsForDelivery settlementIdUpgrade deliverer2 deliverer1 delivery2 (length instruction1Cids)
                instructionIds <- map (.instructionId) <$> mapA fetch (instruction1Cids <> instruction2Cids)
                tCid <- create Dvd with operator; agent = payingAgent; deliverer1; deliverer2; settlementId = settlementIdUpgrade; instructionIds; delivery1; delivery2; status = Instructed
                dCid <- mapA (createInstructionsForPayout snapshot) indexedPayouts
                pure ([tCid], dCid)
            exercise snapshotCid Delete
            pure deliveryCids
        results <- mapA createInstructionsForSnapshot snapshotCids
        let
          dvds = concatMap fst results
          deliveries = concatMap snd results
        pure (dvds, deliveries)
