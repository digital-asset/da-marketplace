module Marketplace.Lifecycle.Service where

import ContingentClaims.Claim (deserialize, serialize)
import ContingentClaims.Lifecycle qualified as Lifecycle
import ContingentClaims.Claim.Serializable (Claim(..))
import ContingentClaims.Observation qualified as Ob
import ContingentClaims.Util (fixings, payoffs)
import DA.Finance.Types (Id)
import DA.Foldable (mapA_)
import DA.List (head)
import DA.Optional (whenSome)
import DA.Set qualified as Set
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Issuance.AssetDescription qualified as AssetDescription
import Marketplace.Issuance.Instrument.Model qualified as Instrument
import Marketplace.Lifecycle.Model (Observation, Today, Effect(..))
import Marketplace.Snapshot.Model
import Marketplace.Settlement.Hierarchical.Util (getAccount)
import Marketplace.Utils
import SwiftMessage.Message (SwiftMessage(MT564), SwiftMessageType(..), SwiftOutboundMessage(..))
import SwiftMessage.Model.MT564
import SwiftMessage.Util

type Claims = Claim Date Decimal Id

type T = Service

template Service
  with
    operator : Party
    bondRegistrar : Party
    payingAgent : Party
    issuer : Party
    cashProvider : Party
  where
    signatory operator, bondRegistrar, issuer, payingAgent

    key (operator, issuer, payingAgent) : (Party, Party, Party)
    maintainer key._1

    controller payingAgent can
      nonconsuming CalculateEffect : Optional (ContractId Effect)
        with
          assetId : Id
          election : Optional Claims
        do
          (_, today) <- fetchByKey @Today (operator, payingAgent)
          (_, description) <- fetchByKey @AssetDescription.T assetId
          let obs label date = do
              (_, observation) <- fetchByKey @Observation (operator, payingAgent, label, date)
              pure observation.value
          remaining <-
            case election of
            Some e -> Lifecycle.exercise obs (True, deserialize e) (deserialize description.claims) today.date
            _ -> pure (deserialize description.claims)
          Lifecycle.Result{remaining, pending} <- Lifecycle.lifecycle obs remaining today.date
          let serializedRemaining = serialize remaining
          if description.claims /= serializedRemaining then do
            let
              newVersion = assetId.version + 1
              lifecycleId = "Lifecycle-" <> show today.date <> "-" <> assetId.label <> "(v" <> show assetId.version <> ")"
              expired = serializedRemaining == Zero
            descriptionCid <- create description with assetId.version = newVersion; claims = serializedRemaining
            effectCid <- create Effect with operator; issuer; bondRegistrar; cashProvider; payingAgent; lifecycleId; assetId; newVersion; date = today.date; payouts = pending; expired
            pure $ Some effectCid
          else
            pure None

    controller operator can
      nonconsuming SendPrePayoutSwiftMessage : [ContractId SwiftOutboundMessage]
        with
          snapshotCids : [ContractId Snapshot]
          exDivDate : Date
        do
          let
              getPayoutDate : Claims -> Date
              getPayoutDate serializedClaims =
                head $ fixings $ deserialize serializedClaims

              getPayoutRate : Claims -> Update Decimal
              getPayoutRate serializedClaims =
                let getObserveRate label = do
                    (_, observation) <- fetchByKey @Observation (operator, payingAgent, label, exDivDate)
                    pure observation.value in
                let (comingPayout, id) = head $ payoffs $ deserialize serializedClaims in
                case comingPayout of
                  Ob.Const rate -> pure rate
                  Ob.Add (Ob.Observe k, Ob.Const spread) -> do
                      observeRate <- getObserveRate k
                      pure $ observeRate + spread
                  other -> error $ "Cannot find payout rate with observation: " <> show other

              createNewPrenotificationSwiftMessage : Text -> Party -> Party -> MT564Details -> Update (ContractId SwiftOutboundMessage)
              createNewPrenotificationSwiftMessage referenceId provider consumer mt564 = do
                let swiftMessageType = MT564_t
                currentReport <- (lookupByKey @SwiftOutboundMessage (operator, referenceId, swiftMessageType))
                whenSome currentReport archive
                create SwiftOutboundMessage with swiftMessage=MT564 (mt564); status=Finalized; observers=Set.empty; ..

              sendMessageForSnapshot : Snapshot -> Update (ContractId SwiftOutboundMessage)
              sendMessageForSnapshot snapshot = do
                  let buyer = snapshot.deposit.account.owner
                      assetId = snapshot.assetId
                  (_, bond) <- fetchByKey @Instrument.Bond (Set.fromList [issuer, bondRegistrar], assetId.label)
                  (_, description) <- fetchByKey @AssetDescription.T assetId
                  (_, settlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, buyer)
                  let
                    claims = description.claims
                    asset = snapshot.deposit.asset
                    instrumentId = bond.isin <> "-" <> assetId.label
                    currency = bond.currencyId
                    maturityDate = bond.maturityDate
                    payoutDate = getPayoutDate claims
                    redemptionDate = getRedemptionDate maturityDate payoutDate
                  payoutRate <- getPayoutRate claims
                  let
                    faceAmount = asset.quantity * payoutRate
                    buyerSafekeepingAcc = getAccount False settlementInfo buyer
                    buyerCashAcc = getAccount True settlementInfo buyer
                    mt564 = createMT564Details instrumentId asset.id description.cfi issuer buyerSafekeepingAcc buyerCashAcc CRED faceAmount currency maturityDate payoutDate redemptionDate exDivDate
                    mt564_redempt = (\_ -> createMT564Details instrumentId asset.id description.cfi issuer buyerSafekeepingAcc buyerCashAcc CRED asset.quantity currency maturityDate payoutDate redemptionDate exDivDate) <$> redemptionDate
                    createRefId isRedempt = PayoutRefId with receiver = buyer; ..
                  mapA_ (\mt564_r -> createNewPrenotificationSwiftMessage (show $ createRefId True) operator operator mt564_r) mt564_redempt
                  createNewPrenotificationSwiftMessage (show $ createRefId False) operator operator mt564
          snapshots <- mapA fetch snapshotCids
          mapA_ (`exercise` Delete) snapshotCids
          mapA sendMessageForSnapshot snapshots
      Terminate : ()
        do return ()

template Offer
  with
    operator : Party
    bondRegistrar : Party
    payingAgent : Party
    issuer : Party
    cashProvider : Party
  where
    signatory operator, bondRegistrar, issuer

    controller payingAgent can
      Accept : ContractId Service
        do
          createOrLookup Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    bondRegistrar : Party
    payingAgent : Party
    issuer : Party
    cashProvider : Party
   where
    signatory payingAgent

    controller operator, bondRegistrar can
      Approve : ContractId Service
        do
          createOrLookup Service with ..

      Reject : ()
        do
          return ()
