module Marketplace.Lifecycle.Service where

import ContingentClaims.Claim (deserialize, serialize)
import ContingentClaims.Lifecycle qualified as Lifecycle
import ContingentClaims.Claim.Serializable (Claim(..))
import DA.Finance.Types (Id)
import Marketplace.Issuance.AssetDescription qualified as AssetDescription
import Marketplace.Lifecycle.Model (Observation, Effect(..))
import Marketplace.Utils
import Marketplace.Issuance.Instrument.Model qualified as Instrument

type Claims = Claim Date Decimal Id

type T = Service

template Service
  with
    operator : Party
    issuer : Party
    bondRegistrar : Party
    cashProvider : Party
  where
    signatory operator, issuer, bondRegistrar

    key (operator, issuer, bondRegistrar) : (Party, Party, Party)
    maintainer key._1
    
    controller bondRegistrar can
      nonconsuming CalculateEffect : Optional (ContractId Effect)
        with
          assetId : Id
          election : Optional Claims
          payDate: Date
          recordDate : Date
        do
          -- (_, today) <- fetchByKey @Today (operator, bondRegistrar)
          (_, description) <- fetchByKey @AssetDescription.T assetId
          (_, bond) <- fetchByKey @Instrument.Bond (assetId.signatories,assetId.label)
          let obs label date = do
              (_, observation) <- fetchByKey @Observation (operator, bondRegistrar, label, date)
              pure observation.value
          remaining <-
            case election of
            Some e -> Lifecycle.exercise obs (True, deserialize e) (deserialize description.claims) payDate
            _ -> pure (deserialize description.claims)
          Lifecycle.Result{remaining, pending} <- Lifecycle.lifecycle obs remaining payDate
          let serializedRemaining = serialize remaining
          if description.claims /= serialize remaining then do
            let newVersion = assetId.version + 1
            let lifecycleId = "Lifecycle-" <> show payDate <> "-" <> assetId.label <> "(v" <> show assetId.version <> ")"
            let expired = serializedRemaining == Zero
            -- create description with assetId.version = newVersion; claims = serializedRemaining
            Some <$> create Effect with remainingClaims = serializedRemaining; operator; issuer; bondRegistrar; cashProvider; lifecycleId; assetId; newVersion; payDate; payouts = pending; expired; recordDate; isin = bond.isin; cfi = description.cfi
          else
            pure None

    controller operator can
      Terminate : ()
        do return ()

template Offer
  with
    operator : Party
    issuer : Party
    bondRegistrar : Party
    cashProvider : Party
  where
    signatory operator, issuer

    controller bondRegistrar can
      Accept : ContractId Service
        do
          createOrLookup Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    issuer : Party
    operator : Party
    bondRegistrar : Party
    cashProvider : Party
  where
    signatory bondRegistrar

    controller operator, issuer can
      Approve : ContractId Service
        do
          createOrLookup Service with ..

      Reject : ()
        do
          return ()
