module Marketplace.Lifecycle.Service where

import ContingentClaims.Claim (deserialize, serialize)
import ContingentClaims.Lifecycle qualified as Lifecycle
import ContingentClaims.Claim.Serializable (Claim(..))
import ContingentClaims.Observation qualified as Ob
import ContingentClaims.Util (fixings, payoffs)
import DA.Finance.Types (Id)
import DA.Foldable (mapA_)
import DA.List (head)
import DA.Set (empty, fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Issuance.AssetDescription qualified as AssetDescription
import Marketplace.Issuance.Instrument.Model qualified as Instrument
import Marketplace.Lifecycle.Model (Observation, Today, Effect(..))
import Marketplace.Lifecycle.Snapshot.Model
import Marketplace.Settlement.Hierarchical (getAccount)
import Marketplace.Utils
import SwiftMessage.Message (SwiftMessage(MT564), SwiftMessageType(..), SwiftOutboundMessage(..))
import SwiftMessage.Model.MT564
import SwiftMessage.Util

type Claims = Claim Date Decimal Id

type T = Service

template Service
  with
    operator : Party
    issuer : Party
    bondRegistrar : Party
    cashProvider : Party
    payingAgent : Party
  where
    signatory operator, issuer, payingAgent
    observer bondRegistrar
    
    key (operator, issuer, payingAgent) : (Party, Party, Party)
    maintainer key._1

    controller payingAgent can
      nonconsuming CalculateEffect : Optional (ContractId Effect, ContractId AssetDescriptionUpdateRequest)
        with
          assetId : Id
          election : Optional Claims
        do
          (_, today) <- fetchByKey @Today (operator, payingAgent)
          (_, description) <- fetchByKey @AssetDescription.T assetId
          let obs label date = do
              (_, observation) <- fetchByKey @Observation (operator, payingAgent, label, date)
              pure observation.value
          remaining <-
            case election of
            Some e -> Lifecycle.exercise obs (True, deserialize e) (deserialize description.claims) today.date
            _ -> pure (deserialize description.claims)
          Lifecycle.Result{remaining, pending} <- Lifecycle.lifecycle obs remaining today.date
          let serializedRemaining = serialize remaining
          if description.claims /= serialize remaining then do
            let newVersion = assetId.version + 1
            let lifecycleId = "Lifecycle-" <> show today.date <> "-" <> assetId.label <> "(v" <> show assetId.version <> ")"
            let expired = serializedRemaining == Zero
            requestCid <- create AssetDescriptionUpdateRequest with claims = serializedRemaining; ..
            effectCid <- create Effect with operator; issuer; bondRegistrar; cashProvider; payingAgent; lifecycleId; assetId; newVersion; date = today.date; payouts = pending; expired
            pure $ Some (effectCid, requestCid)
          else
            pure None

    controller operator can
      nonconsuming SendPrePayoutSwiftMessage : ()
        with 
          assetId : Id
          snapshotCids : [ContractId Snapshot]
          exDivDate : Date
        do
          let 
              getPayoutDate : Claims -> Date 
              getPayoutDate serializedClaims = 
                head $ fixings $ deserialize serializedClaims
            
              getPayoutRate : Claims -> Decimal
              getPayoutRate serializedClaims = 
                let (comingPayout, id) = head $ payoffs $ deserialize serializedClaims in
                case comingPayout of
                  Ob.Const v -> v
                  other  -> error $ "Cannot find payout rate: " <> show other 
              
              sendMessageForSnapshot : Snapshot -> Update (ContractId SwiftOutboundMessage)
              sendMessageForSnapshot snapshot = do                
                  let buyer = snapshot.deposit.account.owner
                  (_, bond) <- fetchByKey @Instrument.Bond (fromList [issuer, bondRegistrar], assetId.label)
                  (_, description) <- fetchByKey @AssetDescription.T assetId
                  (_, settlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, buyer)
                  let                  
                    claims = description.claims
                    asset = snapshot.deposit.asset
                    instrumentId = bond.isin <> "-" <> assetId.label        
                    currency = bond.currencyId
                    maturityDate = bond.maturityDate
                    payoutDate = getPayoutDate claims
                    redemptionDate = getRedemptionDate maturityDate payoutDate
                    faceAmount = asset.quantity * (getPayoutRate claims)
                    buyerSafekeepingAcc = getAccount True settlementInfo buyer
                    mt564 = createMT564Details instrumentId buyerSafekeepingAcc CR faceAmount currency maturityDate payoutDate redemptionDate exDivDate
                    mt564_redempt = (\_ -> createMT564Details instrumentId buyerSafekeepingAcc CR asset.quantity currency maturityDate payoutDate redemptionDate exDivDate) <$> redemptionDate          
                    notificationId = "Prenotification-" <> show exDivDate <> "-" <> assetId.label <> "(v" <> show assetId.version <> ")" <> "-" <> partyToText buyer
                  mapA_ (\mt564_r -> create SwiftOutboundMessage with referenceId = notificationId <> "-" <> "redempt"; provider = operator ; consumer = operator; swiftMessage=MT564 (mt564_r); swiftMessageType=MT564_t; status=Finalized; observers=empty) mt564_redempt
                  create SwiftOutboundMessage with referenceId = notificationId; provider = operator ; consumer = operator; swiftMessage=MT564 (mt564); swiftMessageType=MT564_t; status=Finalized; observers=empty
          snapshots <- mapA fetch snapshotCids
          mapA_ sendMessageForSnapshot snapshots
          mapA_ (`exercise` Delete) snapshotCids
      Terminate : ()
        do return ()

template Offer
  with
    operator : Party
    issuer : Party
    bondRegistrar : Party
    cashProvider : Party
    payingAgent : Party
  where
    signatory operator, issuer

    controller payingAgent can
      Accept : ContractId Service
        do
          createOrLookup Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    issuer : Party
    operator : Party
    bondRegistrar : Party
    cashProvider : Party
    payingAgent : Party
  where
    signatory payingAgent

    controller operator, issuer can
      Approve : ContractId Service
        do
          createOrLookup Service with ..

      Reject : ()
        do
          return ()

template AssetDescriptionUpdateRequest 
  with
    issuer : Party
    payingAgent : Party
    bondRegistrar : Party
    assetId : Id
    description : AssetDescription.AssetDescription
    newVersion : Int
    claims : Claims
  where 
    signatory issuer, payingAgent
    
    controller bondRegistrar can 
      ApproveUpdate : ContractId AssetDescription.AssetDescription
        do
          create description with assetId.version = newVersion; claims