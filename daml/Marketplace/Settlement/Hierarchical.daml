module Marketplace.Settlement.Hierarchical where

import DA.Assert ((===))
import DA.Finance.Types (Account, Asset)
import DA.Finance.Asset (AssetDeposit(..), AssetDeposit_Transfer(..), AssetDeposit_SetObservers(..))
import DA.List (singleton)
import DA.Optional (whenSome, fromSome, fromSomeNote)
import DA.Set (fromList)
import Marketplace.Custody.Model qualified as Custody
import SwiftMessage.Message

data Status =
  Instructed
  | Settled
  deriving (Eq, Show)

template Trade
  with
    operator : Party
    agent : Party
    deliverer : Party
    payer : Party
    settlementId : Text
    instructionIds : [Text]
    payment : Asset
    delivery : Asset
    status : Status
  where
    signatory operator
    observer agent

    key (operator, settlementId) : (Party, Text)
    maintainer key._1

    let finalizeSwiftMessage k = do
        cidOpt <- lookupByKey @SwiftOutboundMessage k
        whenSome cidOpt (\cid -> do exercise cid Finalize; pure ())
    controller agent can
      Settle : (ContractId Trade, [ContractId AssetDeposit])
        do
          let
            settle (instructionId : Text) = do
              (siCid, si) <- fetchByKey @SettlementInstruction (operator, settlementId, instructionId)
              assertMsg "Settlement id of instruction doesn't match trade" $ si.settlementId == settlementId
              exercise siCid SettleInstruction
          adCids <- mapA settle instructionIds
          tradeCid <- create this with status = Settled
          finalizeSwiftMessage (operator, settlementId, MT545_t)
          finalizeSwiftMessage (operator, settlementId, MT547_t)
          pure (tradeCid, adCids)

template Delivery
  with
    operator : Party
    agent : Party
    sender : Party
    receiver : Party
    settlementId : Text
    instructionIds : [Text]
    asset : Asset
    status : Status
  where
    signatory operator
    observer agent

    key (operator, settlementId) : (Party, Text)
    maintainer key._1

    controller agent can
      SettleDelivery : (ContractId Delivery, [ContractId AssetDeposit])
        do
          let
            settle (instructionId : Text) = do
              (siCid, si) <- fetchByKey @SettlementInstruction (operator, settlementId, instructionId)
              si.settlementId === settlementId
              si.asset.id.label === asset.id.label
              si.asset.id.version === asset.id.version
              si.asset.quantity === asset.quantity
              exercise siCid SettleInstruction
          adCids <- mapA settle instructionIds
          deliveryCid <- create this with status = Settled
          pure (deliveryCid, adCids)

template SettlementInstruction
  with
    operator : Party
    agent : Party
    sender : Party
    receiver : Party
    signed : [Party]
    settlementId : Text
    instructionId : Text
    senderAccount : Account
    receiverAccount : Account
    asset : Asset
    depositCid : Optional (ContractId AssetDeposit)
  where
    signatory operator, signed
    observer agent, sender, receiver

    key (operator, settlementId, instructionId) : (Party, Text, Text)
    maintainer key._1

    controller sender can
      Allocate : ContractId SettlementInstruction
        with
          settlementDepositCid : ContractId AssetDeposit
        do
          deposit <- fetch settlementDepositCid
          deposit.asset === asset
          deposit.account === senderAccount
          depositCid <- Some <$> exercise settlementDepositCid AssetDeposit_SetObservers with newObservers = fromList [agent]
          create this with depositCid; signed = sender :: signed

    controller receiver can
      Sign : ContractId SettlementInstruction
        do
          create this with signed = receiver :: signed

    controller agent can
      SettleInstruction : ContractId AssetDeposit
        do
          case depositCid of
            Some cid -> exercise cid AssetDeposit_Transfer with receiverAccount
            None -> fail $ "Instruction [" <> instructionId <> "] of settlement [ " <> settlementId <> " ] is not allocated"

createInstructions : Bool -> Party -> Party -> Party -> Party -> Party -> Text -> Int -> Asset -> Update [ContractId SettlementInstruction]
createInstructions isCash operator agent rootProvider sender receiver settlementId instructionIdx asset = do
  (_, senderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, sender)
  (_, receiverSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiver)
  let
    createInstruction sending receiving sAcc rAcc siAsset instIdx = do
      let si = SettlementInstruction with operator; agent; sender = sending; receiver = receiving; settlementId; senderAccount = sAcc; receiverAccount = rAcc; asset = siAsset; signed = []; depositCid = None; instructionId = show instIdx
      if sending == receiving then pure [] else singleton <$> create si
    senderAccount =
      if isCash
      then fromSomeNote ("No cash account for party " <> partyToText sender <> " and asset " <> asset.id.label) senderSettlementInfo.cashAccount
      else fromSomeNote ("No securities account for party " <> partyToText sender <> " and asset " <> asset.id.label) senderSettlementInfo.securitiesAccount
    receiverAccount =
      if isCash
      then fromSomeNote ("No cash account for party " <> partyToText receiver <> " and asset " <> asset.id.label) receiverSettlementInfo.cashAccount
      else fromSomeNote ("No securities account for party " <> partyToText receiver <> " and asset " <> asset.id.label) receiverSettlementInfo.securitiesAccount
  if senderAccount.provider == rootProvider && receiverAccount.provider == rootProvider then do -- TODO: Could shortcut this if common custodian is found earlier below in the hierarchy
    createInstruction senderAccount.owner receiverAccount.owner senderAccount receiverAccount asset instructionIdx
  else if senderAccount.provider == rootProvider then do
    (_, providerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiverAccount.provider)
    sis1 <- createInstruction receiverAccount.provider receiverAccount.owner (fromSome providerSettlementInfo.ownAccount) receiverAccount (asset with id.signatories = fromList [providerSettlementInfo.party]) instructionIdx
    sis2 <- createInstructions isCash operator agent rootProvider sender receiverAccount.provider settlementId (instructionIdx + 1) asset
    pure $ sis1 <> sis2
  else if receiverAccount.provider == rootProvider then do
    (_, providerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, senderAccount.provider)
    sis1 <- createInstruction senderAccount.owner senderAccount.provider senderAccount (fromSome providerSettlementInfo.ownAccount) (asset with id.signatories = fromList [providerSettlementInfo.party]) instructionIdx
    sis2 <- createInstructions isCash operator agent rootProvider senderAccount.provider receiver settlementId (instructionIdx + 1) asset
    pure $ sis1 <> sis2
  else do
    (_, senderProviderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, senderAccount.provider)
    sis1 <- createInstruction senderAccount.owner senderAccount.provider senderAccount (fromSome senderProviderSettlementInfo.ownAccount) (asset with id.signatories = fromList [senderProviderSettlementInfo.party]) instructionIdx
    (_, receiverProviderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiverAccount.provider)
    sis2 <- createInstruction receiverAccount.provider receiverAccount.owner (fromSome receiverProviderSettlementInfo.ownAccount) receiverAccount (asset with id.signatories = fromList [receiverProviderSettlementInfo.party]) (instructionIdx + 1)
    sis3 <- createInstructions isCash operator agent rootProvider senderAccount.provider receiverAccount.provider settlementId (instructionIdx + 2) asset
    pure $ sis1 <> sis2 <> sis3

