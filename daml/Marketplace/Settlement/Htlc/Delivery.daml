module Marketplace.Settlement.Htlc.Delivery where

import DA.Assert ((===))
import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Types (Asset)
import DA.Text (sha256)
import Marketplace.Settlement.Htlc.Instruction qualified as Instruction

data HtlcState = Locked | Settled | Refunded
  deriving (Eq, Show)

template Delivery
  with
    operator : Party
    agent : Party
    sender : Party
    receiver : Party
    settlementId : Text
    instructionIds : [Text]
    asset : Asset
    status : HtlcState
    hashlock : Text
    expiry : Time
  where
    signatory operator
    observer agent

    key (operator, settlementId) : (Party, Text)
    maintainer key._1

    controller agent can
      Settle : (ContractId Delivery, [ContractId AssetDeposit])
        with
          secret : Text
        do
          time <- getTime
          assertMsg "Time lock has expired" (time < expiry)
          status === Locked
          hashlock === sha256 secret
          let
            settle (instructionId : Text) = do
              (siCid, si) <- fetchByKey @Instruction.Instruction (operator, settlementId, instructionId)
              si.settlementId === settlementId
              si.asset.id.label === asset.id.label
              si.asset.id.version === asset.id.version
              si.asset.quantity === asset.quantity
              exercise siCid Instruction.Settle with secret
          adCids <- mapA settle instructionIds
          deliveryCid <- create this with status = Settled
          pure (deliveryCid, adCids)

      Refund : (ContractId Delivery, [ContractId AssetDeposit])
        do
          time <- getTime
          assertMsg "Time lock has not expired" (time >= expiry)
          status === Locked
          let
            refund (instructionId : Text) = do
              (siCid, si) <- fetchByKey @Instruction.Instruction (operator, settlementId, instructionId)
              si.settlementId === settlementId
              si.asset.id.label === asset.id.label
              si.asset.id.version === asset.id.version
              si.asset.quantity === asset.quantity
              exercise siCid Instruction.Refund
          adCids <- mapA refund instructionIds
          deliveryCid <- create this with status = Refunded
          pure (deliveryCid, adCids)
