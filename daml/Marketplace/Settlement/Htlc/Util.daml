module Marketplace.Settlement.Htlc.Util where

import DA.Finance.Types (Asset, Account)
import DA.List (singleton)
import DA.Optional (fromSome)
import DA.Set (fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Settlement.Htlc.Instruction qualified as Instruction
import Marketplace.Settlement.Hierarchical.Util (getAccount)

data HtlcState = Locked | Settled | Refunded
  deriving (Eq, Show)

createInstructionsHtlc : Bool -> Party -> Party -> Party -> Account -> Party -> Account -> Text -> Int -> Asset -> Text -> Time -> Update [ContractId Instruction.T]
createInstructionsHtlc isCash operator rootProvider senderAgent senderAccount receiverAgent receiverAccount settlementId instructionIdx asset hashlock expiry = do
  let
    createInstructionHtlc sender receiver sAcc rAcc siAsset instIdx = do
      let si = Instruction.Instruction with operator; senderAgent; receiverAgent; sender; receiver; settlementId; senderAccount = sAcc; receiverAccount = rAcc; asset = siAsset; signed = []; depositCid = None; instructionId = show instIdx; hashlock; expiry
      if sender == receiver then pure [] else singleton <$> create si
  if senderAccount.provider == rootProvider && receiverAccount.provider == rootProvider then do -- TODO: Could shortcut this if common custodian is found earlier below in the hierarchy
    createInstructionHtlc senderAccount.owner receiverAccount.owner senderAccount receiverAccount asset instructionIdx
  else if senderAccount.provider == rootProvider then do
    (_, providerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiverAccount.provider)
    let providerAccount = getAccount isCash providerSettlementInfo receiverAccount.owner
    sis1 <- createInstructionHtlc receiverAccount.provider receiverAccount.owner (fromSome providerSettlementInfo.ownAccount) receiverAccount (asset with id.signatories = fromList [providerSettlementInfo.party]) instructionIdx
    sis2 <- createInstructionsHtlc isCash operator rootProvider senderAgent senderAccount receiverAgent providerAccount settlementId (instructionIdx + 1) asset hashlock expiry
    pure $ sis1 <> sis2
  else if receiverAccount.provider == rootProvider then do
    (_, providerSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, senderAccount.provider)
    let providerAccount = getAccount isCash providerSettlementInfo senderAccount.owner
    sis1 <- createInstructionHtlc senderAccount.owner senderAccount.provider senderAccount (fromSome providerSettlementInfo.ownAccount) (asset with id.signatories = fromList [providerSettlementInfo.party]) instructionIdx
    sis2 <- createInstructionsHtlc isCash operator rootProvider senderAgent providerAccount receiverAgent receiverAccount settlementId (instructionIdx + 1) asset hashlock expiry
    pure $ sis1 <> sis2
  else do
    (_, senderProviderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, senderAccount.provider)
    let senderProviderAccount = getAccount isCash senderProviderSettlementInfo senderAccount.owner
    sis1 <- createInstructionHtlc senderAccount.owner senderAccount.provider senderAccount (fromSome senderProviderSettlementInfo.ownAccount) (asset with id.signatories = fromList [senderProviderSettlementInfo.party]) instructionIdx
    (_, receiverProviderSettlementInfo) <- fetchByKey @Custody.SettlementInfo (operator, receiverAccount.provider)
    let receiverProviderAccount = getAccount isCash receiverProviderSettlementInfo receiverAccount.owner
    sis2 <- createInstructionHtlc receiverAccount.provider receiverAccount.owner (fromSome receiverProviderSettlementInfo.ownAccount) receiverAccount (asset with id.signatories = fromList [receiverProviderSettlementInfo.party]) (instructionIdx + 1)
    sis3 <- createInstructionsHtlc isCash operator rootProvider senderAgent senderProviderAccount receiverAgent receiverProviderAccount settlementId (instructionIdx + 2) asset hashlock expiry
    pure $ sis1 <> sis2 <> sis3

