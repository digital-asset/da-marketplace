module Marketplace.Settlement.Htlc.Dvp where

import DA.Assert ((===))
import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Types (Asset)
import DA.Text (sha256)
import Marketplace.Settlement.Htlc.Instruction (Instruction, RefundInstruction(..), SettleInstruction(..))
import Marketplace.Settlement.Htlc.Util (HtlcState(..))
import Marketplace.Settlement.Hierarchical.Util (SettlementMode)

template Dvp
  with
    operator : Party
    deliverer : Party
    payer : Party
    delivererAgent : Party
    payerAgent : Party
    settlementId : Text
    instructionIds : [Text]
    payment : Asset
    delivery : Asset
    status : HtlcState
    settlementMode : SettlementMode
    hashlock : Text
    expiry : Time
  where
    signatory operator
    observer deliverer, delivererAgent, payer, payerAgent

    key (operator, settlementId) : (Party, Text)
    maintainer key._1

    choice SettleDvp : (ContractId Dvp, [ContractId AssetDeposit])
      with
        secret : Text
      controller payerAgent
        do
          time <- getTime
          assertMsg "Time lock has expired" (time < expiry)
          status === Locked
          hashlock === sha256 secret
          let
            settle (instructionId : Text) = do
              (siCid, si) <- fetchByKey @Instruction (operator, settlementId, instructionId)
              si.settlementId === settlementId
              si.asset.id.label === delivery.id.label
              si.asset.id.version === delivery.id.version
              si.asset.quantity === delivery.quantity
              exercise siCid SettleInstruction with secret
          adCids <- mapA settle instructionIds
          tradeCid <- create this with status = Settled
          pure (tradeCid, adCids)

    choice Refund : (ContractId Dvp, [ContractId AssetDeposit])
      controller delivererAgent
        do
          time <- getTime
          assertMsg "Time lock has not expired" (time >= expiry)
          status === Locked
          let
            refund (instructionId : Text) = do
              (siCid, si) <- fetchByKey @Instruction (operator, settlementId, instructionId)
              si.settlementId === settlementId
              si.asset.id.label === delivery.id.label
              si.asset.id.version === delivery.id.version
              si.asset.quantity === delivery.quantity
              exercise siCid RefundInstruction
          adCids <- mapA refund instructionIds
          deliveryCid <- create this with status = Refunded
          pure (deliveryCid, adCids)

    choice CancelDvp : ContractId Dvp
      controller operator
      do
        create this with status = Cancelled
        
        