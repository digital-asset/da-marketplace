module Marketplace.Settlement.Hierarchical.Delivery where

import DA.Assert ((===))
import DA.Finance.Types (Asset)
import DA.Finance.Asset (AssetDeposit(..))
import DA.Optional (whenSome)
import Marketplace.Settlement.Hierarchical.Instruction (Instruction, SettleInstruction(..))
import Marketplace.Settlement.Hierarchical.Util (Status(..))
import SwiftMessage.Message

template Delivery
  with
    operator : Party
    agent : Party
    sender : Party
    receiver : Party
    settlementId : Text
    refIdOpt : Optional Text -- reference id for swift message
    instructionIds : [Text]
    asset : Asset
    status : Status
  where
    signatory operator
    observer agent

    key (operator, settlementId) : (Party, Text)
    maintainer key._1

    choice SettleDelivery : (ContractId Delivery, [ContractId AssetDeposit])
      controller agent
        do
          let
            settle (instructionId : Text) = do
              (siCid, si) <- fetchByKey @Instruction (operator, settlementId, instructionId)
              si.settlementId === settlementId
              si.asset.id.label === asset.id.label
              si.asset.id.version === asset.id.version
              si.asset.quantity === asset.quantity
              exercise siCid SettleInstruction
          adCids <- mapA settle instructionIds
          deliveryCid <- create this with status = Settled
          whenSome refIdOpt (\refId -> finalizeSwiftMessage (operator, refId, MT566_t))
          pure (deliveryCid, adCids)
