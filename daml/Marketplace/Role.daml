daml 1.2
module Marketplace.Role where

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types
import DA.List as L
import DA.Next.Set
import DA.Action

import Marketplace.Token
import Marketplace.Trading
import Marketplace.Utils


template UserSession
  with
    operator : Party
    user : Party
    role : Text
  where
    signatory user

    controller operator can
      UserSession_Ack : ()
        do
          let userKey = (operator, user)
          case role of
            "Custodian" -> do
              optCustodianInvitation <- lookupByKey @CustodianInvitation userKey
              optCustodian <- lookupByKey @Custodian userKey
              case (optCustodianInvitation, optCustodian) of
                (None, None) -> void $ exerciseByKey @Operator operator Operator_OnboardCustodian with custodian = user
                (Some custodianInvitationCid, Some custodianCid) -> archive custodianInvitationCid
                _ -> return ()
            "Issuer" -> do
              optIssuerInvitation <- lookupByKey @IssuerInvitation userKey
              optIssuer <- lookupByKey @Issuer userKey
              case (optIssuerInvitation, optIssuer) of
                (None, None) -> void $ exerciseByKey @Operator operator Operator_OnboardIssuer with issuer = user
                (Some issuerInvitationCid, Some issuerCid) -> archive issuerInvitationCid
                _ -> return ()
            "Exchange" -> do
              optExchangeInvitation <- lookupByKey @ExchangeInvitation userKey
              optExchange <- lookupByKey @Exchange userKey
              case (optExchangeInvitation, optExchange) of
                (None, None) -> void $ exerciseByKey @Operator operator Operator_OnboardExchange with exchange = user
                (Some exchangeInvitationCid, Some exchangeCid) -> archive exchangeInvitationCid
                _ -> return ()
            "Broker" -> do
              optBrokerInvitation <- lookupByKey @BrokerInvitation userKey
              optBroker <- lookupByKey @Broker userKey
              case (optBrokerInvitation, optBroker) of
                (None, None) -> void $ exerciseByKey @Operator operator Operator_OnboardBroker with broker = user
                (Some brokerInvitationCid, Some brokerCid) -> archive brokerInvitationCid
                _ -> return ()
            "Investor" -> do
              optInvestorInvitation <- lookupByKey @InvestorInvitation userKey
              optInvestor <- lookupByKey @Investor userKey
              case (optInvestorInvitation, optInvestor) of
                (None, None) -> void $ exerciseByKey @Operator operator Operator_OnboardInvestor with investor = user
                (Some investorInvitationCid, Some investorCid) -> archive investorInvitationCid
                _ -> return ()
            _ -> return ()


template Operator
  with
    operator : Party
    public : Party
  where
    signatory operator

    key operator : Party
    maintainer key

    controller operator can
      nonconsuming Operator_OnboardCustodian : ContractId CustodianInvitation
        with
          custodian : Party
        do
          create CustodianInvitation with ..

      nonconsuming Operator_OnboardIssuer : ContractId IssuerInvitation
        with
          issuer : Party
        do
          create IssuerInvitation with ..

      nonconsuming Operator_OnboardInvestor : ContractId InvestorInvitation
        with
          investor : Party
        do
          create InvestorInvitation with ..

      nonconsuming Operator_OnboardBroker : ContractId BrokerInvitation
        with
          broker : Party
        do
          create BrokerInvitation with ..

      nonconsuming Operator_OnboardExchange : ContractId ExchangeInvitation
        with
          exchange : Party
        do
          create ExchangeInvitation with ..


template RegisteredCustodian
  with
    operator : Party
    public : Party
    custodian : Party
  where
    signatory operator, custodian
    observer public

    key (operator, custodian) : (Party, Party)
    maintainer key._2

    controller operator can
      RegisteredCustodian_Offboard : ()
        do return ()


template RegisteredIssuer
  with
    operator : Party
    public : Party
    issuer : Party
  where
    signatory operator, issuer
    observer public

    key (operator, issuer) : (Party, Party)
    maintainer key._2

    controller operator can
      RegisteredIssuer_Offboard : ()
        do return ()


template RegisteredInvestor
  with
    operator : Party
    public : Party
    investor : Party
    isPublic : Bool
  where
    signatory operator, investor
    observer if isPublic then [public] else []

    key (operator, investor) : (Party, Party)
    maintainer key._2

    controller operator can
      RegisteredInvestor_Offboard : ()
        do return ()


template RegisteredExchange
  with
    operator : Party
    public : Party
    exchange : Party
  where
    signatory operator, exchange
    observer public

    key (operator, exchange) : (Party, Party)
    maintainer key._2

    controller operator can
      RegisteredExchange_Offboard : ()
        do return ()


template InvestorInvitation
  with
    operator : Party
    investor : Party
    public : Party
  where
    signatory operator

    key (operator, investor) : (Party, Party)
    maintainer key._1

    controller investor can
      InvestorInvitation_Accept : ContractId Investor
        with
          isPublic : Bool
        do
          create RegisteredInvestor with ..
          create Investor with ..


template Investor
  with
   operator : Party
   investor : Party
   isPublic : Bool
   public : Party
  where
    signatory operator, investor

    key (operator, investor) : (Party, Party)
    maintainer key._1

    controller investor can
      nonconsuming Investor_RequestCustodianRelationship : ContractId CustodianRelationshipRequest
        with
          custodian : Party
        do create CustodianRelationshipRequest with requester = investor, role = "Investor", ..

      nonconsuming Investor_RequestBrokerRelationship : ContractId BrokerRelationshipRequest
        with
          broker : Party
        do create BrokerRelationshipRequest with requester = investor, ..

      nonconsuming Investor_TransferTo : ContractId AssetDeposit
        with
          receiver : Party
          depositCid : ContractId AssetDeposit
        do
          deposit <- fetch depositCid
          assertMsg "Can only transfer deposits on main account"
            $ deposit.account.id.label == getAccountLabel investor deposit.account.provider
          (senderRuleCid, senderRule) <- fetchByKey @AssetSettlementRule deposit.account.id
          let receiverAccountId = getAccountId receiver deposit.account.provider [deposit.account.provider]
          (receiverRuleCid, receiverRule) <- fetchByKey @AssetSettlementRule receiverAccountId
          exercise senderRuleCid AssetSettlement_Transfer with ..

      nonconsuming Investor_AllocateToExchange : ContractId AssetDeposit
        with
          exchange : Party
          depositCid : ContractId AssetDeposit
        do
          deposit <- fetch depositCid
          (senderRuleCid, senderRule) <- fetchByKey @AssetSettlementRule deposit.account.id
          let exchangeAccountId = getAccountId investor exchange [deposit.account.provider]
          (exchangeAccountCid, exchangeAccount) <- fetchByKey @AssetSettlementRule exchangeAccountId
          exercise senderRuleCid AssetSettlement_Transfer with receiverAccountId = exchangeAccountId, ..

template BrokerInvitation
  with
    operator : Party
    broker : Party
  where
    signatory operator

    key (operator, broker) : (Party, Party)
    maintainer key._1

    controller broker can
      BrokerInvitation_Accept : ContractId Broker
        do create Broker with ..

template Broker
  with
    operator : Party
    broker : Party
  where
    signatory operator, broker

    key (operator, broker) : (Party, Party)
    maintainer key._1

    controller broker can
      nonconsuming Broker_RequestCustodianRelationship : ContractId CustodianRelationshipRequest
        with
          custodian : Party
        do create CustodianRelationshipRequest with requester = broker, role = "Broker", ..

template BrokerRelationshipRequest
  with
    operator : Party
    requester : Party
    broker : Party
  where
    signatory operator, requester

    controller broker can
      BrokerRelationshipRequest_Accept : ContractId BrokerInvestorRelationship
        do create BrokerInvestorRelationship with investor = requester, ..

      BrokerRelationshipRequest_Reject : ()
        do return ()

template BrokerInvestorRelationship
  with
    operator : Party
    broker : Party
    investor : Party
  where
    signatory broker

    key (broker, investor) : (Party, Party)
    maintainer key._1

    controller investor can
      BrokerInvestorRelationship_PlaceBid : ContractId OrderRequest
        with
          exchange : Party
          depositCid : ContractId AssetDeposit
          pair : TokenPair
          price : Decimal
        do
          (exchParticipantCid, exchParticipant) <- fetchByKey @ExchangeParticipant (exchange, operator, broker)
          exercise exchParticipantCid ExchangeParticipant_PlaceBid with ..


template ExchangeInvitation
  with
    operator : Party
    exchange : Party
    public : Party
  where
    signatory operator

    key (operator, exchange) : (Party, Party)
    maintainer key._1

    controller exchange can
      ExchangeInvitation_Accept : ContractId Exchange
        do
          create RegisteredExchange with ..
          create Exchange with tokenPairs = [], participants = [], ..


template Exchange
  with
    operator : Party
    exchange : Party
    public : Party
    tokenPairs : [TokenPair] -- tokens pairs that are tradable on the exchange
    participants : [Party]
  where
    signatory operator, exchange

    key (operator, exchange) : (Party, Party)
    maintainer key._1

    observer participants

    controller exchange can
      nonconsuming Exchange_RequestCustodianRelationship : ContractId CustodianRelationshipRequest
        with
          custodian : Party
        do create CustodianRelationshipRequest with requester = exchange, role = "Exchange", ..

      Exchange_InviteParticipant : (ContractId Exchange, ContractId ExchangeParticipantInvitation)
        with
          exchParticipant : Party
        do
          participantInvitationCid <- create ExchangeParticipantInvitation with ..
          exchangeCid <- create this with participants = dedup $ exchParticipant :: participants
          return (exchangeCid, participantInvitationCid)

      Exchange_AddPair : ContractId Exchange
        with
          baseTokenId : Id
          quoteTokenId : Id
        do
          (_, baseToken) <- fetchByKey @Token baseTokenId
          (_, quoteToken) <- fetchByKey @Token quoteTokenId
          assertMsg "Pair must have different base and quote tokens" $ baseToken.id.label /= quoteToken.id.label
          create this with tokenPairs = dedup $ (baseTokenId, quoteTokenId) :: tokenPairs


template ExchangeParticipantInvitation
  with
    operator : Party
    exchange : Party
    exchParticipant : Party
  where
    signatory exchange

    controller exchParticipant can
      ExchangeParticipantInvitation_Accept : ContractId ExchangeParticipant
        do create ExchangeParticipant with ..


template ExchangeParticipant
  with
    operator : Party
    exchange : Party
    exchParticipant : Party
  where
    signatory exchange, exchParticipant

    key (exchange, operator, exchParticipant) : (Party, Party, Party)
    maintainer key._1

    controller exchParticipant can
      nonconsuming ExchangeParticipant_PlaceBid : ContractId OrderRequest
        with
          depositCid : ContractId AssetDeposit
          pair : TokenPair
          price : Decimal
        do
          deposit <- fetch depositCid
          (exchangeCid, exchangeCdata) <- fetchByKey @Exchange (operator, exchange)
          assertMsg "deposit is not allocated to the exchange"
            $ deposit.account.id.label == getAccountLabel exchParticipant exchange
          assertMsg ("pair " <> pair._1.label <> "/" <> pair._2.label <> " is not supported by exchange")
            $ pair `elem` exchangeCdata.tokenPairs
          assertMsg ("deposit should be for " <> pair._2.label <> " but it is for " <> deposit.asset.id.label)
            $ pair._2 == deposit.asset.id
          (_, quoteToken) <- fetchByKey @Token pair._2
          assertMsg ("price should be rounded to at most " <> show quoteToken.quantityPrecision <> " decimal places")
            $ roundBankers quoteToken.quantityPrecision price == price
          (_, baseToken) <- fetchByKey @Token pair._1
          let qty = roundBankers baseToken.quantityPrecision $ deposit.asset.quantity / price
              order = Order with isBid = True, status = "New", orderId = -1, ..
          create OrderRequest with ..

      nonconsuming ExchangeParticipant_PlaceOffer : ContractId OrderRequest
        with
          depositCid : ContractId AssetDeposit
          pair : TokenPair
          price : Decimal
        do
          deposit <- fetch depositCid
          (exchangeCid, exchangeCdata) <- fetchByKey @Exchange (operator, exchange)
          assertMsg "deposit is not allocated to the exchange"
            $ deposit.account.id.label == getAccountLabel exchParticipant exchange
          assertMsg ("pair " <> pair._1.label <> "/" <> pair._2.label <> " is not supported by exchange")
            $ pair `elem` exchangeCdata.tokenPairs
          assertMsg ("deposit should be for " <> pair._1.label <> " but it is for " <> deposit.asset.id.label)
            $ pair._1 == deposit.asset.id
          (_, quoteToken) <- fetchByKey @Token pair._2
          assertMsg ("price should be rounded to at most " <> show quoteToken.quantityPrecision <> " decimal places")
            $ roundBankers quoteToken.quantityPrecision price == price
          (_, baseToken) <- fetchByKey @Token pair._1
          let qty = roundBankers baseToken.quantityPrecision deposit.asset.quantity
              order = Order with isBid = False, status = "New", orderId = -1, ..
          create OrderRequest with ..


template IssuerInvitation
  with
    operator : Party
    issuer : Party
    public : Party
  where
    signatory operator

    key (operator, issuer) : (Party, Party)
    maintainer key._1

    controller issuer can
      IssuerInvitation_Accept : ContractId Issuer
        do
          create RegisteredIssuer with ..
          create Issuer with ..


template Issuer
  with
    operator : Party
    issuer : Party
    public : Party
  where
    signatory operator, issuer

    key (operator, issuer) : (Party, Party)
    maintainer key._1

    controller issuer can
      nonconsuming Issuer_IssueToken : ContractId Token
        with
          name : Text
          quantityPrecision : Int
        do
          let tokenId = Id with signatories = fromList [issuer], label = name, version = 0
          create Token with id = tokenId, observers = fromList [public], ..

      nonconsuming Issuer_RequestCustodianRelationship : ContractId CustodianRelationshipRequest
        with
          custodian : Party
        do create CustodianRelationshipRequest with requester = issuer, role = "Issuer", ..


template CustodianRelationshipRequest
  with
    operator : Party
    requester : Party
    custodian : Party
    role : Text
  where
    signatory operator, requester

    controller custodian can
      CustodianRelationshipRequest_Approve : ()
        do
          case role of
            "Issuer" -> void $ exerciseByKey @Custodian (operator, custodian) Custodian_AddIssuer with issuer = requester
            "Exchange" -> void $ exerciseByKey @Custodian (operator, custodian) Custodian_AddExchange with exchange = requester
            "Investor" -> void $ exerciseByKey @Custodian (operator, custodian) Custodian_AddInvestor with investor = requester
            "Broker" -> void $ exerciseByKey @Custodian (operator, custodian) Custodian_AddBroker with broker = requester
            _ -> abort $ "Unknown role type: " <> role

      CustodianRelationshipRequest_Reject : ()
        do return ()


template CustodianInvitation
  with
    operator : Party
    custodian : Party
    public : Party
  where
    signatory operator

    key (operator, custodian) : (Party, Party)
    maintainer key._1

    controller custodian can
      CustodianInvitation_Accept : ContractId Custodian
        do
          create RegisteredCustodian with ..
          create Custodian with investors = [], brokers = [], exchanges = [], issuers = [], ..


template Custodian
  with
    operator : Party
    custodian : Party
    issuers  : [Party]
    investors : [Party]
    brokers : [Party]
    exchanges : [Party]
  where
    signatory operator, custodian

    key (operator, custodian) :  (Party, Party)
    maintainer key._1

    controller custodian can
      Custodian_AddIssuer : ContractId Custodian
        with
          issuer : Party
        do
          assertMsg ("Issuer " <> show issuer <> " already exists") $ issuer `notElem` issuers
          create this with issuers = issuer :: issuers

      Custodian_AddExchange : ContractId Custodian
        with
          exchange : Party
        do
          assertMsg ("Exchange " <> show exchange <> " already exists") $ exchange `notElem` exchanges
          create this with exchanges = exchange :: exchanges

      Custodian_AddBroker : ContractId Custodian
        with
          broker : Party
        do
          assertMsg ("Broker " <> show broker <> " already exists") $ broker `notElem` brokers
          create this with brokers = broker :: brokers

      Custodian_AddInvestor : ContractId Custodian
        with
          investor : Party
        do
          assertMsg ("Investor " <> show investor <> " already exists") $ investor `notElem` investors
          create this with investors = investor :: investors

      nonconsuming GetAccount : Account
        with
          investor : Party
        do
          let accountId = getAccountId investor custodian [custodian]
          return Account with id = accountId, provider = custodian, owner = investor

      nonconsuming CreateDeposit : ContractId AssetDeposit
        with
          tokenId : Id
          depositQuantity : Decimal
          beneficiary : Party
        do
          (tokenCid, token) <- fetchByKey @Token tokenId
          let quantity = roundBankers token.quantityPrecision depositQuantity
              asset = Asset with id = tokenId, ..
              depositObs = fromList $ beneficiary :: signatory token
          account <- exercise self GetAccount with investor = beneficiary
          create AssetDeposit with observers = depositObs, account = account, ..

      nonconsuming UpdateAssetSettlementRules : [ContractId AssetSettlementRule]
        do
          custodianAccounts <- mapA (\u -> do
            let accountId = getAccountId u custodian [custodian]
                account = Account with id = accountId, provider = custodian, owner = u
            optAssetRuleCid <- lookupByKey @AssetSettlementRule accountId
            case optAssetRuleCid of
              None -> create AssetSettlementRule with observers = fromList investors,  ctrls = fromList $ L.filter (/= u) investors, ..
              Some ruleCid -> do
                archive ruleCid
                create AssetSettlementRule with observers = fromList investors, ctrls = fromList $ L.filter (/= u) investors, ..) investors
          exchangeAccounts <- mapA (\e -> do
            mapA (\u -> do
              let accountId = getAccountId u e [custodian]
                  account = Account with id = accountId, provider = custodian, owner = u
              optAssetRuleCid <- lookupByKey @AssetSettlementRule accountId
              case optAssetRuleCid of
                None -> create AssetSettlementRule with observers = fromList [u, custodian, e], ctrls = fromList investors, ..
                Some ruleCid -> return ruleCid) investors) exchanges
          return $ custodianAccounts ++ concat exchangeAccounts
