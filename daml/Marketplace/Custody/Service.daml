module Marketplace.Custody.Service where

import DA.Finance.Asset
import DA.Finance.Types
import DA.Finance.Utils (fetchAndArchive)
import DA.Set qualified as Set
import DA.Text qualified as Text
import DA.Map qualified as M
import DA.Set (empty, fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Utils

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    controller customer can

      nonconsuming RequestOpenAccount : ContractId Custody.OpenAccountRequest
        with
          label : Text
        do
          assertMsg "Account label cannot be empty" $ label /= ""
          create Custody.OpenAccountRequest with ..

      nonconsuming RequestDeposit : ContractId Custody.DepositRequest
        with
          asset : Asset
          account : Account
          depositChannel: Custody.Channel
        do
          create Custody.DepositRequest with ..

      nonconsuming RequestWithdrawal : ContractId Custody.WithdrawalRequest
        with
          depositCid : ContractId AssetDeposit
          withdrawalChannel: Custody.Channel
        do
          create Custody.WithdrawalRequest with ..

    controller provider can

      nonconsuming OpenAccount : ContractId Custody.AccountInfo
        with
          requestCid : ContractId Custody.OpenAccountRequest
        do
          Custody.OpenAccountRequest{label} <- fetchAndArchive requestCid
          let account = Account with id = (Id with signatories = fromList [provider, customer]; label; version = 0); provider; owner = customer
          create Custody.AccountInfo with operator; account

      nonconsuming CloseAccount : ()
        with
          requestCid : ContractId Custody.CloseAccountRequest
        do
          Custody.CloseAccountRequest{accountInfoCid, settlementInfoCid} <- fetchAndArchive requestCid
          accountInfo <- fetch accountInfoCid
          settlementInfo <- fetch settlementInfoCid
          assertMsg "Cannot close account used as own settlement account" $ Some accountInfo.account /= settlementInfo.ownAccount
          assertMsg "Cannot close account used as omnibus cash settlement account" $ Some accountInfo.account /= settlementInfo.omnibusCashAccount
          assertMsg "Cannot close account used as omnibus securities settlement account" $ Some accountInfo.account /= settlementInfo.omnibusSecuritiesAccount
          assertMsg "Cannot close account used as cash settlement account" $ notElem accountInfo.account (M.values settlementInfo.cashAccounts)
          assertMsg "Cannot close account used as securities settlement account" $ notElem accountInfo.account (M.values settlementInfo.securitiesAccounts)
          archive accountInfoCid

      nonconsuming Deposit : ContractId AssetDeposit
        with
          depositRequestCid : ContractId Custody.DepositRequest
        do
          Custody.DepositRequest{asset, account, depositChannel} <- fetchAndArchive depositRequestCid
          assertMsg "only handle onledger deposit request" (depositChannel == Custody.ONLEDGER)
          create AssetDeposit with asset; account; lockers = empty; observers = empty --fromList [ issuer ]

      nonconsuming ExternalDeposit : (ContractId AssetDeposit, ContractId Custody.DepositConfirmed)
        with
          depositRequestAcknowledgedCid:  ContractId Custody.DepositRequestAcknowledged
        do
          Custody.DepositRequestAcknowledged{asset, account, depositChannel, referenceId} <- fetchAndArchive depositRequestAcknowledgedCid
          assetDepsositCid <- create AssetDeposit with asset; account; lockers = empty; observers = empty
          confirmedCid <- create Custody.DepositConfirmed with ..
          return (assetDepsositCid, confirmedCid)

      nonconsuming Withdrawal : ()
        with
          withdrawalRequestCid : ContractId Custody.WithdrawalRequest
        do
          Custody.WithdrawalRequest{depositCid, withdrawalChannel} <- fetchAndArchive withdrawalRequestCid
          assertMsg "only handle onledger deposit request" (withdrawalChannel == Custody.ONLEDGER)
          deposit <- fetch depositCid
          assertMsg "Deposit account provider and service provider do not match" $ deposit.account.provider == provider

          archive depositCid

      nonconsuming ExternalWithdrawal : ContractId Custody.WithdrawalConfirmed
        with
          withdrawalRequestAcknowledgedCid : ContractId Custody.WithdrawalRequestAcknowledged
        do
          Custody.WithdrawalRequestAcknowledged{depositCid, referenceId, withdrawalChannel} <- fetchAndArchive withdrawalRequestAcknowledgedCid
          deposit <- fetch depositCid
          assertMsg "Deposit account provider and service provider do not match" $ deposit.account.provider == provider
          archive depositCid
          create Custody.WithdrawalConfirmed with ..

    choice Terminate : ()
      with
        ctrl : Party
      controller ctrl 
      do
        let ctrls = [operator, provider, customer]
        assertMsg (Text.intercalate "," $ map partyToText ctrls) (ctrl `Set.member` Set.fromList ctrls)
        

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        do
          let account = createAccount provider customer
          createOrLookup Service with ..

      Decline : ()
        do pure ()

    controller provider can
      Withdraw : ()
        do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    controller customer can
      Cancel : ()
        do pure ()

    controller provider can
      Reject : ()
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        let account = createAccount provider customer
        createOrLookup Service with ..
