module Marketplace.Custody.Service where

import DA.Finance.Asset
import DA.Finance.Types
import DA.Finance.Utils (fetchAndArchive)
import DA.Set qualified as Set
import DA.Text qualified as Text
import DA.Map qualified as M
import DA.Set (empty, fromList)
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Utils

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice RequestOpenAccount : ContractId Custody.OpenAccountRequest
      with
        label : Text
      controller customer
        do
          assertMsg "Account label cannot be empty" $ label /= ""
          create Custody.OpenAccountRequest with ..

    nonconsuming choice RequestDeposit : ContractId Custody.DepositRequest
      with
        asset : Asset
        account : Account
        depositChannel: Custody.Channel
      controller customer
        do
          create Custody.DepositRequest with ..

    nonconsuming choice RequestWithdrawal : ContractId Custody.WithdrawalRequest
      with
        depositCid : ContractId AssetDeposit
        withdrawalChannel: Custody.Channel
      controller customer
        do
          create Custody.WithdrawalRequest with ..

    nonconsuming choice OpenAccount : ContractId Custody.AccountInfo
      with
        requestCid : ContractId Custody.OpenAccountRequest
      controller provider
        do
          Custody.OpenAccountRequest{label} <- fetchAndArchive requestCid
          let account = Account with id = (Id with signatories = fromList [provider, customer]; label; version = 0); provider; owner = customer
          create Custody.AccountInfo with operator; account

    nonconsuming choice CloseAccount : ()
      with
        requestCid : ContractId Custody.CloseAccountRequest
      controller provider
        do
          Custody.CloseAccountRequest{accountInfoCid, settlementInfoCid} <- fetchAndArchive requestCid
          accountInfo <- fetch accountInfoCid
          settlementInfo <- fetch settlementInfoCid
          assertMsg "Cannot close account used as own settlement account" $ Some accountInfo.account /= settlementInfo.ownAccount
          assertMsg "Cannot close account used as omnibus cash settlement account" $ Some accountInfo.account /= settlementInfo.omnibusCashAccount
          assertMsg "Cannot close account used as omnibus securities settlement account" $ Some accountInfo.account /= settlementInfo.omnibusSecuritiesAccount
          assertMsg "Cannot close account used as cash settlement account" $ notElem accountInfo.account (M.values settlementInfo.cashAccounts)
          assertMsg "Cannot close account used as securities settlement account" $ notElem accountInfo.account (M.values settlementInfo.securitiesAccounts)
          archive accountInfoCid

    nonconsuming choice Deposit : ContractId AssetDeposit
      with
        depositRequestCid : ContractId Custody.DepositRequest
      controller provider
        do
          Custody.DepositRequest{asset, account, depositChannel} <- fetchAndArchive depositRequestCid
          assertMsg "only handle onledger deposit request" (depositChannel == Custody.ONLEDGER)
          create AssetDeposit with asset; account; lockers = empty; observers = empty --fromList [ issuer ]

    nonconsuming choice ExternalDeposit : (ContractId AssetDeposit, ContractId Custody.DepositConfirmed)
      with
        depositRequestAcknowledgedCid:  ContractId Custody.DepositRequestAcknowledged
      controller provider
        do
          Custody.DepositRequestAcknowledged{asset, account, depositChannel, referenceId} <- fetchAndArchive depositRequestAcknowledgedCid
          assetDepsositCid <- create AssetDeposit with asset; account; lockers = empty; observers = empty
          confirmedCid <- create Custody.DepositConfirmed with ..
          return (assetDepsositCid, confirmedCid)

    nonconsuming choice Withdrawal : ()
      with
        withdrawalRequestCid : ContractId Custody.WithdrawalRequest
      controller provider
        do
          Custody.WithdrawalRequest{depositCid, withdrawalChannel} <- fetchAndArchive withdrawalRequestCid
          assertMsg "only handle onledger deposit request" (withdrawalChannel == Custody.ONLEDGER)
          deposit <- fetch depositCid
          assertMsg "Deposit account provider and service provider do not match" $ deposit.account.provider == provider

          archive depositCid

    nonconsuming choice ExternalWithdrawal : ContractId Custody.WithdrawalConfirmed
      with
        withdrawalRequestAcknowledgedCid : ContractId Custody.WithdrawalRequestAcknowledged
      controller provider
        do
          Custody.WithdrawalRequestAcknowledged{depositCid, referenceId, withdrawalChannel} <- fetchAndArchive withdrawalRequestAcknowledgedCid
          deposit <- fetch depositCid
          assertMsg "Deposit account provider and service provider do not match" $ deposit.account.provider == provider
          archive depositCid
          create Custody.WithdrawalConfirmed with ..

    choice Terminate : ()
      with
        ctrl : Party
      controller ctrl 
      do
        let ctrls = [operator, provider, customer]
        assertMsg  ("Only " <> Text.intercalate "," (map partyToText ctrls) <> " are allowed to terminate") (ctrl `Set.member` Set.fromList ctrls)
        

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
        do
          let account = createAccount provider customer
          createOrLookup Service with ..

    choice Decline : ()
      controller customer
        do pure ()

    choice Withdraw : ()
      controller provider
        do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
        do pure ()

    choice Reject : ()
      controller provider
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        let account = createAccount provider customer
        createOrLookup Service with ..
