module Marketplace.Execution where

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types
import Marketplace.Trading.Service qualified as TradingService
import Marketplace.Trading.Order qualified as Order

-- TODO: Implement

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    controller customer can
      nonconsuming RequestCreateOrder : (ContractId TradingService.CreateOrderRequest, ContractId AssetDeposit)
        with
          orderDetails : Order.OrderDetails
          depositCid : ContractId AssetDeposit
        do
          -- TODO: Check that price and quantity conform to the precision requirements of the Listing
          depositCid <- exerciseByKey @AssetSettlementRule tradingAccount.id AssetSettlement_Transfer with receiverAccountId = allocationAccount.id; ..
          createOrderRequestCid <- create TradingService.CreateOrderRequest with ..
          pure (createOrderRequestCid, depositCid)

      nonconsuming RequestCancelOrder : ContractId TradingService.CancelOrderRequest
        with
          orderCid : ContractId Order.T
        do
          Order.Order{..} <- fetch orderCid
          create TradingService.CancelOrderRequest with ..

    controller provider can
      nonconsuming CreateOrder : ContractId Order.T
        with
          createOrderRequestCid : ContractId TradingService.CreateOrderRequest
          id : Int
        do
          let
            status = Order.New
            providerOrderId = None
            executionFills = []
          TradingService.CreateOrderRequest{..} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          create Order.Order with remainingQuantity = orderDetails.asset.quantity, ..

      nonconsuming CancelOrder : ContractId AssetDeposit
        with
          cancelOrderRequestCid : ContractId TradingService.CancelOrderRequest
        do
          TradingService.CancelOrderRequest{..} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          (orderCid, order@Order.Order{..}) <- fetchByKey (provider, orderDetails.id.label)
          archive orderCid

          orderCid <- create order with status = Order.Cancelled
          depositCid <- exerciseByKey @AssetSettlementRule allocationAccount.id AssetSettlement_Transfer with receiverAccountId = tradingAccount.id; ..

          exerciseByKey @AssetSettlementRule allocationAccount.id AssetSettlement_Transfer with depositCid = order.depositCid; receiverAccountId = tradingAccount.id

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        with
          tradingAccount : Account
          allocationAccount : Account
        do
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    customer : Party
    provider : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory operator, customer

    controller provider can
      Approve : ContractId Service
        do
          create Service with ..

      Reject : ()
        do
          return ()
