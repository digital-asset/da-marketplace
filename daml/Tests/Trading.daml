module Tests.Trading where

import Daml.Script
import DA.Optional
import DA.Finance.Types (Id(..), Asset(..))
import DA.Next.Set (fromList)
import Marketplace.Trading qualified as T
import DA.Finance.Asset (AssetDeposit)
import DA.List

-- In order to test between daml, the Exberry bot with simulating the Integration bot responses
-- 1/ "daml start" from root of da-marketplace
-- 2/ "daml deploy --host=localhost --port=6865" from root of daml-dit-integration-exberry
-- 3/ "poetry build && DAML_LEDGER_URL=localhost:6865 poetry run python bot/exberry_adapter_bot.py" from exberry_adapter folder in da-marketplace
-- 4/ "daml script --dar .daml/dist/da-marketplace-0.1.8.dar --script-name Tests.Trading:<function_name> --ledger-host localhost --ledger-port 6865" from root of da-marketplace
-- 5/ "daml repl --ledger-host=localhost --ledger-port=6865 .daml/dist/da-marketplace-0.1.8.dar ../daml-dit-integration-exberry/.daml/dist/dabl-integration-exberry-1.0.0.dar --import da-marketplace --import dabl-integration-exberry" from root of da-marketplace
--  a/ To get an existing party - Run in repl "exchange <- pure . fromSome $ partyFromText "Exchange""
--  b/ To execute a command to simulate the Integration bot (substituting values as necessary)
--    - New Order success : "exchange `submit` (createCmd $ NewOrderSuccess with integrationParty = exchange, sid = 123, orderId = 99999)"
--    - New Order failure : "exchange `submit` (createCmd $ NewOrderFailure with integrationParty = exchange, sid = 123, errorCode = 999, errorMessage = "oh dear, something wrong happened!")"
--    - Cancel Order success : "exchange `submit` (createCmd $ CancelOrderSuccess with integrationParty = exchange, sid = 123)"
--    - Cancel Order failure : "exchange `submit` (createCmd $ CancelOrderFailure with integrationParty = exchange, sid = 123, errorCode = 999, errorMessage = "oh dear, something wrong happened!")"
--    - Execution report : "exchange `submit` (createCmd $ ExecutionReport with integrationParty = exchange, sid = 1, eventId = 2, eventTimestamp = "beep", instrument = "JPM.N/USD", trackingNumber = 3, makerMpId = 1, makerMpOrderId = 123, makerOrderId = 321, takerMpId = 1, takerMpOrderId = 456, takerOrderId = 654, matchId = 123456, executedQuantity = 200.0, executedPrice = 100.0)"

getExistingParties : [Text] -> Script [Party]
getExistingParties = \parties -> pure . fromSome $ mapA partyFromText parties

newOrders : Script ()
newOrders = do
  -- Setup:Setup must be ran before running this script

  -- Get our parties
  [alice, bob, exchange, custodian, operator] <- getExistingParties ["Alice", "Bob", "Exchange", "Custodian", "Operator"]

  (aliceAssetDepositCid, aliceAssetDeposit) <- head <$> query @AssetDeposit alice
  (bobAssetDepositCid, bobAssetDeposit)     <- head <$> query @AssetDeposit bob

  -- Create Order Request
  let
    shareId = Id with signatories = fromList [ custodian ]; label = "JPM.N"; version = 0
    cashId = Id with signatories = fromList [ custodian ]; label = "USD"; version = 0
    shareAsset = Asset with id = shareId; quantity = 200.0
    cashAsset = Asset with id = cashId; quantity = 20000.0
    sharePriceAsset = Asset with id = shareId; quantity = 100.0
    cashPriceAsset = Asset with id = cashId; quantity = 100.0
    aliceOrderId = Id with signatories = fromList [ alice ]; label = "123"; version = 0
    aliceOrderDetails = T.OrderDetails with
      id = aliceOrderId
      market = "JPM.N/USD"
      asset = shareAsset
      side = T.Sell
      orderType = T.Limit with price = cashPriceAsset
      timeInForce = T.GTC
    bobOrderId = Id with signatories = fromList [ bob ]; label = "456"; version = 0
    bobOrderDetails = T.OrderDetails with
      id = bobOrderId
      market = "JPM.N/USD"
      asset = shareAsset
      side = T.Buy
      orderType = T.Limit with price = cashPriceAsset
      timeInForce = T.GTC
    tradingServicekey p = (operator, exchange, p)

  (aliceOrderCid, aliceOrderRequestCid, aliceAssetDepositCid) <- alice `submit` do
    exerciseByKeyCmd @T.Service (tradingServicekey alice) T.RequestCreateOrder with orderDetails = aliceOrderDetails, depositCid = aliceAssetDepositCid

  (bobOrderCid, bobOrderRequestCid, bobAssetDepositCid) <- bob `submit` do
    exerciseByKeyCmd @T.Service (tradingServicekey bob) T.RequestCreateOrder with orderDetails = bobOrderDetails, depositCid = bobAssetDepositCid

  pure ()

cancelSentOrder : Script ()
cancelSentOrder = do
  -- Note : Setup and newOrders must be run before this script

  [alice, exchange, operator] <- getExistingParties ["Alice", "Exchange", "Operator"]
  (aliceOrderCid, aliceOrder) <- head <$> query @T.Order alice

  (aliceOrderCid, aliceCancelOrderRequestCid) <- alice `submit` do
    exerciseByKeyCmd @T.Service (operator, exchange, alice) T.RequestCancelOrder with orderCid = aliceOrderCid

  pure ()
