module Tests.Trading.E2E where

import Daml.Script
import Common
import DA.List
import Marketplace.Trading.Model qualified as Order
import Marketplace.Trading.Service qualified as Trading
import Marketplace.Trading.Role qualified as Exchange
import Marketplace.Listing.Service qualified as Listing
import Marketplace.Listing.Model qualified as Listing
import Marketplace.Operator.Role qualified as Operator
import Prelude hiding (forA)

tradingEndToEndTest = script do
  parties@Parties{..} <- allocateParties
  providers@Providers{exchange; matchingServiceCid; bank; settlementServiceCid} <- onboardProviders parties

  alice <- onboardCustomer providers "Alice" alice
  bob <- onboardCustomer providers "Bob" bob
  issuer <- onboardCustomer providers "Issuer" issuer

  Assets{usd; tsla} <- onboardAssets providers issuer
  let
    shareAsset = tsla with quantity = 200.0
    cashAsset = usd with quantity = 20000.0
  aliceDepositCid <- depositAsset providers alice shareAsset alice.mainAccount.id
  bobDepositCid <- depositAsset providers bob cashAsset bob.mainAccount.id

  -- This is a problem: I shouldn't need to list a security to trade it OTC, so should it be
  -- part of the `Order` type?
  -- List a Security to trade
  (listingServiceCid, _) <- head <$> query @Listing.Service alice.customer
  let
    symbol = "TSLAUSD"
    listingType = Listing.CollateralizedRequest
    calendarId = "1261007448"
    description = "Tesla Inc."
    tradedAssetId = tsla.id
    quotedAssetId = usd.id
    tradedAssetPrecision = 2
    quotedAssetPrecision = 2
    minimumTradableQuantity = 1.0
    maximumTradableQuantity = 1000000.0
    providerId = "123"
    observers = []
  createListingRequestCid <- alice.customer `submit` do exerciseCmd listingServiceCid Listing.RequestCreateListing with ..
  listingCid <- exchange `submit` do exerciseCmd listingServiceCid Listing.CreateListing with ..

  -- Scenario 1 : Unilateral agreement between alice/bob i.e. bob is a broker
  -- ###########################################################################

  -- FIXME: Why this alternate naming of Trading/Exchange Service when they are the same? It's just confusing.
  bobExchangeRoleOfferCid <- submit providers.operator do exerciseCmd providers.operatorRoleCid Operator.OfferExchangeRole with provider = bob.customer
  (bobExecutionServiceRoleCid, _, _, _) <- submit bob.customer do exerciseCmd bobExchangeRoleOfferCid $ Exchange.Accept
  bobExecutionServiceOfferToAliceCid <- submit bob.customer do exerciseCmd bobExecutionServiceRoleCid Exchange.OfferTradingService with customer = alice.customer
  bobExecutionServiceCid <- submit alice.customer do exerciseCmd bobExecutionServiceOfferToAliceCid $ Trading.Accept

  aliceExchangeRoleOfferCid <- submit providers.operator do exerciseCmd providers.operatorRoleCid Operator.OfferExchangeRole with provider = alice.customer
  (aliceExecutionServiceRoleCid, _, _, _) <- submit alice.customer do exerciseCmd aliceExchangeRoleOfferCid $ Exchange.Accept
  aliceExecutionServiceOfferToAliceCid <- submit alice.customer do exerciseCmd aliceExecutionServiceRoleCid Exchange.OfferTradingService with customer = bob.customer
  aliceExecutionServiceCid <- submit bob.customer do exerciseCmd aliceExecutionServiceOfferToAliceCid $ Trading.Accept

  (Some Listing.Listing{listingId}) <- queryContractId @Listing.Listing exchange listingCid
  -- Create orders
  let aliceOrderId = "aliceClientBrokerOrder"
  aliceOrderReqCid <- submit alice.customer do
    exerciseCmd bobExecutionServiceCid $ Trading.RequestCreateOrder
      Order.Order with
        originator = alice.customer
        executor = bob.customer
        details = Order.Details with
            id = aliceOrderId
            listingId
            asset = shareAsset
            side = Order.Sell
            timeInForce = Order.GTC
            optExchangeFee = None
            price = 100.0
  (aliceOrderCid, aliceOrderStateCid) <- submit bob.customer do
    exerciseCmd aliceOrderReqCid Trading.AcknowledgeRequest

  Some Order.State{status=Order.PendingExecution} <- 
    queryContractId alice.customer aliceOrderStateCid

  let bobOrderId = "bobClientBrokerFill"
  submit bob.customer do 
    exerciseCmd aliceOrderCid $ Order.Fill with
        counterparty = bob.customer
        contraOrder = Order.Order with
            originator = bob.customer
            executor = alice.customer
            details = Order.Details with
                        id = bobOrderId
                        listingId
                        asset = shareAsset
                        side = Order.Buy
                        optExchangeFee = None
                        timeInForce = Order.GTC
                        price = 100.0

  Some (_, Order.State{status=Order.FullyExecuted}) <- queryContractKey alice.customer (bob.customer, aliceOrderId)

  -- Scenario 2 : Decentralised trading via public party
  -- ###########################################################################

  public <- allocateParty "public"
  
  publicExchangeRoleOfferCid <- submit providers.operator do exerciseCmd providers.operatorRoleCid Operator.OfferExchangeRole with provider = public
  (publicExecutionServiceRoleCid, _, _, _) <- submit public do exerciseCmd publicExchangeRoleOfferCid $ Exchange.Accept

  publicExecutionServiceOfferToAliceCid <- submit public do 
    exerciseCmd publicExecutionServiceRoleCid Exchange.OfferTradingService with customer = alice.customer
  publicExecutionServiceCid <- submit alice.customer do exerciseCmd publicExecutionServiceOfferToAliceCid $ Trading.Accept

  let aliceOrderId = "alicePublicOrder"
  (aliceOrderCid, _) <- submitMulti [alice.customer, public] [public] do
    exerciseCmd publicExecutionServiceCid $ Trading.CreateOrder
      Order.Order with
        originator = alice.customer
        executor = public
        details = Order.Details with
                    id = aliceOrderId
                    listingId
                    asset = shareAsset
                    side = Order.Sell
                    timeInForce = Order.GTC -- INFO Note that when creating a public order, it's likely you'll want to make it FoK. Otherwise it will be left with the executor, unfilled.
                    optExchangeFee = None
                    price = 100.0

  let bobOrderId = "bobPublicFill"
  submitMulti [bob.customer, public] [public] do
    exerciseCmd aliceOrderCid $ Order.Fill with
      counterparty = bob.customer
      contraOrder = Order.Order with
        originator = bob.customer
        executor = alice.customer
        details = Order.Details with
                    id = bobOrderId
                    listingId
                    asset = shareAsset
                    side = Order.Buy
                    optExchangeFee = None
                    timeInForce = Order.GTC
                    price = 100.0

  Some (_, Order.State{status=Order.FullyExecuted}) <- queryContractKey alice.customer (public, aliceOrderId)

  return ()
