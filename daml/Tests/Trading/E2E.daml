module Tests.Trading.E2E where

import Daml.Script
import Common
import DA.Assert ((===))
import DA.List
import Marketplace.Trading.Model qualified as Order
import Marketplace.Trading.Service qualified as Trading
import Marketplace.Trading.Role qualified as Exchange
import Marketplace.Listing.Service qualified as Listing
import Marketplace.Listing.Model qualified as Listing
import Marketplace.Operator.Role qualified as Operator

checkOrderStatusMatches : Order.OrderId -> Party -> Order.Status -> Script ()
checkOrderStatusMatches orderId party status = do
  Some (_, order) <- queryContractKey @Order.State party (party, orderId)
  order.status === status

tradingEndToEndTest = script do
  parties@Parties{..} <- allocateParties
  providers@Providers{exchange; matchingServiceCid; bank; settlementServiceCid} <- onboardProviders parties

  alice <- onboardCustomer providers "Alice" alice
  bob <- onboardCustomer providers "Bob" bob
  issuer <- onboardCustomer providers "Issuer" issuer

  Assets{usd; tsla} <- onboardAssets providers issuer
  let
    shareAsset = tsla with quantity = 200.0
    cashAsset = usd with quantity = 20000.0
  aliceDepositCid <- depositAsset providers alice shareAsset alice.mainAccount.id
  bobDepositCid <- depositAsset providers bob cashAsset bob.mainAccount.id

  -- This is a problem: I shouldn't need to list a security to trade it OTC, so should it be
  -- part of the `Order` type?
  -- List a Security to trade
  (listingServiceCid, _) <- head <$> query @Listing.Service alice.customer
  let
    symbol = "TSLAUSD"
    listingType = Listing.CollateralizedRequest
    calendarId = "1261007448"
    description = "Tesla Inc."
    tradedAssetId = tsla.id
    quotedAssetId = usd.id
    tradedAssetPrecision = 2
    quotedAssetPrecision = 2
    minimumTradableQuantity = 1.0
    maximumTradableQuantity = 1000000.0
    providerId = "123"
    observers = []
  createListingRequestCid <- alice.customer `submit` do exerciseCmd listingServiceCid Listing.RequestCreateListing with ..
  listingCid <- exchange `submit` do exerciseCmd listingServiceCid Listing.CreateListing with ..

  -- Scenario 1 : Bilateral (recpirocal service) agreement between alice/bob
  -- ###########################################################################

  -- FIXME: Why this alternate naming of Trading/Exchange Service when they are the same? It's just confusing.
  bobExchangeRoleOfferCid <- submit providers.operator do exerciseCmd providers.operatorRoleCid Operator.OfferExchangeRole with provider = bob.customer
  (bobExecutionServiceRoleCid, _, _, _) <- submit bob.customer do exerciseCmd bobExchangeRoleOfferCid $ Exchange.Accept
  bobExecutionServiceOfferToAliceCid <- submit bob.customer do exerciseCmd bobExecutionServiceRoleCid Exchange.OfferTradingService with customer = alice.customer
  bobExecutionServiceCid <- submit alice.customer do exerciseCmd bobExecutionServiceOfferToAliceCid $ Trading.Accept

  aliceExchangeRoleOfferCid <- submit providers.operator do exerciseCmd providers.operatorRoleCid Operator.OfferExchangeRole with provider = alice.customer
  (aliceExecutionServiceRoleCid, _, _, _) <- submit alice.customer do exerciseCmd aliceExchangeRoleOfferCid $ Exchange.Accept
  aliceExecutionServiceOfferToAliceCid <- submit alice.customer do exerciseCmd aliceExecutionServiceRoleCid Exchange.OfferTradingService with customer = bob.customer
  aliceExecutionServiceCid <- submit bob.customer do exerciseCmd aliceExecutionServiceOfferToAliceCid $ Trading.Accept

  (Some Listing.Listing{listingId}) <- queryContractId @Listing.Listing exchange listingCid
  -- Create orders
  let aliceOrderId = "1"
  aliceOrderReqCid <- submit alice.customer do
    exerciseCmd bobExecutionServiceCid $ Trading.RequestCreateOrder
      Order.Order with
        -- collateral = Order.Collateral aliceDepositCid
        originator = alice.customer
        executor = bob.customer
        details = Order.Details with
            id = aliceOrderId
            listingId
            asset = shareAsset
            side = Order.Sell
            timeInForce = Order.GTC
            optExchangeFee = None
            price = Some 100.0
  (aliceOrderCid, _) <- submit bob.customer do
    exerciseCmd aliceOrderReqCid Trading.AcknowledgeRequest with
      providerOrderId = "alice reference 1"

  Some (_, Order.State{status=Order.New}) <- 
    queryContractKey bob.customer (bob.customer, aliceOrderId)

  let bobOrderId = "2"
  submit bob.customer do 
    exerciseCmd aliceOrderCid $ Order.Fill Order.Order with
        originator = bob.customer
        executor = alice.customer
        details = Order.Details with
            id = bobOrderId
            listingId
            asset = shareAsset
            side = Order.Buy
            optExchangeFee = None
            timeInForce = Order.GTC
            price = Some 100.0

  Some (_, Order.State{status=Order.FullyExecuted}) <- queryContractKey alice.customer (bob.customer, aliceOrderId)
  return ()

  -- Settle orders
  {-assetDepositCids <- exchange `submit` exerciseCmd settlementInstructionCid Settlement.Settle

  forA_ assetDepositCids \depositCid -> do
    Some deposit <- queryContractId @AssetDeposit bank depositCid
    deposit.asset === if deposit.account.owner == alice.customer
      then cashAsset
      else shareAsset
-}
