{-# LANGUAGE ApplicativeDo #-}

module Tests.Trading.E2E where

import Daml.Script
import Common
import DA.List
import Marketplace.Trading.Model qualified as Order
import Marketplace.Trading.Service qualified as Trading
import Marketplace.Trading.Role qualified as Exchange
import Marketplace.Listing.Service qualified as Listing
import Marketplace.Listing.Model qualified as Listing
import Marketplace.Operator.Role qualified as Operator
import Prelude hiding (forA)

tradingEndToEndTest = script do
  parties@Parties{..} <- allocateParties
  providers@Providers{exchange; matchingServiceCid; bank; settlementServiceCid} <- onboardProviders parties

  alice <- onboardCustomer providers "Alice" alice
  bob <- onboardCustomer providers "Bob" bob
  issuer <- onboardCustomer providers "Issuer" issuer

  Assets{usd; tsla} <- onboardAssets providers issuer
  let
    shareAsset = tsla with quantity = 200.0
    cashAsset = usd with quantity = 20000.0
  aliceDepositCid <- depositAsset providers alice shareAsset alice.mainAccount.id
  bobDepositCid <- depositAsset providers bob cashAsset bob.mainAccount.id

  -- This is a problem: I shouldn't need to list a security to trade it OTC, so should it be
  -- part of the `Order` type?
  -- List a Security to trade
  (listingServiceCid, _) <- head <$> query @Listing.Service alice.customer
  let
    symbol = "TSLAUSD"
    listingType = Listing.CollateralizedRequest
    calendarId = "1261007448"
    description = "Tesla Inc."
    tradedAssetId = tsla.id
    quotedAssetId = usd.id
    tradedAssetPrecision = 2
    quotedAssetPrecision = 2
    minimumTradableQuantity = 1.0
    maximumTradableQuantity = 1000000.0
    providerId = "123"
    observers = []
  createListingRequestCid <- alice.customer `submit` do exerciseCmd listingServiceCid Listing.RequestCreateListing with ..
  listingCid <- exchange `submit` do exerciseCmd listingServiceCid Listing.CreateListing with ..

  -- Scenario 1 : Unilateral agreement between alice/bob i.e. bob is a broker
  -- ###########################################################################

  -- FIXME: Why this alternate naming of Trading/Exchange Service when they are the same? It's just confusing.
  bobExchangeRoleOfferCid <- submit providers.operator do exerciseCmd providers.operatorRoleCid Operator.OfferExchangeRole with provider = bob.customer
  (bobExecutionServiceRoleCid, _, _, _) <- submit bob.customer do exerciseCmd bobExchangeRoleOfferCid $ Exchange.Accept
  bobExecutionServiceOfferToAliceCid <- submit bob.customer do exerciseCmd bobExecutionServiceRoleCid Exchange.OfferTradingService with customer = alice.customer
  bobExecutionServiceCid <- submit alice.customer do exerciseCmd bobExecutionServiceOfferToAliceCid $ Trading.Accept

  (Some Listing.Listing{listingId}) <- queryContractId @Listing.Listing exchange listingCid
  -- Create orders
  let aliceOrderId = "aliceClientBrokerOrder"
  aliceOrderReqCid <- submit alice.customer do
    exerciseCmd bobExecutionServiceCid $ Trading.RequestCreateOrder
      Order.Order with
        originator = alice.customer
        executor = bob.customer
        id = aliceOrderId
        listingId
        asset = shareAsset
        side = Order.Sell
        timeInForce = Order.GTC
        price = 100.0
  (aliceOrderCid, aliceOrderStateCid) <- submit bob.customer do
    exerciseCmd aliceOrderReqCid Trading.AcknowledgeRequest

  Some Order.State{status=Order.PendingExecution} <- 
    queryContractId alice.customer aliceOrderStateCid

  let bobOrderId = "bobClientBrokerFill"
  submit bob.customer do 
    exerciseCmd aliceOrderCid $ Order.Fill with
        counterparty = bob.customer
        contraOrder = Order.Order with
            originator = bob.customer
            executor = alice.customer
            id = bobOrderId
            listingId
            asset = shareAsset
            side = Order.Buy
            timeInForce = Order.GTC
            price = 100.0

  Some (_, Order.State{status=Order.FullyExecuted}) <- queryContractKey alice.customer (bob.customer, aliceOrderId)

  -- Scenario 2 : Decentralised trading via public party
  -- ###########################################################################

  public <- allocateParty "public"
  
  publicExchangeRoleOfferCid <- submit providers.operator do exerciseCmd providers.operatorRoleCid Operator.OfferExchangeRole with provider = public
  (publicExecutionServiceRoleCid, _, _, _) <- submit public do exerciseCmd publicExchangeRoleOfferCid $ Exchange.Accept

  publicExecutionServiceOfferToAliceCid <- submit public do 
    exerciseCmd publicExecutionServiceRoleCid Exchange.OfferTradingService with customer = alice.customer
  publicExecutionServiceCid <- submit alice.customer do exerciseCmd publicExecutionServiceOfferToAliceCid $ Trading.Accept

  let aliceOrderId = "alicePublicOrder"
  (aliceOrderCid, _) <- submitMulti [alice.customer, public] [public] do
    exerciseCmd publicExecutionServiceCid $ Trading.CreateOrder
      Order.Order with
        originator = alice.customer
        executor = public
        id = aliceOrderId
        listingId
        asset = shareAsset
        side = Order.Sell
        timeInForce = Order.GTC -- INFO Note that when creating a public order, it's likely you'll want to make it FoK. Otherwise it will be left with the executor, unfilled.
        price = 100.0

  let bobOrderId = "bobPublicFill"
  submitMulti [bob.customer, public] [public] do
    exerciseCmd aliceOrderCid $ Order.Fill with
      counterparty = bob.customer
      contraOrder = Order.Order with
        originator = bob.customer
        executor = alice.customer -- TODO: note this doesn't match the other order's executor!
        id = bobOrderId
        listingId
        asset = shareAsset
        side = Order.Buy
        timeInForce = Order.GTC
        price = 100.0

  Some (_, Order.State{status=Order.FullyExecuted}) <- queryContractKey alice.customer (public, aliceOrderId)

  -- Scenario # 3 Novation via CCP
  -- ############################################################################

  ccp <- allocateParty "CCP"
  
  ccpExchangeRoleOfferCid <- submit providers.operator do exerciseCmd providers.operatorRoleCid Operator.OfferExchangeRole with provider = ccp
  (ccpExecutionServiceRoleCid, _, _, _) <- submit ccp do exerciseCmd ccpExchangeRoleOfferCid $ Exchange.Accept

  ccpExecutionServiceOfferToAliceCid <- submit ccp do 
    exerciseCmd ccpExecutionServiceRoleCid Exchange.OfferTradingService with customer = alice.customer
  aliceCcpExecutionServiceCid <- submit alice.customer do exerciseCmd ccpExecutionServiceOfferToAliceCid $ Trading.Accept

  ccpExecutionServiceOfferToBobCid <- submit ccp do 
    exerciseCmd ccpExecutionServiceRoleCid Exchange.OfferTradingService with customer = bob.customer
  bobCcpExecutionServiceCid <- submit bob.customer do exerciseCmd ccpExecutionServiceOfferToBobCid $ Trading.Accept

  let aliceOrderId = "aliceExchangeOrder"
  aliceOrderReqCid <- submit alice.customer do
    exerciseCmd aliceCcpExecutionServiceCid $ Trading.RequestCreateOrder
      Order.Order with
        originator = alice.customer
        executor = ccp
        id = aliceOrderId
        listingId
        asset = shareAsset
        side = Order.Sell
        timeInForce = Order.GTC
        price = 100.0

  (aliceOrderCid, aliceOrderStateCid) <- submit ccp do
    exerciseCmd aliceOrderReqCid Trading.AcknowledgeRequest

  let bobOrderId = "bobExchangeOrder"
  bobOrderReqCid <- submit bob.customer do
    exerciseCmd bobCcpExecutionServiceCid $ Trading.RequestCreateOrder
      Order.Order with
        originator = bob.customer
        executor = ccp
        id = bobOrderId
        listingId
        asset = shareAsset
        side = Order.Buy
        timeInForce = Order.GTC
        price = 100.0

  -- FIXME: novate in a single step, so that order is filled and Ack'd at the same time
  (bobOrderCid, bobOrderStateCid) <- submit ccp do 
    exerciseCmd bobOrderReqCid $ Trading.AcknowledgeRequest
  
  Some aliceOrder <- queryContractId ccp aliceOrderCid
  Some bobOrder <- queryContractId ccp bobOrderCid

  ((_, _, aliceOrderStateCid, _), (_, _, bobOrderStateCid, _)) <- submit ccp do
    b <- exerciseCmd bobOrderCid $ Order.Fill { counterparty = ccp, contraOrder = aliceOrder {originator = ccp , executor = bob.customer} }
    a <- exerciseCmd aliceOrderCid $ Order.Fill { counterparty = ccp, contraOrder = bobOrder {originator = ccp, executor = alice.customer} }
    return (a, b)
  
  Some Order.State{status=Order.FullyExecuted} <- queryContractId alice.customer aliceOrderStateCid
  Some Order.State{status=Order.FullyExecuted} <- queryContractId bob.customer bobOrderStateCid
  
  -- Scenario # 4 Inter-dealer broker
  -- ############################################################################

  -- We're re-using the services created above for this

  let aliceOrderId = "aliceAgencyOrder"
  aliceOrderReqCid <- submit alice.customer do
    exerciseCmd bobExecutionServiceCid $ Trading.RequestCreateOrder
      Order.Order with
        originator = alice.customer
        executor = bob.customer
        id = aliceOrderId
        listingId
        asset = shareAsset
        side = Order.Sell
        timeInForce = Order.GTC
        price = 100.0
  (aliceOrderCid, aliceOrderStateCid) <- submit bob.customer do
    exerciseCmd aliceOrderReqCid Trading.AcknowledgeRequest

  Some Order.State{status=Order.PendingExecution} <- 
    queryContractId alice.customer aliceOrderStateCid

  Some aliceOrder <- queryContractId bob.customer aliceOrderCid

  let bobOrderId = "bobAgencyOrder"
  bobOrderReqCid <- submit bob.customer do
    exerciseCmd bobCcpExecutionServiceCid $ Trading.RequestCreateOrder
      aliceOrder with originator = bob.customer, executor = ccp, id = bobOrderId

  (bobOrderCid, bobOrderStateCid) <- submit ccp do 
     exerciseCmd bobOrderReqCid $ Trading.AcknowledgeRequest

  -- FIXME : make the two fills atomic
  (_, _, bobOrderStateCid,_ ) <- submit ccp do 
    exerciseCmd bobOrderCid $ 
      Order.Fill with
        counterparty = ccp
        contraOrder = Order.Order with
          originator = ccp
          executor = bob.customer
          id = "CCP principal fill"
          listingId
          asset = shareAsset
          side = Order.Buy
          timeInForce = Order.GTC
          price = 100.0

  (_, _, aliceOrderStateCid, _) <- submit bob.customer do
     exerciseCmd aliceOrderCid $ 
      Order.Fill with
        counterparty = bob.customer
        contraOrder = Order.Order with
          originator = bob.customer
          executor = alice.customer
          id = "bob agency fill"
          listingId
          asset = shareAsset
          side = Order.Buy
          timeInForce = Order.GTC
          price = 100.0
   
  Some Order.State{status=Order.FullyExecuted} <- queryContractId bob.customer bobOrderStateCid
  Some Order.State{status=Order.FullyExecuted} <- queryContractId alice.customer aliceOrderStateCid

  return ()
