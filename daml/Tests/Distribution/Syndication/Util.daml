module Tests.Distribution.Syndication.Util where

import ContingentClaims.Claim (Claim, serialize)
import ContingentClaims.Observation (Observation)
import Daml.Script
import DA.Finance.Asset (AssetDeposit_Upgrade(..), AssetDeposit(..), AssetDeposit_Split(..), AssetDeposit_Merge(..))
import DA.Finance.Base.DayCount (DayCountConvention)
import DA.Finance.Base.HolidayCalendar (BusinessDayConventionEnum)
import DA.Finance.Base.RollConvention (PeriodEnum, RollConventionEnum)
import DA.Finance.Types (Asset(..), Id(..))
import DA.Foldable (mapA_, forA_)
import DA.List (head, dedup)
import DA.Optional (isNone, isSome, mapOptional)
import DA.Set (empty)
import Marketplace.Operator.Role qualified as Operator
import Marketplace.Custody.Role qualified as Custodian
import Marketplace.Custody.Service qualified as Custody
import Marketplace.Custody.Model qualified as Custody
import Marketplace.Issuance.AssetDescription (AssetDescription)
import Marketplace.Issuance.CFI qualified as CFI
import Marketplace.Issuance.Instrument.Model qualified as Instrument
import Marketplace.Issuance.Instrument.Service qualified as Instrument
import Marketplace.Issuance.Service qualified as Issuance
import Marketplace.Issuance.Role qualified as Issuer
import Marketplace.Distribution.Syndication.Bidding.Model qualified as Bidding
import Marketplace.Distribution.Syndication.Bidding.Service qualified as Bidding
import Marketplace.Distribution.Syndication.BookBuilding.Model qualified as BookBuilding
import Marketplace.Distribution.Syndication.BookBuilding.Service qualified as BookBuilding
import Marketplace.Distribution.Syndication.Structurer qualified as Structurer
import Marketplace.Distribution.Syndication.Distributor qualified as Distributor
import Marketplace.Distribution.Syndication.Investor qualified as Investor
import Marketplace.Distribution.Syndication.Structuring.Model qualified as Structuring
import Marketplace.Distribution.Syndication.Structuring.Service qualified as Structuring
import Marketplace.Lifecycle.Service qualified as Lifecycle
import Marketplace.Snapshot.Service qualified as Snapshot
import Marketplace.Reporting.Service qualified as Reporting
import Marketplace.Settlement.Hierarchical (SettlementInstruction, Allocate(..), Sign(..), Settle(..), Trade, Delivery, SettleDelivery(..), SettlementMode)
import Marketplace.Trading.Otc.Service qualified as Trading

createCustodianRole : Party -> Party -> Script (ContractId Custodian.Role, ContractId Custody.SettlementInfo)
createCustodianRole operator provider = do
  offerCid <- submit operator do exerciseByKeyCmd @Operator.Role operator Operator.OfferCustodianRole with provider
  submit provider do exerciseCmd offerCid Custodian.Accept

createCustodyService : Party -> Party -> Party -> Script (ContractId Custody.Service)
createCustodyService operator provider customer = do
  offerCid <- submit provider do exerciseByKeyCmd @Custodian.Role (operator, provider) Custodian.OfferCustodyService with ..
  submit customer do exerciseCmd offerCid Custody.Accept

createIssuanceService : Party -> Party -> Party -> Script (ContractId Issuance.Service)
createIssuanceService operator provider customer = do
  offerCid <- submit provider do exerciseByKeyCmd @Custodian.Role (operator, provider) Custodian.OfferIssuanceService with ..
  submit customer do exerciseCmd offerCid Issuance.Accept

createInstrumentService : Party -> Party -> Party -> Script (ContractId Instrument.Service)
createInstrumentService operator provider customer = do
  offerCid <- submit provider do exerciseByKeyCmd @Custodian.Role (operator, provider) Custodian.OfferInstrumentService with ..
  submit customer do exerciseCmd offerCid Instrument.Accept

createStructurerRole : Party -> Party -> Script (ContractId Structurer.Role)
createStructurerRole operator provider = do
  offerCid <- submit operator do exerciseByKeyCmd @Operator.Role operator Operator.OfferSyndicationStructurerRole with provider
  submit provider do exerciseCmd offerCid Structurer.Accept

createDistributorRole : Party -> Party -> Script (ContractId Distributor.Role)
createDistributorRole operator provider = do
  offerCid <- submit operator do exerciseByKeyCmd @Operator.Role operator Operator.OfferSyndicationDistributorRole with provider
  submit provider do exerciseCmd offerCid Distributor.Accept

createInvestorRole : Party -> Party -> Script (ContractId Investor.Role, ContractId Custody.SettlementInfo)
createInvestorRole operator investor = do
  offerCid <- submit operator do exerciseByKeyCmd @Operator.Role operator Operator.OfferInvestorRole with investor
  submit investor do exerciseCmd offerCid Investor.Accept

createIssuerRole : Party -> Party -> Script (ContractId Issuer.Role, ContractId Custody.SettlementInfo)
createIssuerRole operator issuer = do
  offerCid <- submit operator do exerciseByKeyCmd @Operator.Role operator Operator.OfferIssuerRole with issuer
  submit issuer do exerciseCmd offerCid Issuer.Accept

createStructuringService : Party -> Party -> Party -> Script (ContractId Structuring.Service)
createStructuringService operator provider customer = do
  offerCid <- submit provider do exerciseByKeyCmd @Structurer.Role (operator, provider) Structurer.OfferStructuringService with ..
  submit customer do exerciseCmd offerCid Structuring.Accept

createBookBuildingService : Party -> Party -> Party -> Script (ContractId BookBuilding.Service)
createBookBuildingService operator provider customer = do
  offerCid <- submit provider do exerciseByKeyCmd @Distributor.Role (operator, provider) Distributor.OfferBookBuildingService with ..
  submit customer do exerciseCmd offerCid BookBuilding.Accept

createBiddingService : Party -> Party -> Party -> Script (ContractId Bidding.Service)
createBiddingService operator provider customer = do
  offerCid <- submit provider do exerciseByKeyCmd @Distributor.Role (operator, provider) Distributor.OfferBiddingService with ..
  submit customer do exerciseCmd offerCid Bidding.Accept

createLifecycleService : Party -> Party -> Party -> Party -> Party -> Script (ContractId Lifecycle.Service)
createLifecycleService operator issuer bondRegistrar cashProvider payingAgent = do
  offerCid <- submit issuer do exerciseByKeyCmd @Issuer.Role (operator, issuer) Issuer.OfferLifecycleService with ..
  submit payingAgent do exerciseCmd offerCid Lifecycle.Accept

createSnapshotService : Party -> Party -> Script (ContractId Snapshot.Service)
createSnapshotService operator customer = do
  submit operator do createCmd Snapshot.Service with ..

createReportingService : Party -> Party -> Script (ContractId Reporting.Service)
createReportingService operator accountProvider = do
  submit operator do createCmd Reporting.Service with ..

createTradingService : Party -> Party -> Script (ContractId Trading.Service)
createTradingService operator customer  = do
  offerCid <- submit operator do exerciseByKeyCmd @Operator.Role operator Operator.OfferTradingService with ..
  submit customer do exerciseCmd offerCid Trading.Accept

openAccount : Party -> Party -> Party -> Text -> Script (ContractId Custody.AccountInfo)
openAccount operator provider customer label = do
  requestCid <- submit customer do exerciseByKeyCmd @Custody.Service (operator, provider, customer) Custody.RequestOpenAccount with label
  submit provider do exerciseByKeyCmd @Custody.Service (operator, provider, customer) Custody.OpenAccount with ..

setOmnibusCashAccount : Party -> Party -> ContractId Custody.AccountInfo -> Script (ContractId Custody.SettlementInfo)
setOmnibusCashAccount operator party accountInfoCid = do
  submit party do exerciseByKeyCmd @Custody.SettlementInfo (operator, party) Custody.SetOmnibusCashAccount with accountInfoCid

setOmnibusSecuritiesAccount : Party -> Party -> ContractId Custody.AccountInfo -> Script (ContractId Custody.SettlementInfo)
setOmnibusSecuritiesAccount operator party accountInfoCid = do
  submit party do exerciseByKeyCmd @Custody.SettlementInfo (operator, party) Custody.SetOmnibusSecuritiesAccount with accountInfoCid

setCashAccountForParty : Party -> Party -> Party -> ContractId Custody.AccountInfo -> Script (ContractId Custody.SettlementInfo)
setCashAccountForParty operator party beneficiary accountInfoCid = do
  submit party do exerciseByKeyCmd @Custody.SettlementInfo (operator, party) Custody.SetCashAccount with beneficiary; accountInfoCid

setSecuritiesAccountForParty : Party -> Party -> Party -> ContractId Custody.AccountInfo -> Script (ContractId Custody.SettlementInfo)
setSecuritiesAccountForParty operator party beneficiary accountInfoCid = do
  submit party do exerciseByKeyCmd @Custody.SettlementInfo (operator, party) Custody.SetSecuritiesAccount with beneficiary; accountInfoCid

originate : Party -> Party -> Party -> Party -> Text -> Claim Observation Date Decimal Id -> Script (ContractId AssetDescription, AssetDescription)
originate operator provider customer public assetLabel claims = do
  let
    cfi = CFI.other
    description = assetLabel
    observers = [public]
  createOriginationCid <- submit customer do exerciseByKeyCmd @Issuance.Service (operator, provider, customer) Issuance.RequestOrigination with claims = serialize claims; ..
  submit provider do exerciseByKeyCmd @Issuance.Service (operator, provider, customer) Issuance.Originate with createOriginationCid

createSchedule : Date -> Date -> PeriodEnum -> Int -> [Text] -> BusinessDayConventionEnum -> DayCountConvention -> RollConventionEnum -> Instrument.InterestSchedule
createSchedule startDate endDate period periodMultiplier calendarIds businessDayConvention dayCountConvention rollConvention =
  Instrument.InterestSchedule with ..

createFixedRateBond : Id -> Text -> Id -> Party -> Date -> Date -> Instrument.InterestSchedule -> Decimal -> Bool -> Bool -> Bool -> [Party] -> Instrument.Bond
createFixedRateBond id isin currencyId issuer issueDate maturityDate schedule annualRate isTradeable isPricedDirty isCallable observers =
  let
    amount = Instrument.Fixed with annualRate
    stream = Some Instrument.InterestStream with schedule; amount
  in Instrument.Bond with ..

createFloatingRateBond : Id -> Text -> Id -> Party -> Date -> Date -> Instrument.InterestSchedule -> Id -> Decimal -> Bool -> Bool -> Bool -> [Party] -> Instrument.Bond
createFloatingRateBond id isin currencyId issuer issueDate maturityDate schedule rateId periodSpread isTradeable isPricedDirty isCallable observers =
  let
    amount = Instrument.Float with rateId; periodSpread
    stream = Some Instrument.InterestStream with schedule; amount
  in Instrument.Bond with ..

createZeroCouponBond : Id -> Text -> Id -> Party -> Date -> Date -> Bool -> Bool -> Bool -> [Party] -> Instrument.Bond
createZeroCouponBond id isin currencyId issuer issueDate maturityDate isTradeable isPricedDirty isCallable observers =
  Instrument.Bond with stream = None; ..

createSwap : Id -> Id -> Id -> Party -> Date -> Date -> Instrument.InterestStream -> Instrument.InterestStream -> Bool -> [Party] -> Instrument.Swap
createSwap id payCurrencyId receiveCurrencyId issuer issueDate maturityDate pay receive isTradeable observers =
  Instrument.Swap with ..

originateBond : Party -> Party -> Party -> [Party] -> Instrument.Bond -> Script (AssetDescription, ContractId Instrument.Bond)
originateBond operator provider customer observers bond = do
  (requestCid, bondCid) <- submit customer do exerciseByKeyCmd @Instrument.Service (operator, provider, customer) Instrument.RequestBond with ..
  desc <- snd <$> submit provider do exerciseByKeyCmd @Issuance.Service (operator, provider, customer) Issuance.Originate with createOriginationCid = requestCid
  pure (desc, bondCid)

originateSwap : Party -> Party -> Party -> [Party] -> Instrument.Swap -> Script (AssetDescription, ContractId Instrument.Swap)
originateSwap operator provider customer observers swap = do
  (requestCid, swapCid) <- submit customer do exerciseByKeyCmd @Instrument.Service (operator, provider, customer) Instrument.RequestSwap with ..
  desc <- snd <$> submit provider do exerciseByKeyCmd @Issuance.Service (operator, provider, customer) Issuance.Originate with createOriginationCid = requestCid
  pure (desc, swapCid)

issue : Party -> Party -> Party -> Text -> ContractId Structuring.Tranche -> Script (ContractId AssetDeposit)
issue operator provider customer issuanceId trancheCid = do
  (_, Custody.AccountInfo{account}) <- head <$> queryFilter @Custody.AccountInfo customer (\info -> info.provider == provider && info.customer == customer)
  createIssuanceRequestCid <- submit customer do exerciseByKeyCmd @Issuance.Service (operator, provider, customer) Issuance.RequestCreateIssuance with ..
  snd <$> submit provider do exerciseByKeyCmd @Issuance.Service (operator, provider, customer) Issuance.CreateIssuance with createIssuanceRequestCid

deposit : Party -> Party -> Party -> Decimal -> Id -> Script (ContractId AssetDeposit)
deposit operator provider customer quantity assetId = do
  let asset = Asset with id = assetId; quantity
  (_, Custody.AccountInfo{account}) <- head <$> queryFilter @Custody.AccountInfo customer (\info -> info.provider == provider && info.customer == customer)
  depositRequestCid <- submitMulti [customer] [] do exerciseByKeyCmd @Custody.Service (operator, provider, customer) Custody.RequestDeposit with asset; account; depositChannel = Custody.ONLEDGER
  submit provider do exerciseByKeyCmd @Custody.Service (operator, provider, customer) Custody.Deposit with depositRequestCid

depositToAccount : Party -> Party -> Party -> Text -> Decimal -> Id -> Script (ContractId AssetDeposit)
depositToAccount operator provider customer accountLabel quantity assetId = do
  let asset = Asset with id = assetId; quantity
  (_, Custody.AccountInfo{account}) <- head <$> queryFilter @Custody.AccountInfo customer (\info -> info.provider == provider && info.customer == customer && info.account.id.label == accountLabel)
  depositRequestCid <- submitMulti [customer] [] do exerciseByKeyCmd @Custody.Service (operator, provider, customer) Custody.RequestDeposit with asset; account; depositChannel = Custody.ONLEDGER
  submit provider do exerciseByKeyCmd @Custody.Service (operator, provider, customer) Custody.Deposit with depositRequestCid

createDeal : Party -> Party -> Party -> Text -> Script (ContractId Structuring.Deal)
createDeal operator provider customer dealId = do
  createDealRequestCid <- submit customer do exerciseByKeyCmd @Structuring.Service (operator, provider, customer) Structuring.RequestCreateDeal with ..
  submit provider do exerciseByKeyCmd @Structuring.Service (operator, provider, customer) Structuring.CreateDeal with ..

addTranche : Party -> Party -> Party -> Party -> Party -> Party -> Party -> Party -> Text -> Text -> Id -> Id -> Decimal -> Script (ContractId Structuring.Deal, ContractId Structuring.Tranche)
addTranche operator provider customer settlementBank bndBank bondRegistrar cashProvider payingAgent dealId trancheId deliveryId paymentId size = do
  addTrancheRequestCid <- submit customer do exerciseByKeyCmd @Structuring.Service (operator, provider, customer) Structuring.RequestAddTranche with ..
  submit provider do exerciseByKeyCmd @Structuring.Service (operator, provider, customer) Structuring.AddTranche with ..

requestBookBuilding : Party -> Party -> Party -> ContractId Structuring.Tranche -> Script (ContractId BookBuilding.BuildRequest)
requestBookBuilding operator provider customer trancheCid = do
  submit customer do exerciseByKeyCmd @BookBuilding.Service (operator, provider, customer) BookBuilding.RequestBookBuilding with ..

bid : Party -> Party -> Party -> Text -> Text -> Decimal -> Decimal -> Script (ContractId Bidding.Bid)
bid operator provider customer dealId trancheId quantity price = do
  [(buildRequestCid, _)] <- queryFilter @BookBuilding.BuildRequest provider (\r -> r.dealId == dealId && r.trancheId == trancheId)
  bidRequestCid <- submit provider do exerciseByKeyCmd @Bidding.Service (operator, provider, customer) Bidding.RequestBid with buildRequestCid
  submit customer do exerciseByKeyCmd @Bidding.Service (operator, provider, customer) Bidding.SubmitBid with ..

closeBook : Party -> Party -> Party -> Text -> Text -> [(Party, Decimal)] -> Decimal -> Script [ContractId Bidding.Allocation]
closeBook operator provider customer dealId trancheId allocations offeredPrice = do
  buildRequestCids <- map fst <$> queryFilter @BookBuilding.BuildRequest customer (\r -> r.dealId == dealId && r.trancheId == trancheId)
  bidCids <- map fst <$> queryFilter @Bidding.Bid customer (\r -> r.dealId == dealId && r.trancheId == trancheId)
  submit customer do exerciseByKeyCmd @Structuring.Service (operator, provider, customer) Structuring.CloseBook with ..

confirm : Party -> Text -> Text -> SettlementMode -> Script (ContractId Bidding.Confirmation)
confirm investor dealId trancheId settlementMode = do
  [(allocationCid, _)] <- queryFilter @Bidding.Allocation investor (\a -> a.dealId == dealId && a.trancheId == trancheId)
  submit investor do exerciseCmd allocationCid Bidding.Confirm with settlementMode

allocateSi : Party -> (ContractId SettlementInstruction, SettlementInstruction) -> Script ()
allocateSi party (siCid, si) = do
  adsAllocated <- mapOptional ((.depositCid) . snd) <$> queryFilter @SettlementInstruction party (\si -> si.sender == party && isSome si.depositCid)
  ads <- queryFilter @AssetDeposit party (\ad -> ad.account.owner == party)
  let
    valid (adCid, ad) = notElem adCid adsAllocated && ad.account.owner == party && ad.account == si.senderAccount && ad.asset.id == si.asset.id && ad.asset.quantity >= si.asset.quantity
    adCids = map fst $ filter valid ads
  case adCids of
    [] ->
      if si.senderAccount.provider == party && si.senderAccount.owner == party then do
        adCid <- submit party do createCmd AssetDeposit with asset = si.asset; account = si.senderAccount; observers = empty; lockers = empty
        submit party do exerciseCmd siCid Allocate with settlementDepositCid = adCid
        pure ()
      else do
        pure ()
    adHead :: adTail -> do
      adMergedCid <-
        if null adTail
        then pure adHead
        else submit party do exerciseCmd adHead AssetDeposit_Merge with depositCids = adTail
      Some adMerged <- queryContractId party adMergedCid
      if adMerged.asset.quantity > si.asset.quantity then do
        adCid :: _ <- submit party do exerciseCmd adMergedCid AssetDeposit_Split with quantities = [ si.asset.quantity ]
        submit party do exerciseCmd siCid Allocate with settlementDepositCid = adCid
        pure ()
      else if adMerged.asset.quantity == si.asset.quantity then do
        submit party do exerciseCmd siCid Allocate with settlementDepositCid = adMergedCid
        pure ()
      else do
        debug $ "Insufficient funds for party " <> partyToText party
        pure ()

allocateInstructions : [Party] -> Script ()
allocateInstructions parties = do
  let
    allocate party = do
      sisUnallocated <- queryFilter @SettlementInstruction party (\si -> si.sender == party && isNone si.depositCid)
      forA_ sisUnallocated (allocateSi party)
  forA_ parties allocate

signInstructions : [Party] -> Script ()
signInstructions parties = do
  let
    sign party = do
      sis <- queryFilter @SettlementInstruction party (\si -> si.receiver == party)
      forA_ sis (\(siCid, _) -> submit party do exerciseCmd siCid Sign)
  forA_ parties sign

settleTrade : Party -> ContractId Trade -> Script ()
settleTrade party tradeCid = do
  submit party do exerciseCmd tradeCid Settle
  pure ()

settleTrades : Party -> [ContractId Trade] -> Script ()
settleTrades party tradeCids = do
  forA_ tradeCids $ settleTrade party

settleDelivery : Party -> ContractId Delivery -> Script ()
settleDelivery party deliveryCid = do
  submit party do exerciseCmd deliveryCid SettleDelivery
  pure ()

settleDeliveries : Party -> [ContractId Delivery] -> Script ()
settleDeliveries party deliveryCids = do
  forA_ deliveryCids $ settleDelivery party

consolidate : [Party] -> Script ()
consolidate parties = do
  let
    cleanup party = do
      adCids <- map fst <$> queryFilter @AssetDeposit party (\ad -> ad.account.owner == party && ad.account.provider == party)
      forA_ adCids (\cid -> submit party do archiveCmd cid)
      ads <- queryFilter @AssetDeposit party (\ad -> ad.account.owner == party)
      let ids = dedup $ map ((.asset.id) . snd) ads
      forA_ ids (merge party ads)
  forA_ parties cleanup

merge : Party -> [(ContractId AssetDeposit, AssetDeposit)] -> Id -> Script (ContractId AssetDeposit)
merge party deposits id = do
  let (adCid, _) :: t = filter (\(_, ad) -> ad.asset.id == id) deposits
  submit party do exerciseCmd adCid AssetDeposit_Merge with depositCids = map fst t

getMaxId : Party -> Id -> Script Id
getMaxId payingAgent assetId = do
  h :: t <- map snd <$> queryFilter @AssetDescription payingAgent (\ad -> ad.assetId.signatories == assetId.signatories && ad.assetId.label == assetId.label)
  pure $ foldl (\id desc -> if desc.assetId.version > id.version then desc.assetId else id) h.assetId t

upgradeVersion : [Party] -> Id -> Script ()
upgradeVersion parties maxId = do
  let upgradeVersionForParty party = do
        let
          isTargetAsset : AssetDeposit -> Bool
          isTargetAsset deposit = (maxId.version == deposit.asset.id.version && maxId.label == deposit.asset.id.label)
        ads <- queryFilter @AssetDeposit party (\ad -> ad.account.provider == party && isTargetAsset ad)
        mapA_ (\(adCid, ad) -> submit party do
          let newVersion = maxId.version + 1
          exerciseCmd adCid AssetDeposit_Upgrade with newVersion) ads
  mapA_ upgradeVersionForParty parties
