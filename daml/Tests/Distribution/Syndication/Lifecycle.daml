module Tests.Distribution.Syndication.Lifecycle where

import Daml.Script
import DA.Assert ((===))
import DA.Date (date, Month(..))
import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Types (Id)
import DA.Foldable (forA_)
import Marketplace.Issuance.AssetDescription (AssetDescription)
import Marketplace.Lifecycle.Model qualified as Lifecycle
import Marketplace.Lifecycle.Service qualified as Lifecycle
import Marketplace.Settlement.Hierarchical (Delivery)
import Tests.Distribution.Syndication.Setup (setup, Parties(..))
import Tests.Distribution.Syndication.Issuance (issuance)
import Tests.Distribution.Syndication.Origination (origination, Origination(..))
import Tests.Distribution.Syndication.Util

requestSnapshot : Party -> Party -> Id -> Date -> Script (ContractId Lifecycle.SnapshotRequest)
requestSnapshot operator bondRegistrar assetId date = do
  [(effectCid, effect)] <- queryFilter @Lifecycle.Effect bondRegistrar (\e -> e.bondRegistrar == bondRegistrar && e.assetId == assetId && e.date == date)
  submit bondRegistrar do exerciseCmd effectCid Lifecycle.RequestSnapshot

forwardRequest : Party -> Id -> Date -> Script [ContractId Lifecycle.SnapshotRequest]
forwardRequest custodian assetId date = do
  srs <- queryFilter @Lifecycle.SnapshotRequest custodian (\sr -> sr.custodian == custodian && sr.assetId == assetId && sr.date == date)
  case srs of
    [(srCid, sr)] -> do
      depositCids <- map fst <$> queryFilter @AssetDeposit custodian (\ad -> ad.account.provider == custodian && ad.asset.id.label == assetId.label && ad.asset.id.version == assetId.version)
      -- debug $ "[" <> show date <> "] " <> partyToText custodian <> " forwarding snapshot request for " <> assetId.label <> "(v" <> show assetId.version <> ") to " <> show (length depositCids) <> " custodians"
      submit custodian do exerciseCmd srCid Lifecycle.Forward with depositCids
    [] -> pure []
    _ -> fail "More than one snapshot request received"

provideSnapshot : Party -> Id -> Date -> Script [ContractId Lifecycle.Snapshot]
provideSnapshot custodian assetId date = do
  srs <- queryFilter @Lifecycle.SnapshotRequest custodian (\sr -> sr.custodian == custodian && sr.assetId == assetId && sr.date == date)
  case srs of
    [(srCid, sr)] -> do
      depositCids <- map fst <$> queryFilter @AssetDeposit custodian (\ad -> ad.account.provider == custodian && ad.asset.id.label == assetId.label && ad.asset.id.version == assetId.version)
      submit custodian do exerciseCmd srCid Lifecycle.Provide with depositCids
    [] -> pure []
    _ -> fail "More than one snapshot request received"

instructLifecycle : Party -> Party -> Id -> Date -> Script [ContractId Delivery]
instructLifecycle operator bondRegistrar assetId date = do
  [(effectCid, effect)] <- queryFilter @Lifecycle.Effect bondRegistrar (\e -> e.bondRegistrar == bondRegistrar && e.assetId == assetId && e.date == date)
  snapshotCids <- map fst <$> queryFilter @Lifecycle.Snapshot bondRegistrar (\s -> s.bondRegistrar == bondRegistrar && s.deposit.asset.id.label == assetId.label && s.deposit.asset.id.version == assetId.version && s.date == date)
  submit operator do exerciseCmd effectCid Lifecycle.Instruct with snapshotCids

test : Script ()
test = do
  parties@Parties{..} <- setup
  orig@Origination{..} <- origination parties
  issuance parties orig
  submitMulti [operator, bondRegistrar] [] do createCmd Lifecycle.Today with operator; provider = bondRegistrar; date = date 2021 Jan 15

  let dates = [ date 2022 Mar 21, date 2022 Jun 21, date 2022 Sep 20, date 2022 Dec 20, date 2023 Jun 20, date 2023 Dec 20 ]

  forA_ dates $ lifecycleAssets parties [ bond1Desc.assetId, bond2Desc.assetId ]

  createLifecycleEffect parties bond1Desc.assetId (date 2022 Jun 21) (date 2022 Jun 07)
  lifecycleAssets parties [ bond1Desc.assetId ] (date 2022 Jun 21)

  createLifecycleEffect parties bond1Desc.assetId (date 2022 Sep 20) (date 2022 Sep 06)
  lifecycleAssets parties [ bond1Desc.assetId ] (date 2022 Sep 20)

  createLifecycleEffect parties bond1Desc.assetId (date 2022 Dec 20) (date 2022 Dec 06)
  -- lifecycleAssets parties [ bond1Desc.assetId ] (date 2022 Dec 20)

  -- createLifecycleEffect parties bond2Desc.assetId (date 2022 Jun 21) (date 2022 Jun 07)
  -- lifecycleAssets parties [ bond2Desc.assetId ] (date 2022 Jun 21)

  -- createLifecycleEffect parties bond2Desc.assetId (date 2022 Dec 20) (date 2022 Dec 06)
  -- lifecycleAssets parties [ bond2Desc.assetId ] (date 2022 Dec 20)

  -- createLifecycleEffect parties bond2Desc.assetId (date 2023 Jun 20) (date 2023 Jun 07)
  -- lifecycleAssets parties [ bond2Desc.assetId ] (date 2023 Jun 20)

  -- createLifecycleEffect parties bond2Desc.assetId (date 2023 Dec 20) (date 2023 Dec 07)
  -- lifecycleAssets parties [ bond2Desc.assetId ] (date 2023 Dec 20)

  [(_, ad1)] <- queryFilter @AssetDeposit investor1 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad2)] <- queryFilter @AssetDeposit investor2 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad3)] <- queryFilter @AssetDeposit investor3 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad4)] <- queryFilter @AssetDeposit investor4 (\ad -> ad.asset.id.label == usd.assetId.label)
  ad1.asset.quantity === 21_400_000.0
  ad2.asset.quantity === 42_800_000.0
  ad3.asset.quantity === 64_200_000.0
  ad4.asset.quantity === 85_600_000.0
  pure ()

lifecycleAssets : Parties -> [Id] -> Date -> Script ()
lifecycleAssets parties assetIds date = do
  forA_ assetIds $ lifecycle parties date

createLifecycleEffect: Parties -> Id -> Date -> Date -> Script (Optional (ContractId Lifecycle.Effect))
createLifecycleEffect Parties{..} assetId payDate recordDate = do
  h :: t <- map snd <$> queryFilter @AssetDescription bondRegistrar (\ad -> ad.assetId.signatories == assetId.signatories && ad.assetId.label == assetId.label)
  let maxId = foldl (\id desc -> if desc.assetId.version > id.version then desc.assetId else id) h.assetId t
  submit bondRegistrar do exerciseByKeyCmd @Lifecycle.Service (operator, issuer, bondRegistrar) Lifecycle.CalculateEffect with assetId = maxId; election = None; payDate; recordDate
  
lifecycle : Parties -> Date -> Id -> Script ()
lifecycle Parties{..} date assetId = do

  h :: t <- map snd <$> queryFilter @AssetDescription bondRegistrar (\ad -> ad.assetId.signatories == assetId.signatories && ad.assetId.label == assetId.label)
  let maxId = foldl (\id desc -> if desc.assetId.version > id.version then desc.assetId else id) h.assetId t
  submit bondRegistrar do exerciseByKeyCmd @Lifecycle.Today (operator, bondRegistrar) Lifecycle.SetDate with newDate = date
  let lifecycleId = "Lifecycle-" <> show date <> "-" <> assetId.label <> "(v" <> show maxId.version <> ")"
  effectCidOpt <- queryContractKey @Lifecycle.Effect bondRegistrar (bondRegistrar, lifecycleId)
  case effectCidOpt of
    Some (effectCid, _) -> do
      Some effect <- queryContractId bondRegistrar effectCid
      debug $ "[" <> show date <> "][" <> maxId.label <> "(v" <> show maxId.version <> ")] " <> "Event with " <> show (length effect.payouts) <> " payouts"

      requestSnapshot operator bondRegistrar maxId date
      forwardRequest bondRegistrar maxId date
      provideSnapshot custodian1 maxId date
      provideSnapshot custodian2 maxId date
      forwardRequest custodian4 maxId date
      provideSnapshot custodian5 maxId date
      paymentCids <- instructLifecycle operator bondRegistrar maxId date

      allocateInstructions [ issuer, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]
      signInstructions [ issuer, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]
      settleDeliveries bondRegistrar paymentCids
      consolidate [ issuer, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]

    None -> do
      debug $ "[" <> show date <> "][" <> maxId.label <> "(v" <> show maxId.version <> ")] " <> "No event"

