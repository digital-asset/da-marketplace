module Tests.Distribution.Syndication.Lifecycle where

import Daml.Script
import DA.Assert ((===))
import DA.Date (date, Month(..))
import DA.Finance.Asset (AssetDeposit_Transfer(..), AssetDeposit_Split(..), AssetDeposit)
import DA.Finance.Base.HolidayCalendar (HolidayCalendar)
import DA.Finance.Types (Id)
import DA.Foldable (forA_)
import DA.List (head)
import DA.Time (time)
import Marketplace.Custody.Model (AccountInfo)
import Marketplace.Reporting.Service as Reporting
import Marketplace.Lifecycle.Model qualified as Lifecycle
import Marketplace.Lifecycle.Service qualified as Lifecycle
import Marketplace.Snapshot.Model as Snapshot
import Marketplace.Snapshot.Service qualified as Snapshot
import Marketplace.Settlement.Hierarchical (Delivery)
import SwiftMessage.Message (SwiftOutboundMessage, SwiftMessageType(..), SwiftMessage(..))
import Tests.Distribution.Syndication.Setup (setup, Parties(..))
import Tests.Distribution.Syndication.Issuance (issuance)
import Tests.Distribution.Syndication.Origination (origination, Origination(..))
import Tests.Distribution.Syndication.Util

requestSnapshot : Party -> Party -> Party -> Id -> RefId -> Script (ContractId Snapshot.SnapshotRequest)
requestSnapshot operator payingAgent bondRegistrar assetId referenceId = do
  submit payingAgent do exerciseByKeyCmd @Snapshot.Service (operator, payingAgent) Snapshot.RequestSnapshot with custodian = bondRegistrar; ..

forwardRequest : Party -> Id -> Script [ContractId Snapshot.SnapshotRequest]
forwardRequest custodian assetId = do
  srs <- queryFilter @Snapshot.SnapshotRequest custodian (\sr -> sr.custodian == custodian && sr.assetId == assetId)
  case srs of
    [(srCid, sr)] -> do
      depositCids <- map fst <$> queryFilter @AssetDeposit custodian (\ad -> ad.account.provider == custodian && ad.asset.id.label == assetId.label && ad.asset.id.version == assetId.version)
      -- debug $ "[" <> show date <> "] " <> partyToText custodian <> " forwarding snapshot request for " <> assetId.label <> "(v" <> show assetId.version <> ") to " <> show (length depositCids) <> " custodians"
      submit custodian do exerciseCmd srCid Snapshot.Forward with depositCids
    [] -> pure []
    _ -> fail "More than one snapshot request received"

provideSnapshot : Party -> Id -> Script [ContractId Snapshot.Snapshot]
provideSnapshot custodian assetId = do
  srs <- queryFilter @Snapshot.SnapshotRequest custodian (\sr -> sr.custodian == custodian && sr.assetId == assetId)
  case srs of
    [(srCid, sr)] -> do
      depositCids <- map fst <$> queryFilter @AssetDeposit custodian (\ad -> ad.account.provider == custodian && ad.asset.id.label == assetId.label && ad.asset.id.version == assetId.version)
      submit custodian do exerciseCmd srCid Snapshot.Provide with depositCids
    [] -> pure []
    _ -> fail "More than one snapshot request received"

instructLifecycle : Party -> Party -> Id -> RefId -> Date -> Script [ContractId Delivery]
instructLifecycle operator payingAgent assetId snapshotRefId date = do
  [(effectCid, effect)] <- queryFilter @Lifecycle.Effect payingAgent (\e -> e.payingAgent == payingAgent && e.assetId == assetId && e.date == date)
  snapshotCids <- map fst <$> queryFilter @Snapshot.Snapshot payingAgent (\s -> s.requester == payingAgent 
    && s.deposit.asset.id.label == assetId.label 
    && s.deposit.asset.id.version == assetId.version
    && s.referenceId == snapshotRefId)
  submit operator do exerciseCmd effectCid Lifecycle.Instruct with snapshotCids

testReporting : Script ()
testReporting = do
  parties@Parties{..} <- setup
  orig@Origination{..} <- origination parties
  issuance parties orig

  -- create report can be done at anytime
  Some calendar <- queryContractId @HolidayCalendar operator calendarCid
  setTime (time (date 2021 Jan 8) 0 0 0)
  
  -- move part of BOND1 for investor1 into different account under the same provider to check report correctness
  (depositBond1Cid, depositBond1) <- head <$> queryFilter @AssetDeposit investor1 (\deposit -> deposit.asset.id.label == "BOND1")
  (accountInfoCid, accountInfo) <- head <$> queryFilter @AccountInfo investor1 (\accountInfo -> accountInfo.account.id.label == "Investor1@Custodian1-2")
  splitResultCid <- head <$> submit investor1 do exerciseCmd depositBond1Cid AssetDeposit_Split with quantities = [500000.0]
  submit investor1 do exerciseCmd splitResultCid AssetDeposit_Transfer with receiverAccount = accountInfo.account

  -- security report
  reporting operator bondRegistrar calendar False
  reporting operator custodian1 calendar False
  reporting operator custodian2 calendar False
  reporting operator custodian4 calendar False
  reporting operator custodian5 calendar False

  -- cash report
  reporting operator cashProvider calendar True

  -- make sure that we can submit reporting at the same date without failing
  reporting operator bondRegistrar calendar False
  reporting operator cashProvider calendar True

  -- prev business day of Jan 11 2021 is Jan 8 2021
  setTime (time (date 2021 Jan 11) 0 0 0)
  reporting operator bondRegistrar calendar False

  -- check investor1's report under custodian1 has 3 entry (2* bond1) + (1 bond2)
  Some (_, swiftOutboundMessage) <- queryContractKey @SwiftOutboundMessage custodian1 (custodian1, "2021-01-08-Investor1@Custodian1", MT535_t)
  case swiftOutboundMessage.swiftMessage of 
    MT535 mt535 -> length mt535.reportDetails.reportDetails === 3
    _ -> error "type mismatch"
  pure ()


testBond1 : Script ()
testBond1 = do
  parties@Parties{..} <- setup
  orig@Origination{..} <- origination parties
  issuance parties orig
  submitMulti [operator, payingAgent] [] do createCmd Lifecycle.Today with operator; provider = payingAgent; date = date 2021 Jan 15

  let 
      bond1Id = bond1Desc.assetId
      bond1PayoutDates = [ date 2022 Mar 21, date 2022 Jun 21, date 2022 Sep 20, date 2022 Dec 20 ]

  forA_ bond1PayoutDates (\date -> do preNotify parties date bond1Id 
                                      lifecycle parties date bond1Id)
                                    
  [(_, ad1)] <- queryFilter @AssetDeposit investor1 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad2)] <- queryFilter @AssetDeposit investor2 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad3)] <- queryFilter @AssetDeposit investor3 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad4)] <- queryFilter @AssetDeposit investor4 (\ad -> ad.asset.id.label == usd.assetId.label)
  ad1.asset.quantity === 10_400_000.0
  ad2.asset.quantity === 20_800_000.0
  ad3.asset.quantity === 31_200_000.0
  ad4.asset.quantity === 41_600_000.0

  pure ()


testBond2 : Script ()
testBond2 = do
  parties@Parties{..} <- setup
  orig@Origination{..} <- origination parties
  issuance parties orig
  submitMulti [operator, payingAgent] [] do createCmd Lifecycle.Today with operator; provider = payingAgent; date = date 2021 Jan 15

  let 
    bond2Id = bond2Desc.assetId
    bond2PayoutDates = [ date 2022 Jun 21, date 2022 Dec 20, date 2023 Jun 20, date 2023 Dec 20 ]

  forA_ bond2PayoutDates (\date -> do preNotify parties date bond2Id 
                                      lifecycle parties date bond2Id)
  
  [(_, ad1)] <- queryFilter @AssetDeposit investor1 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad2)] <- queryFilter @AssetDeposit investor2 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad3)] <- queryFilter @AssetDeposit investor3 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad4)] <- queryFilter @AssetDeposit investor4 (\ad -> ad.asset.id.label == usd.assetId.label)
  ad1.asset.quantity === 11_000_000.0
  ad2.asset.quantity === 22_000_000.0
  ad3.asset.quantity === 33_000_000.0
  ad4.asset.quantity === 44_000_000.0                                                      
  pure ()

lifecycleSnapshot : Parties -> Id -> RefId -> Script ()
lifecycleSnapshot Parties{..} maxId snapshotRefId = do
  requestSnapshot operator payingAgent bondRegistrar maxId snapshotRefId
  forwardRequest bondRegistrar maxId
  provideSnapshot custodian1 maxId
  provideSnapshot custodian2 maxId
  forwardRequest custodian4 maxId
  provideSnapshot custodian5 maxId
  pure ()

lifecycleAssets : Parties -> [Id] -> Date -> Script ()
lifecycleAssets parties assetIds date = do
  forA_ assetIds $ lifecycle parties date

lifecycle : Parties -> Date -> Id -> Script ()
lifecycle parties@Parties{..} date assetId = do
  maxId <- getMaxId payingAgent assetId

  -- on payout date
  submit payingAgent do exerciseByKeyCmd @Lifecycle.Today (operator, payingAgent) Lifecycle.SetDate with newDate = date
  effectCidOpt <- submit payingAgent do exerciseByKeyCmd @Lifecycle.Service (operator, issuer, payingAgent) Lifecycle.CalculateEffect with assetId = maxId; election = None

  case effectCidOpt of
    Some (effectCid, requestCid) -> do
      let snapshotRefId = "lifecycle-snapshot"
      lifecycleSnapshot parties maxId snapshotRefId
      submit bondRegistrar do exerciseCmd requestCid Lifecycle.ApproveUpdate -- update asset description after calculating effect
      Some effect <- queryContractId payingAgent effectCid
      debug $ "[" <> show date <> "][" <> maxId.label <> "(v" <> show maxId.version <> ")] " <> "Event with " <> show (length effect.payouts) <> " payouts"
      upgradeVersion [bondRegistrar, custodian1, custodian2, custodian4, custodian5] maxId
      paymentCids <- instructLifecycle operator payingAgent maxId snapshotRefId date

      allocateInstructions [ issuer, bondRegistrar, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]
      signInstructions [ issuer, bondRegistrar, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]
      settleDeliveries payingAgent paymentCids
      consolidate [ issuer, bondRegistrar, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]

    None -> do
      debug $ "[" <> show date <> "][" <> maxId.label <> "(v" <> show maxId.version <> ")] " <> "No event"

preNotify : Parties -> Date -> Id -> Script ()
preNotify parties@Parties{..} date assetId = do
  -- before payout date
  maxId <- getMaxId payingAgent assetId
  let snapshotRefId = "prenotify-snapshot"
  lifecycleSnapshot parties maxId snapshotRefId
  snapshotCids <- map fst <$> queryFilter @Snapshot.Snapshot payingAgent (\s -> s.requester == payingAgent 
    && s.deposit.asset.id.label == maxId.label 
    && s.deposit.asset.id.version == maxId.version
    && s.referenceId == snapshotRefId)

  submit operator do exerciseByKeyCmd @Lifecycle.Service (operator, issuer, payingAgent) Lifecycle.SendPrePayoutSwiftMessage with exDivDate = date; ..
  pure ()

reporting : Party -> Party -> HolidayCalendar -> Bool -> Script ()
reporting operator accountProvider calendar isCashReporting = do 
  depositCids <- map fst <$> queryFilter @AssetDeposit accountProvider (\deposit -> deposit.account.provider == accountProvider)
  submit accountProvider do exerciseByKeyCmd @Reporting.Service (operator, accountProvider) Reporting.CreateReports with calendar; depositCids; isCashReporting
  pure ()
  