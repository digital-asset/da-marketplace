module Tests.Distribution.Syndication.Lifecycle where

import Daml.Script
import DA.Assert ((===))
import DA.Date (date, Month(..))
import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Types (Id)
import DA.Foldable (forA_)
import Marketplace.Lifecycle.Reporting.Service as Reporting
import Marketplace.Lifecycle.Model qualified as Lifecycle
import Marketplace.Lifecycle.Service qualified as Lifecycle
import Marketplace.Lifecycle.Snapshot.Model as Snapshot
import Marketplace.Lifecycle.Snapshot.Service qualified as Snapshot
import Marketplace.Settlement.Hierarchical (Delivery)
import Tests.Distribution.Syndication.Setup (setup, Parties(..))
import Tests.Distribution.Syndication.Issuance (issuance)
import Tests.Distribution.Syndication.Origination (origination, Origination(..))
import Tests.Distribution.Syndication.Util
import DA.Time (time)

requestSnapshot : Party -> Party -> Party -> Id -> Script (ContractId Snapshot.SnapshotRequest)
requestSnapshot operator payingAgent bondRegistrar assetId = do
  submit payingAgent do exerciseByKeyCmd @Snapshot.Service (operator, payingAgent) Snapshot.RequestSnapshot with custodian = bondRegistrar; ..

forwardRequest : Party -> Id -> Script [ContractId Snapshot.SnapshotRequest]
forwardRequest custodian assetId = do
  srs <- queryFilter @Snapshot.SnapshotRequest custodian (\sr -> sr.custodian == custodian && sr.assetId == assetId)
  case srs of
    [(srCid, sr)] -> do
      depositCids <- map fst <$> queryFilter @AssetDeposit custodian (\ad -> ad.account.provider == custodian && ad.asset.id.label == assetId.label && ad.asset.id.version == assetId.version)
      -- debug $ "[" <> show date <> "] " <> partyToText custodian <> " forwarding snapshot request for " <> assetId.label <> "(v" <> show assetId.version <> ") to " <> show (length depositCids) <> " custodians"
      submit custodian do exerciseCmd srCid Snapshot.Forward with depositCids
    [] -> pure []
    _ -> fail "More than one snapshot request received"

provideSnapshot : Party -> Id -> Script [ContractId Snapshot.Snapshot]
provideSnapshot custodian assetId = do
  srs <- queryFilter @Snapshot.SnapshotRequest custodian (\sr -> sr.custodian == custodian && sr.assetId == assetId)
  case srs of
    [(srCid, sr)] -> do
      depositCids <- map fst <$> queryFilter @AssetDeposit custodian (\ad -> ad.account.provider == custodian && ad.asset.id.label == assetId.label && ad.asset.id.version == assetId.version)
      submit custodian do exerciseCmd srCid Snapshot.Provide with depositCids
    [] -> pure []
    _ -> fail "More than one snapshot request received"

instructLifecycle : Party -> Party -> Id -> Date -> Script [ContractId Delivery]
instructLifecycle operator payingAgent assetId date = do
  [(effectCid, effect)] <- queryFilter @Lifecycle.Effect payingAgent (\e -> e.payingAgent == payingAgent && e.assetId == assetId && e.date == date)
  snapshotCids <- map fst <$> queryFilter @Snapshot.Snapshot payingAgent (\s -> s.requester == payingAgent && s.deposit.asset.id.label == assetId.label && s.deposit.asset.id.version == assetId.version)
  submit operator do exerciseCmd effectCid Lifecycle.Instruct with snapshotCids

testReporting : Script ()
testReporting = script do
  parties@Parties{..} <- setup
  orig@Origination{..} <- origination parties
  issuance parties orig

  -- create report can be done at anytime
  setTime (time (date 2021 Jan 1) 0 0 0)
  
  -- security report
  reporting operator bondRegistrar False
  reporting operator custodian1 False
  reporting operator custodian2 False
  reporting operator custodian3 False
  reporting operator custodian4 False
  reporting operator custodian5 False

  -- cash report
  reporting operator cashProvider True

  -- make sure that we can submit reporting at the same date without failing
  reporting operator bondRegistrar False
  reporting operator cashProvider True

  pure ()


testBond1 : Script ()
testBond1 = do
  parties@Parties{..} <- setup
  orig@Origination{..} <- origination parties
  issuance parties orig
  submitMulti [operator, payingAgent] [] do createCmd Lifecycle.Today with operator; provider = payingAgent; date = date 2021 Jan 15

  let 
      bond1Id = bond1Desc.assetId
      bond1PayoutDates = [ date 2022 Mar 21, date 2022 Jun 21, date 2022 Sep 20, date 2022 Dec 20 ]

  forA_ bond1PayoutDates (\date -> do preNotify parties date bond1Id 
                                      lifecycle parties date bond1Id)
                                    
  [(_, ad1)] <- queryFilter @AssetDeposit investor1 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad2)] <- queryFilter @AssetDeposit investor2 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad3)] <- queryFilter @AssetDeposit investor3 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad4)] <- queryFilter @AssetDeposit investor4 (\ad -> ad.asset.id.label == usd.assetId.label)
  ad1.asset.quantity === 10_400_000.0
  ad2.asset.quantity === 20_800_000.0
  ad3.asset.quantity === 31_200_000.0
  ad4.asset.quantity === 41_600_000.0

  pure ()


testBond2 : Script ()
testBond2 = do
  parties@Parties{..} <- setup
  orig@Origination{..} <- origination parties
  issuance parties orig
  submitMulti [operator, payingAgent] [] do createCmd Lifecycle.Today with operator; provider = payingAgent; date = date 2021 Jan 15

  let 
    bond2Id = bond2Desc.assetId
    bond2PayoutDates = [ date 2022 Jun 21, date 2022 Dec 20, date 2023 Jun 20, date 2023 Dec 20 ]

  forA_ bond2PayoutDates (\date -> do preNotify parties date bond2Id 
                                      lifecycle parties date bond2Id)
  
  [(_, ad1)] <- queryFilter @AssetDeposit investor1 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad2)] <- queryFilter @AssetDeposit investor2 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad3)] <- queryFilter @AssetDeposit investor3 (\ad -> ad.asset.id.label == usd.assetId.label)
  [(_, ad4)] <- queryFilter @AssetDeposit investor4 (\ad -> ad.asset.id.label == usd.assetId.label)
  ad1.asset.quantity === 11_000_000.0
  ad2.asset.quantity === 22_000_000.0
  ad3.asset.quantity === 33_000_000.0
  ad4.asset.quantity === 44_000_000.0                                                      
  pure ()

lifecycleSnapshot : Parties -> Id -> Script ()
lifecycleSnapshot Parties{..} maxId = do
  requestSnapshot operator payingAgent bondRegistrar maxId
  forwardRequest bondRegistrar maxId
  provideSnapshot custodian1 maxId
  provideSnapshot custodian2 maxId
  forwardRequest custodian4 maxId
  provideSnapshot custodian5 maxId
  pure ()

lifecycleAssets : Parties -> [Id] -> Date -> Script ()
lifecycleAssets parties assetIds date = do
  forA_ assetIds $ lifecycle parties date

lifecycle : Parties -> Date -> Id -> Script ()
lifecycle parties@Parties{..} date assetId = do
  maxId <- getMaxId payingAgent assetId

  -- on payout date
  submit payingAgent do exerciseByKeyCmd @Lifecycle.Today (operator, payingAgent) Lifecycle.SetDate with newDate = date
  effectCidOpt <- submit payingAgent do exerciseByKeyCmd @Lifecycle.Service (operator, issuer, payingAgent) Lifecycle.CalculateEffect with assetId = maxId; election = None

  case effectCidOpt of
    Some (effectCid, requestCid) -> do
      lifecycleSnapshot parties maxId
      submit bondRegistrar do exerciseCmd requestCid Lifecycle.ApproveUpdate -- update asset description after calculating effect
      Some effect <- queryContractId payingAgent effectCid
      debug $ "[" <> show date <> "][" <> maxId.label <> "(v" <> show maxId.version <> ")] " <> "Event with " <> show (length effect.payouts) <> " payouts"
      upgradeVersion [bondRegistrar, custodian1, custodian2, custodian4, custodian5] maxId
      paymentCids <- instructLifecycle operator payingAgent maxId date

      allocateInstructions [ issuer, bondRegistrar, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]
      signInstructions [ issuer, bondRegistrar, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]
      settleDeliveries payingAgent paymentCids
      consolidate [ issuer, bondRegistrar, lm1, lm2, lm3, custodian1, custodian2, custodian4, custodian5, investor1, investor2, investor3, investor4 ]

    None -> do
      debug $ "[" <> show date <> "][" <> maxId.label <> "(v" <> show maxId.version <> ")] " <> "No event"

preNotify : Parties -> Date -> Id -> Script ()
preNotify parties@Parties{..} date assetId = do
  -- before payout date
  maxId <- getMaxId payingAgent assetId
  lifecycleSnapshot parties maxId
  snapshotCids <- map fst <$> queryFilter @Snapshot.Snapshot payingAgent (\s -> s.requester == payingAgent && s.deposit.asset.id.label == maxId.label && s.deposit.asset.id.version == maxId.version)

  submit operator do exerciseByKeyCmd @Lifecycle.Service (operator, issuer, payingAgent) Lifecycle.SendPrePayoutSwiftMessage with exDivDate = date; ..
  pure ()

reporting : Party -> Party -> Bool -> Script ()
reporting operator accountProvider isCashReporting = do 
  depositCids <- map fst <$> queryFilter @AssetDeposit accountProvider (\deposit -> deposit.account.provider == accountProvider)
  submit accountProvider do exerciseByKeyCmd @Reporting.Service (operator, accountProvider) Reporting.CreateReports with depositCids; isCashReporting
  pure ()