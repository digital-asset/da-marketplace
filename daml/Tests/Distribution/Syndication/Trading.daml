module Tests.Distribution.Syndication.Trading where

import Daml.Script
import DA.Date
import DA.Finance.Types (Asset(..))
import DA.Set (singleton)
import DA.Text (sha256)
import DA.Time (hours, addRelTime)
import Marketplace.Settlement.Hierarchical.Dvp qualified as Hierarchical (Dvp)
import Marketplace.Settlement.Htlc.Dvp qualified as Htlc (Dvp)
import Marketplace.Settlement.Hierarchical.Util (SettlementMode(..))
import Marketplace.Trading.Model (Side(..))
import Marketplace.Trading.Otc.Model qualified as Trading
import Marketplace.Trading.Otc.Service qualified as Trading
import Tests.Distribution.Syndication.Setup (setup, Parties(..))
import Tests.Distribution.Syndication.Issuance (issuance)
import Tests.Distribution.Syndication.Origination (origination, Origination(..))
import Tests.Distribution.Syndication.Util

setTradingStatus : Party -> Bool -> Script [ContractId Trading.Service]
setTradingStatus operator isTradingAllowed = do
  serviceCids <- map fst <$> queryFilter @Trading.Service operator (\s -> s.operator == operator)
  submit operator do mapA (\sCid -> exerciseCmd sCid Trading.SetStatus with isTradingAllowed) serviceCids

createOrder : Party -> Party -> Party -> Party -> Party -> Text -> Asset -> Asset -> Side -> SettlementMode -> Optional Text -> Script (ContractId Trading.Order)
createOrder operator customer counterparty deliveryRegistrar paymentRegistrar id delivery payment side settlementMode hashlockOpt= do
  submit customer do exerciseByKeyCmd @Trading.Service (operator, operator, customer) Trading.CreateOrder with ..

acceptOrder : Party -> Party -> ContractId Trading.Order -> Script (ContractId Trading.Match)
acceptOrder operator customer orderCid = do
  submit customer do exerciseByKeyCmd @Trading.Service (operator, operator, customer) Trading.AcceptOrder with ctrl = customer; orderCid

instructMatch : Party -> ContractId Trading.Match -> Date -> Script (ContractId Trading.Match, ContractId Hierarchical.Dvp)
instructMatch operator matchCid dateOfSettlement = do
  submit operator do exerciseCmd matchCid Trading.Instruct with ..

instructMatchHtlc : Party -> ContractId Trading.Match -> Time -> Date -> Script (ContractId Trading.Match, ContractId Htlc.Dvp)
instructMatchHtlc operator matchCid expiry dateOfSettlement = do
  submit operator do exerciseCmd matchCid Trading.InstructHtlc with ..

test : Script ()
test = do
  parties@Parties{..} <- setup
  orig <- origination parties
  issuance parties orig
  trading parties orig

trading : Parties -> Origination -> Script ()
trading Parties{..} Origination{..} = do

  deposit operator cashProvider  lm1        1_000_000.0 usd.assetId
  deposit operator lm1           investor1  1_000_000.0 (usd.assetId with signatories = singleton lm1)

  setTradingStatus operator True
  let
    delivery = Asset with id = bond1Desc.assetId; quantity = 1_000_000.0
    payment = Asset with id = usd.assetId; quantity = 1_000_000.0
    
    delivery2 = Asset with id = bond2Desc.assetId; quantity = 2_000_000.0
    payment2 = Asset with id = usd.assetId; quantity = 2_000_000.0
    
    payment3 = Asset with id = usd.assetId; quantity = 3_000_000.0
    delivery3 = Asset with id = bond3Desc.assetId; quantity = 3_000_000.0
    dateOfSettlement = date 2022 Jun 17

  orderCid <- createOrder operator investor1 investor2 bondRegistrar cashProvider "TRD1" delivery payment Buy Dvp None
  matchCid <- acceptOrder operator investor2 orderCid
  (matchCid, tradeCid) <- instructMatch operator matchCid dateOfSettlement
  
  orderCid2 <- createOrder operator investor1 investor2 bondRegistrar cashProvider "TRD2" delivery2 payment2 Buy Fop None
  matchCid2 <- acceptOrder operator investor2 orderCid2
  (matchCid2, tradeCid2) <- instructMatch operator matchCid2 dateOfSettlement

  now <- getTime
  let 
    secret = "secret"
    hashlock = sha256 secret
    expiry = addRelTime now $ hours 1
  orderCid3 <- createOrder operator investor1 investor2 bondRegistrar cashProvider "TRD3" delivery3 payment3 Buy Htlc (Some hashlock)
  matchCid3 <- acceptOrder operator investor2 orderCid3
  (matchCid3, tradeCid3) <- instructMatchHtlc operator matchCid3 expiry dateOfSettlement

  allocateInstructions [ lm1, lm2, investor1, investor2, custodian1, custodian2 ]
  allocateInstructionsHtlc [ investor2, custodian1, custodian2 ]
  signInstructions [ lm1, lm2, investor1, investor2, custodian1, custodian2 ]
  signInstructionsHtlc [ investor1, custodian1, custodian2 ]
  settleTrade operator tradeCid
  settleTrade operator tradeCid2
  settleTradeHtlc investor1 (secret, tradeCid3)


  -- demonstrate cancellation flow
  orderCid4 <- createOrder operator investor1 investor2 bondRegistrar cashProvider "TRD4" delivery payment Buy Dvp None
  matchCid4 <- acceptOrder operator investor2 orderCid4
  
  -- cancellation can be made before instruct 
  cancelProposalCid <- submit investor1 do exerciseCmd matchCid4 Trading.ProposeCancel with ctrl = investor1
  matchCid4 <- submit investor2 do exerciseCmd cancelProposalCid Trading.RejectCancellation
  
  (matchCid4, tradeCid4) <- instructMatch operator matchCid4 dateOfSettlement
  
  -- cancellation can also be made after instruct but note that if any instruction has been allocated, the allocation will not be rolled back
  cancelProposalCid <- submit investor1 do exerciseCmd matchCid4 Trading.ProposeCancel with ctrl = investor1
  matchCancelCid <- submit investor2 do exerciseCmd cancelProposalCid Trading.AcceptCancellation
  submit operator do exerciseCmd matchCancelCid Trading.CancelMatch

  consolidate [ lm1, lm2, investor1, investor2, custodian1, custodian2 ]

  pure ()
