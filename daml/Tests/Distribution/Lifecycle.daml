module Tests.Distribution.Lifecycle where

import Daml.Script
import DA.Date (date, Month(..))
import DA.Finance.Asset (AssetDeposit)
import Marketplace.Lifecycle.Model qualified as Lifecycle
import Tests.Distribution.Setup (Parties(..))
import Tests.Distribution.Issuance (issuance, Issuance(..))
import Tests.Distribution.Util

instructLifecycle : Party -> Party -> Party -> [Party] -> Script ()
instructLifecycle operator issuer custodian custodians = do
  [ (effectCid, _) ] <- queryFilter @Lifecycle.Effect custodian (\le -> le.recipient == custodian)
  if null custodians
  then do
    depositCids <- map fst <$> queryFilter @AssetDeposit custodian (\ad -> ad.account.provider == custodian)
    -- TODO: This implies we have a lifecycle service with the operator signatures for every custodian. we'd then call `Instruct` through that service to have the necessary auth
    submitMulti [operator, custodian] [] do exerciseCmd effectCid Lifecycle.Instruct with ..
  else do
    submitMulti [operator, custodian] [] do exerciseCmd effectCid Lifecycle.Instruct with depositCids = []; ..
  pure ()

coupon : Script ()
coupon = do

  Issuance{parties, security} <- issuance
  let Parties{..} = parties

  submitMulti [operator, bondRegistrar] [] do createCmd Lifecycle.Today with operator; provider = bondRegistrar; date = date 2021 Jan 15

  Some effectCid <- lifecycle operator issuer bondRegistrar security.assetId
  instructLifecycle operator issuer bondRegistrar [ custodian1, custodian2, custodian3, custodian4 ]
  instructLifecycle operator issuer custodian1 []
  instructLifecycle operator issuer custodian2 []
  instructLifecycle operator issuer custodian4 [ custodian5 ]
  instructLifecycle operator issuer custodian5 []
  pure ()
