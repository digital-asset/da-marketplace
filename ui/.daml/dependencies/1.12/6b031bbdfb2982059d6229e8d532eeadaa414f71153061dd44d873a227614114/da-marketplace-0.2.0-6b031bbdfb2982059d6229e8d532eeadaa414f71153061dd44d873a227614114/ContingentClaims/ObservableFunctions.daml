--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# LANGUAGE NoImplicitPrelude #-}

module ContingentClaims.ObservableFunctions where

-- TODO: rename this module to something more appropriate

import Daml.Control.Arrow (Arrow, arr)
import Daml.Data.Functor.Contravariant
import Prelude (Applicative, Additive, Multiplicative, Divisible, liftA2, Text, const, (.))
import Prelude qualified ((+), negate, (*), (^), (/), pure, aunit, munit, (<=))
import ContingentClaims.Observable

-- Default instances for applicative functors

instance forall f t . (Arrow f, Applicative (f t)) => Point f t Text where
  pure = Prelude.pure
  observe key = arr (const key)

instance (Additive a, Applicative (f t)) => Additive (f t a) where
  aunit = Prelude.pure Prelude.aunit
  (+) = liftA2 (Prelude.+)
  negate = fmap Prelude.negate

instance (Multiplicative a, Applicative (f t)) => Multiplicative (f t a) where
  munit = Prelude.pure Prelude.munit
  (*) = liftA2 (Prelude.*)
  x ^ i = fmap (Prelude.^ i) x

instance (Divisible a, Applicative (f t)) => Divisible (f t a) where
  (/) = liftA2 (Prelude./)

instance Interpret (->) where
  eval _ f = arr f
  compare _ (TimeGte t) = arr (>= t)
  compare _ (Lte (f, f')) = arr (liftA2 (Prelude.<=) f f')
  mapParams g _ f = getOp . contramap g . Op . fmap f -- There is no special `observe` op for functions - just use `lift`.
